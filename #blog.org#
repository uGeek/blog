#+TITLE: uGeek Blog 
#+LINK: https://ugeek.github.io/blog
#+DESCRIPTION: Blog de Tecnología, Android, GNU Linux, Servidores, y mucho más. Blog vinculado al Blog del Podcast de uGeek
#+KEYWORDS: GNU, linux, Raspberry, android, domótica 
#+AUTHOR: Angel
#+LANGUAGE: es
#+STARTUP: inlineimages
#+SEQ_TODO: TODO(t) NEXT(n) DESARROLLO(r) NO_PROBADO(p) | DONE(d)
#+OPTIONS: ^:nil

* TODO Instala la última versión de Pandoc
:PROPERTIES:
:TITLE: Instala la última versión de Pandoc
:EXPORT_FILE_NAME: Instala la última versión de Pandoc
:DESCRIPTION: Si en tu PC como yo, tienes una versión antigua como Ubuntu 18.04, te darás cuenta que la versión de Pandoc esta muy desactualizada
:EXPORT_DATE: 2019-08-14 23:00
:CATEGORY: pandoc
:TAG:      notas,orgmode,markdown,bash
:IMAGE: ./images-blog/ugeek.png
:END:


Si en tu PC como yo, tienes una versión antigua como Ubuntu 18.04, te darás cuenta que la versión de Pandoc esta muy desactualizada. Instalar la última versión de Pandoc para arquitectura 64 bits, es muy fácil.

** Instalación
Accederemos al [[https://github.com/jgm/pandoc/releases][repositorio de Pandoc en GitHub]] y descargaremos la última versión. 

En el momento de escribir este post, estamos en la versión 2.7.3.

=sudo dpkg -i pandoc-2.7-3-amd64.deb=

Comprobaremos si ya tenemos la última versión instalada correctamente:

=pandoc --version=

** Fuente
- https://pandoc.org/
- [[https://github.com/jgm/pandoc/releases][Repositorio de Pandoc en GitHub]]

* TODO Exportando tu Notas de Google Keep a Org Mode o Markdown
:PROPERTIES:
:TITLE: Exportando tu Notas de Google Keep a Org Mode o Markdown
:EXPORT_FILE_NAME: Exportando tu Notas de Google Keep a Org Mode o Markdown
:DESCRIPTION: Hay quien no se acostumbra a utilizar Orgzly ni Emacs cuando toma notas con su movil, en cambio le gustaría el tener el backup de todas las notas de su cuenta Google Keep en un único archivo Org Mode. También hay quien le gustaría tenerlas en Markdown
:EXPORT_DATE: 2019-07-26 22:00
:CATEGORY: emacs
:TAG:      notas,orgmode,markdown,bash,python
:IMAGE: ./images-blog/keep.png
:END:

Hay quien no se acostumbra a utilizar Orgzly ni Emacs cuando toma notas con su movil, en cambio le gustaría el tener el backup de todas las notas de su cuenta Google Keep en un único archivo Org Mode. También hay quien le gustaría tenerlas en Markdown. 
#+HTML: <center>
[[./images-blog/keep.png]]
#+HTML: </center>
Esto, gracias a un par de scripts, no es tarea imposible. Estaba empezando ha hacer yo el script y pensé: ¿No habrá alguien que lo ha hecho primero?. He encontrado en GitHub un script en Bash de [[https://github.com/jLouisIV/][jLouisIV]] y otro en Python de [[https://github.com/makuto/][makuto]].

Voy a explicarte como hacer ambos procesos y veras que no es nada complejo.

** Descargando una copia de nuestra notas
Lo primero que tenemos que hacer es ir a la página de [[https://takeout.google.com/settings/takeout][Google Takeout]] y descargar un archivo *.zip*, que contiene todas las notas que tenemos en Google Keep. 

Descomprimimos el archivo zip que hemos descargado.

Las notas están en formato *.html*, ahora gracias a estos scripts, vamos a transformarlas a Org Mode o Markdown.

** Google Keep a Org Mode
Clonamos el repositorios:
#+BEGIN_SRC 
git clone https://github.com/uGeek/KeepToOrg.git
#+END_SRC
Entramos en la carpeta del repositorio:
#+BEGIN_SRC 
cd KeepToOrg
#+END_SRC
Ejecutamos el script especificando en que carpeta hemos descomprimido nuestro archivo zip de notas de Google Keep y en que destino queremos dejar nuestros archivos Org Mode.

Ejemplo:
#+BEGIN_SRC 
python3 KeepToOrg.py ~/Takeout/ ~/Carpeta_Destino
#+END_SRC
El Script nos creará un archivo Org Mode por cada etiqueta que tengamos en Google Keep y dentro del archivo, todas las notas pertenecientes a esta etiqueta.

** Google Keep a Markdown
Este script solo extrae el texto y las listas numeradas. Otros tipos de datos (es decir, casillas de verificación) no causarán errores, pero se extraerá muy poco de su contenido.

Las Notas con dos o más etiquetas se guardará en el archivo 'MULTIPLE TAGS' y las notas sin ninguna etiqueta se guardarán en el archivo 'NOTES NOT TAGGED'

Las notas etiquetadas con todos los caracteres que no sean alfanuméricos, espacios, guiones o guiones bajos se guardarán en el archivo 'TAG WITHOUT VALID CHARS'.

El proceso va a ser similar al script anterior, pero en este caso utilizaremos Bash:

Vamos a situarnos dentro de la carpeta descomprimida, en la ruta /Takeout/keep 

Clonamos el repositorio, para descargar el script:
#+BEGIN_SRC 
git clone https://github.com/uGeek/keep-notes-script.git
#+END_SRC
Damos permisos de ejecución:
#+BEGIN_SRC 
sudo chmod +x keep-notes-script.sh
#+END_SRC
Ahora ejecutaremos el script:
#+BEGIN_SRC 
./keep-notes-script.sh
#+END_SRC
El Script nos creará un archivo Markdown por cada etiqueta que tengamos en Google Keep y dentro del archivo, todas las notas pertenecientes a esta etiqueta.

** Fuentes
- https://github.com/makuto/KeepToOrg
- https://github.com/jLouisIV/keep-notes-script

Mis Forks, por si desaparece la fuente original:

- https://github.com/uGeek/KeepToOrg
- https://github.com/uGeek/keep-notes-script

* TODO Actualización automática de tus dockers con Watchtower o Ouroboros
:PROPERTIES:
:TITLE: Actualización automática de tus dockers con Watchtower o Ouroboros
:EXPORT_FILE_NAME: Actualización automática de tus dockers
:DESCRIPTION: Watchtower es una aplicación que controlará sus contenedores Docker en funcionamiento y observará los cambios en las imágenes a partir de los cuales se iniciaron originalmente esos contenedores
:EXPORT_DATE: 2019-07-26 20:30 2020-6-2
:CATEGORY: docker
:TAG:      terminal,ubuntu,raspberry
:IMAGE: ./images-blog/docker.png
:END:


** Watchtower
Watchtower es una aplicación desarrollada en Go, que controlará tus contenedores Docker en funcionamiento y observará los cambios en las imágenes a partir de los cuales se iniciaron originalmente esos contenedores. Si la Watchtower detecta que una imagen ha cambiado, se reiniciará automáticamente el contenedor utilizando la nueva imagen.

Watchtower desplegará su nueva imagen, parará su contenedor y lo reiniciará con las mismas opciones que se usaron cuando se implementó inicialmente.

*** En tu servidor con amd64
#+BEGIN_SRC 
docker run -d --name watchtower --cleanup -v /var/run/docker.sock:/var/run/docker.sock v2tec/watchtower
#+END_SRC

La opción --cleanup, permite borrar las imagenes antiguas.
*** Tu Raspberry Pi o placa con arquitectura ARM
#+BEGIN_SRC 
docker run -d --name watchtower -v /var/run/docker.sock:/var/run/docker.sock v2tec/watchtower:armhf-latest
#+END_SRC

** Ouroboros
Desarrollada en python, Ouroboros hace lo mismo que Watchtower, pero además, elimina las imagenes antiguas. 

Del mismo modo que Watchtower, Ouroboros utiliza la API de docker mediante el socket local.

#+BEGIN_SRC 
docker run -d --name ouroboros \
 -v /var/run/docker.sock:/var/run/docker.sock \
 pyouroboros/ouroboros
#+END_SRC

Os inico algunas de las muchismas opciones que tiene y he visto en el [[https://elblogdelazaro.gitlab.io/2019-09-05-ouroboros-el-sucesosr-de-watchtower/][Blog de Lazaro]]
- Monitorea y actualiza contenedores en múltiples servidores remotos que ejecutan Docker
- Monitorea la etiqueta de la imagen actual o va directamente a latest
- Ignorar contenedores específicos
- Soporte para registros privados.
- Personalizar el intervalo pull
- Supervisar contenedores seleccionados por nombre
- Cambiar el nivel de registro para la depuración/supresión
- Ejecuta ouroboros solo una vez para actualizar, luego termina
- Eliminar la imagen antigua de Docker al crear un nuevo contenedor
- Exporta métricas Prometheus, Influx para el tablero Grafana
- Puede desencadenar múltiples webhooks cuando se actualizan los contenedores. Admite discord, slack, pushover y webhooks genéricos
- Puede enviar correos electrónicos cuando se actualizan los contenedores



** Fuente 
- https://github.com/containrrr/watchtowre
- https://hub.docker.com/r/v2tec/watchtower/
* TODO Docker en Ubuntu 18.04
:PROPERTIES:
:TITLE: Docker en Ubuntu 18.04
:EXPORT_FILE_NAME: Docker en Ubuntu 1804
:DESCRIPTION: Vamos a instalar docker en Ubuntu 18.04
:EXPORT_DATE: 2019-07-23 18:30
:CATEGORY: docker
:TAG:      terminal,ubuntu
:IMAGE: ./images-blog/docker.png
:END:


Vamos a instalar docker en Ubuntu 18.04:

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>


** Requisitos Previos
Instalaremos primero unos requisitos que permitiran a apt usar paquetes mediante https:

=sudo apt install apt-transport-https ca-certificates curl software-properties-common=

** Clave GPG

=curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -=

** Repositorio
Añadimos el repositorio para nuestra versión de ubuntu:

#+BEGIN_SRC 
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable"
#+END_SRC

Actualizamos:

=sudo apt update=

Nos aseguramos que instalaremos desde los repositorios de docker y no de ubuntu:

=apt-cache policy docker-ce=

** Instalamos Docker CE y Docker Compose
#+BEGIN_SRC 
apt -y install docker-ce docker-compose
#+END_SRC

** Iniciamos Docker y lo habilitamos para que se inicie al reiniciar
#+BEGIN_SRC 
systemctl enable docker
systemctl start docker
#+END_SRC
** Comprobamos la versión de docker y si está instalado

=docker -v=

** Añadimos a nuestro usuario para controlar Docker

Creamos el grupo docker:
#+BEGIN_SRC 
groupadd docker
#+END_SRC

Añadimos al usuario:
#+BEGIN_SRC 
usermod -aG docker $USER
#+END_SRC
** Instalando Portainer
Sabéis que me gusta instalar Portainer, para gestionar los contenedores de un modo gráfico:

#+BEGIN_SRC 
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
#+END_SRC


* TODO Plugin zsh-autosuggestions. Autocompletado en la terminal
:PROPERTIES:
:TITLE: Plugin zsh-autosuggestions. Autocompletado en la terminal
:EXPORT_FILE_NAME: Plugin zsh-autosuggestions Autocompletado en la terminal
:DESCRIPTION: Sigo explorando y conociendo los plugin para Zsh. Zsh-autosuggestions sugiere comandos a medida que escribe en base al historial y las terminaciones
:EXPORT_DATE: 2019-07-23 18:00
:CATEGORY: zsh
:TAG:      bash,zsh,terminal
:IMAGE: ./images-blog/omzsh.png
:END:

Sigo explorando y conociendo los plugin para Zsh.

#+HTML: <center>
[[./images-blog/omzsh.png]]
#+HTML: </center>

 Zsh-autosuggestions sugiere comandos a medida que escribe en base al historial y las terminaciones. Este plugin me recuerda mucho a las sugerencias que hace la shell *fish*.

** Instalación
El método mas sencillo de instalación, es clonando el repositorio del proyecto y precargar este plugin al arrancar la terminal, desde el archivo de configuración *.zshcr*

*** Clonar el repositorio
Vamos a clonar el repositorio, en la carpeta local *~/.zsh/zsh-autosuggestions*:

=git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions=

*** Añadir en el archivo de configuración

Editamos con nano:

=nano ~/.zshrc=

Añadimos esta línea:

=source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh=

Reiniciamos nuestra terminal y ya podemos disfrutar del nuevo plugin

** Fuente
- https://github.com/zsh-users/zsh-autosuggestions
* TODO Instalar Oh My ZSH
:PROPERTIES:
:TITLE: Instalar Oh My ZSH
:EXPORT_FILE_NAME: Instalar Oh My ZSH
:DESCRIPTION: Zsh es una shell que junto a Oh My Zsh, un framework desarrollado por la comunidad, nos proporciona sugerencias cuando estamos en nuestra terminal
:EXPORT_DATE: 2019-07-22 21:20 2019-07-23 2020-06-07
:CATEGORY: zsh
:TAG:      bash,zsh,terminal
:IMAGE: ./images-blog/omzsh.png
:END:

Zsh es una shell que junto a Oh My Zsh, un framework desarrollado por la comunidad, nos proporciona sugerencias cuando estamos en nuestra terminal, así como en caso de utilizar git, conocer en que rama estamos. Voy a instalar un tema muy conocido, *agnoster*. 

#+HTML: <center>
[[./images-blog/omzsh.png]]
#+HTML: </center>

Mediante este Post, vamos a aprender a instalarlo, de un modo muy sencillo.

** Instalando  ZSH y git-core
Instalando desde los repositorios:

=sudo apt install zsh git-core=

** Descargando Oh My ZSH y ejecutarlo
Llegó la hora de Instalar Oh My Zsh

=wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh=

** Desinstalar Oh My ZSH
Si no te ha gustado oh my zsh, desinstalarlo es tan sencillo como ejecutar en la terminal:

=uninstall_oh_my_zsh=

** Cambiar la shell a ZSH
Vamos a cambiar nuestra Shell actual a zsh:

=chsh -s `which zsh`=

Si quieres cambiar la terminal a otro usuario siendo administrador, en mi ejemplo, al usuario *angel*.

#+BEGIN_SRC 
sudo chsh -s /usr/bin/zsh angel
#+END_SRC


Ahora, para que surja efecto, será necesario *reiniciar la terminal*. Si no funciona, quizás sea necesario reiniciar el Sistema Operativo.

Si no nos convence Zsh u otra shell, volveremos a bash así:

=chsh -s `which bash`=

** Que Shells hay disponibles en nuestro sistema
Para saber las shells tenemos instaladas en nuestro sistema:

=cat /etc/shells=

** Saber nuestra shell actual

=echo $SHELL=

Si tenemos zsh, nos devolverá:

=/usr/bin/zsh=

** Instalando las Fuentes Powerline para ZSH
Si en tu terminal no aparecen correctamente los símbolos, es necesario instalar:

=sudo apt install fonts-powerline=
** Temas
Voy a cambiar el tema *robbyrussell* e instalar el tema agnoster:

=nano ~/.zshrc=

Sustituye:
#+BEGIN_SRC 
# ZSH_THEME="robbyrussell"
ZSH_THEME="agnoster"
#+END_SRC
** Buscar en el historial
En la raíz del directorio $HOME, crearemos el archivo oculto *.inputrc*. Utilizaremos por ejemplo *nano*, para crear el archivo.

=nano .inputrc=

Una vez abierto, copiaremos en el siguiente contenido:
#+BEGIN_SRC 
## Flecha Arriba
"\e[A":history-search-backward
## Flecha Abajo
"\e[B":history-search-forward
#+END_SRC
** Instalarlo todo automatizado desde un script
He creado este script para que la instalación sea muchísimo más rápida:

=wget https://raw.githubusercontent.com/uGeek/blog/master/scripts/ohmyzsh ; bash  ohmyzsh ; rm ohmyzsh=

** Fuentes
- https://ohmyz.sh/
- http://zshwiki.org/

* TODO Compartiendo tus Dockers
:PROPERTIES:
:TITLE: Compartiendo tus Dockers
:EXPORT_FILE_NAME: Compartiendo tus Dockers
:DESCRIPTION: Después de haber dedicado un tiempo a crear tus dockers, que mejor manera que compartirlos con la comunidad
:EXPORT_DATE: 2019-06-12 20:20
:CATEGORY: docker
:TAG:      raspberry, servidor
:IMAGE: ./images-blog/dockerhub.png
:END:



Después de haber dedicado un tiempo a crear tus dockers, que mejor manera que compartirlos con la comunidad. 

#+HTML: <center>
[[./images-blog/dockerhub.png]]
#+HTML: </center>

Ya os expliqué un ejemplo de [[https://ugeek.github.io/blog/post/2019-02-10-servidor-ejabberd-xmpp-en-tu-raspberry-mediante-docker-y-dockerfile.html][como crear tu docker mediante los dockerfile]]. La verdad es que es muy pesado tener que crear la imagen de cero, cuando en realidad una vez hemos creado la imagen, podemos subirla al DockerHub y una vez allí, instalarlo en todos los dispositivos que sean compatibles con su arquitectura. 

Voy a explicarte como renombrar y subir esta imagen al DockerHub

** Iniciando en la terminal
Dando por hecho que ya has creado tu cuenta en [[https://hub.docker.com][DockerHub]], vamos a logearnos en nuestra terminal:

=docker login=

La terminal nos preguntará por nuestro usuario y contraseña.

** Nombre de la imagen
El nombre de la imagen tiene esta estructura:

*<USUARIO>/<REPOSITORIO>:<ETIQUETA>*

Ejemplo:

=ugeek/ejabberd:arm=

Una vez tengamos la imagen creada siguiendo el Post [[https://ugeek.github.io/blog/post/2019-02-10-servidor-ejabberd-xmpp-en-tu-raspberry-mediante-docker-y-dockerfile.html][como crear tu docker mediante los dockerfile]], vamos a renombrarla siguiendo la estructura.
** Cambiar nombre de la imagen

Vamos a ver las imágenes:

=docker image=

Imagina que he creado un docker de webdav, para arquitectura arm. En el comando anterior, he tomado buena nota del número de la imagen *<IMAGE>*, para añadirlo en el siguiente comando.

=docker tag <IMAGE> ugeek/webdav:arm=

Si lo deseamos, ahora podemos borrar la imagen antigua.

=docker rmi <IMAGE>= 

** Subir imagen
Igual que hariamos con *git*, vamos ha hacer un docker push para subir mi nueva imagen.

=docker push ugeek/webdav:arm=

** Conclusión
Esto era una cosa que no había hecho por pereza y la verdad es que funciona super bien. Ahora gracias a la copia de mis dockers en DockerHub, tengo un backup disponible para montarlo en cualquier máquina y lo puedo compartir. Te animo a probar y crear tus dockers.
* TODO Montar un servidor webdav con dafs2 
:PROPERTIES:
:TITLE:    Montar un servidor webdav con dafs2
:EXPORT_FILE_NAME: Montar un servidor webdav con dafs2
:DESCRIPTION: vamos a ver como montar en tu PC o Servidor este servidor webdav que podemos encontrar en nubes como Nextcloud, Owncloud, Box.com, Yandex... en una carpeta local. Para ello vamos a utilizar dafs2
:EXPORT_DATE: 2019-06-11 20:20
:CATEGORY: servidor
:TAG:      webdav,raspberry
:IMAGE: ./images-blog/dav.png
:END:

En próximos Podcast y Posts, os hablaré de como montar un servidor con webdav, para sincronizar nuestros archivos. 

#+HTML: <center>
[[./images-blog/dav.png]]
#+HTML: </center>

Ahora de momento, vamos a ver como montar en tu PC o Servidor este servidor webdav que podemos encontrar en nubes como Nextcloud, Owncloud, Box.com, Yandex... en una carpeta local. Para ello vamos a utilizar dafs2.

** Instalación
La instalación la haremos desde los repositorios:

=sudo apt-get install davfs2=

Seleccionanos *YES*, indicando que cualquiera que no sea usuario root, pueda montar una unidad.

Creamos una carpeta, por ejemplo la llamaremos webdav, para montar después nuestro servidor.

=mkdir -p ~/webdav=

Reconfigurar davfs2:

=sudo dpkg-reconfigure davfs2=


** Montar
Vamos a montar nuestra servidor webdav en la carpeta local llamada webdav.

=sudo mount.davfs https://<URL>/ ~/webdav=

también podemos utilizar:
#+BEGIN_SRC 
sudo mount -t davfs -o noexec https://<URL>/ ~/webdav
#+END_SRC
** Desmontar 
#+BEGIN_SRC 
sudo fusermount -u ~/webdav
#+END_SRC
** Conclusión
En pocos pasos, podemos acceder a la totalidad de los archivos del servidor webdav y sincronizarlos con todos nuestros dispositivos.
* TODO Convertir de Markdown a Org Mode gracias a Pandoc
:PROPERTIES:
:TITLE:    Convertir de Markdown a Org Mode gracias a Pandoc
:EXPORT_FILE_NAME: Convertir-de-markdown-a-org-Mode-gracias-a-pandoc
:DESCRIPTION: Vamos a convertir nuestros archivos Markdown a Org Mode gracias a Pandoc
:EXPORT_DATE: 2018-12-28 18:05 2021-01-01
:CATEGORY: emacs
:TAG:      emacs,pandoc,orgmode,markdown
:IMAGE: ./images-blog/ugeek.png
:END:

Vamos a convertir nuestros archivos Markdown a Org Mode gracias a Pandoc. Para ello, primero necesitamos instalar Pandoc en nuestro Ubuntu:

#+BEGIN_SRC 
sudo apt install pandoc
#+END_SRC

Ahora tenemos 2 posibilidades, transformar únicamente un archivo .md a .org, o aprovechando la magnífica gestión de los archivos Org Mode, convertir todos los archivos Markdown de una carpeta a un único archivo Org Mode.

** Markdown a Org Mode
Markdown a Org Mode. Ejecutamos este comando en la terminal.

- Para indicar el número de caracteres por línea que tendrá la conversión, utiliza la opción =--columns NUMERO_DE_CARACTERES= 
- La opción =-t=, significa que transformamos markdown a orgmode
- La opción =-o=, significa el archivo de salida será el que indiquemos a continuación

#+BEGIN_SRC 
pandoc -s -f markdown -t org archivo_a_convertir.md -o nuevo_archivo.org
#+END_SRC

Cambiando el orden

#+BEGIN_SRC 
pandoc -f markdown -t org -o nuevo_archivo.org archivo_a_convertir.md
#+END_SRC


Al hacer la conversión, Pandoc incluye en cada cabecera las propieties. Para eliminarlas podemos utilizar *sed*

#+BEGIN_SRC 
pandoc  -f markdown -t org archivo.md  --columns 10000 | sed -E  "/^[[:space:]]+:/ d" > nuevo_archivo.org
#+END_SRC


*** Más fácil y comprensible
La traducción de lo que estamos haciendo sería: Transformamos con *Pandoc* "*-t*" a *org* el *archivo.md*. Utilizaremos un máximo de 10000 caracteres por línea y con *sed*, eliminamos las propieties

#+BEGIN_SRC 
pandoc -t org archivo.md --columns 10000 | sed -E "/^[[:space:]]+:/ d"
#+END_SRC


#+BEGIN_SRC 
pandoc -t org archivo.md --columns 10000 | sed -E "/^[[:space:]]+:/ d" > archivo.org
#+END_SRC




** Muchos Markdown en un único archivo Org Mode
Muchos archivos Markdown a un único Org Mode.

*** find
Vamos a la carpeta donde están todos los Markdown que queremos convertir y Llamamos a find vía Pandoc:

#+BEGIN_SRC 
find . -name \*.md -type f -exec pandoc  -f markdown -t org -o {}.org {} \;
#+END_SRC


*** for

#+BEGIN_SRC 
for f in `ls *.md`; do 
  pandoc -f markdown -t org -o ${f}.org ${f}; 
done
#+END_SRC





Recordar verificar que la conversión se ha hecho correctamente.

* TODO Eliminar líneas en Blanco con sed
:PROPERTIES:
:TITLE:    Eliminar líneas en Blanco con sed
:EXPORT_FILE_NAME: eliminar-lineas-en-blanco
:DESCRIPTION: Como podemos eliminar líneas en Blanco
:EXPORT_DATE: 2018-12-27 13:22
:CATEGORY: unix
:TAG:      bash,unix,terminal,sed
:IMAGE: ./images-blog/ugeek.png
:END:

Para eliminar líneas en Blanco de un archivo de texto, podriamos utilizar *sed*.

#+HTML: <center>
[[./images-blog/sed.png]]
#+HTML: </center>


=cat archivo | sed '/^ *$/d' > nuevo_archivo=

* TODO Con Emacs, también podemos editar Markdown
:PROPERTIES:
:TITLE:    Con Emacs también podemos editar Markdown
:EXPORT_FILE_NAME: Con Emacs tambien podemos editar Markdown
:DESCRIPTION: He hablado de como crear tus archivos Org Mode mediante Emacs, pero… ¿Realmente vale la pena invertir tiempo en aprender los atajos de teclado y el funcionamiento de Emacs?
:EXPORT_DATE: 2019-01-03 18:08
:CATEGORY: emacs
:TAG:      emacs, orgmode, markdown, melpa
:IMAGE: ./images-blog/ugeek.png
:END:

He hablado de como crear tus archivos Org Mode mediante Emacs, pero… ¿Realmente vale la pena invertir tiempo en aprender los atajos de teclado y el funcionamiento de Emacs?.
Por supuesto que Sí!!! Y es que Emacs no solo funciona con Org Mode, sino que con cualquier sintaxis o cosa que se os ocurra.
Hoy vamos a utilizar Emacs como editor de Markdown. Voy a dividir el post en 2 partes, resaltado de sintaxis y previsulización del documento que estamos editando con refresco instantáneo.
Resaltado de Sintaxis

Para que Emacs resalte la sintaxis de Markdown, necesitamos instalar un paquete que encontraremos en [[https://melpa.org/][Melpa]], [[https://github.com/jrblevin/markdown-mode][markdown-mode]].

** Instalación

=M-x package-install RET markdown-mode RET=

** Previsualización del documento

Para previsualizar el documento, instalaremos el paquete también de Melpa, Flymd.

Instalación:

=M-x package-install RET flymd RET=

Ahora si queremos previsualizar el documento, solo tenemos que introducir en Emacs:

=M-x flymd-flyit=

Esto, nos lanzará un archivo temporal y abrirá nuestro navegador web, para previsualizar el documento.

Por defecto se refresca en tiempo real y que podemos deshabilitar

* TODO Kde Connect en Ubuntu, Debian, Lubuntu, Mint... y derivadas
:PROPERTIES:
:TITLE:    Kde Connect en Ubuntu...
:EXPORT_FILE_NAME: kdeconnect-en-ubuntu
:DESCRIPTION: He instalado Kde Connect en Lubuntu y Mint con el escritorio i3. Os detallo como instalarlo paso a paso
:EXPORT_DATE: 2019-01-02 18:00
:CATEGORY: bash
:TAG:      bash, terminal, i3, kdeconnect, ubuntu
:IMAGE: ./images-blog/ugeek.png
:END:

He instalado Kde Connect en Lubuntu y Mint con el escritorio i3. Os detallo como instalarlo paso a paso.

Hasta el paso 3, ya estaría listo gracias a indicator-kdeconnect mediante interfaz gráfica. Pero si te animas con la terminal, llega hasta el final del post.

Recordaros que Kde Connect está tanto en Google Play como en F-Droid para Android.

** Instalación

1) Instalamos en nuestro Ubuntu

=sudo apt install kdeconnect=

Si tienes una versión superior a Ubuntu 16.04, incator-kdeconnect posiblemente estará disponible, en caso contrario, el equipo de webupd8team nos lo pone fácil.
Instala esto:

#+BEGIN_SRC 
sudo add-apt-repository ppa:webupd8team/indicator-kdeconnect
sudo apt update
sudo apt install kdeconnect indicator-kdeconnect
#+END_SRC

2) Instalamos la app en nuestro movil, tablet…

3) Buscará dentro de nuestra red local los dispositivos con Kde Connect. Empareja tu dispositivo y… Ya está!! Si quieres seguir con la terminal, sigue leyendo.

4) Vamos ha hacer el emparejamiento desde la Terminal. El comando *kdeconnect-cli - -help* nos mostrará todos los comandos disponibles.

5) Vamos a listar dispositivos disponibles en nuestra red local desde la terminal

=kdeconnect-cli -l=

La terminal nos mostrará todos los dispositivos disponibles, en mi caso, mi Xiaomi A1:
#+BEGIN_SRC 
angel@angel /usr/lib/kde4 $ kdeconnect-cli -l
        - Xiami A1: 35826fca13f58Gsu (reachable)
	    1 device found  
#+END_SRC
    
6) Vinculamos PC a mi Xiaomi A1 con nuestro:

=kdeconnect-cli -d 35826fca13f58Gsu --pair=

7) En tu movil, tablet Android, recibirás una solicitud para vincularlo.

8) Ya está condectado Kde Connect!!!

Si tienes i3 y quieres que se inicie Kde Connect por defecto, escribe estas líneas en tu archivo de configuración:
#+BEGIN_SRC 
# Autostart kdeconnect
exec --no-startup-id /usr/bin/indicator-kdeconnect
#+END_SRC

* TODO Crear listas m3u para minidlna o vlc
:PROPERTIES:
:TITLE:    Crear listas m3u para minidlna o vlc
:EXPORT_FILE_NAME: crear-listas-m3u-para-minidlna-o-vlc
:DESCRIPTION: Un archivo *.m3u*, es un archivo de texto que contiene un listado de archivos multimedia que es muy utilizado por muchos reproductores como vlc...
:EXPORT_DATE: 2019-01-02 20:00
:CATEGORY: bash
:TAG:      bash, grep ,ls ,unix ,servidor, minidlna, multimedia
:IMAGE: ./images-blog/ugeek.png
:END:

Un archivo *.m3u*, es un archivo de texto que contiene un listado de archivos multimedia que es muy utilizado por muchos reproductores como vlc.
Cuando viste el artículo de [[https://ugeek.gitlab.io/2018-12-27-minidlna.html][minidlna]], te preguntarías como hacer las playlist de este servidor. Pues ahora te explicaré como crear automáticamente listas desde tu terminal en segundos.

** Crear lista para minidlna

- Para crear la lista, no hace falta que especifiquemos la ruta del archivo en nuestro servidor, solo poniendo el nombre del mismo, minidlna buscará en su base de datos donde está este para reproducirlo.
- No importa el lugar donde esté el archivo .m3u, nuestro servidor minidlna lo agregará a su base de datos y así al grupo de playlists.

** Lista dentro de un directorio

1) Nos situamos en el directorio:
=ls -1 | grep .mp3 > lista.m3u=

*** Explicación del comando de listado

 - ls -> lista archivos dentro de la carpeta
 - -1 -> mostrar un archivo por línea
  
Después, podríamos ordenar el listado de diferente maneras, por ejemplo con comandos como *sort*.

** Lista recursiva entrando dentro de subcarpetas

=ls -1 -R | grep .mp3 > lista.m3u=

** Reproducir la lista desde nuestra terminal con vlc

=vlc lista.m3u=

* TODO Redirigir el tráfico de una página web a otra
:PROPERTIES:
:TITLE:    Redirigir el tráfico de una página web a otra
:EXPORT_FILE_NAME: redirigir-el-trafico-de-pagina-web-a-otra
:DESCRIPTION: Hay veces que queremos redirigir el tráfico de una página a otra...
:EXPORT_DATE: 2018-12-29 18:00 2019-01-19
:CATEGORY: html
:TAG:      html,servidor
:IMAGE: ./images-blog/ugeek.png
:END:

Hay veces que queremos redirigir el tráfico de una página a otra. Un modo muy rápido y sencillo, sería crear un archivo .html con el siguiente código. En este ejemplo, el tiempo de espera hasta redirigir es de *3 segundos*. Podemos personalizarlo al tiempo de deseemos. 
#+BEGIN_SRC
<html>
<head>
<title>Redirigir al navegador a otra URL</title>
<META HTTP-EQUIV="REFRESH" CONTENT="3;URL=https://ugeek.gitlab.io">
</head>
<body>
Esta página te redigirá en 3 segundos a https://ugeek.gitlab.io/
</body>
</html> 
#+END_SRC

* TODO Eliminar comentarios de nuestros script
:PROPERTIES:
:TITLE:    Eliminar comentarios de nuestros script
:EXPORT_FILE_NAME: eliminar-comentarios-de-nuestros-script
:DESCRIPTION: Es muy probable que al crear un script para entender mejor lo que estas haciendo tomes un exceso de notas...
:EXPORT_DATE: 2018-12-30 18:00
:CATEGORY: unix
:TAG:      bash, grep, sed, unix
:IMAGE: ./images-blog/ugeek.png
:END:

Es muy probable que al crear un script, para entender mejor lo que estas haciendo, tomes un exceso de notas. Para eliminar estas en , *bash*, va a ser tan sencillo como hacer uso de nuestro querido *grep*:

=cat archivo.sh |  grep -v ^# > archivo_nuevo.sh=

Si además quieres eliminar también las líneas que quedaran en blanco, como expliqué en otro post, utilizaremos *sed*::

=cat archivo.sh |  grep -v ^# | sed '/^ *$/d' > archivo_nuevo.sh=

* TODO minidlna
:PROPERTIES:
:TITLE:    minidlna
:EXPORT_FILE_NAME: minidlna
:DESCRIPTION: DLNA es un servidor multimedia
:EXPORT_DATE: 2018-12-27 21:00 2019-02-24 2019-03-24
:CATEGORY: servidor
:TAG:      servidor,raspberry,minidlna,multimedia
:IMAGE:    ./images-blog/dlna.png
:END:

DLNA es un servidor multimedia (video, audio y fotos) muy ligero, ya que simplemente hará una transferencia del archivo solicitado.

#+HTML: <center>
[[./images-blog/dlna.png]]
#+HTML: </center>

** Instalación

=sudo apt install minidlna=

** Archivo de configuración del servicio

=sudo nano /etc/minidlna.conf=

Añadiremos al inicio del archivo de configuración, la ruta donde están nuestros archivos multimedia. Ejem:

#+BEGIN_SRC 
media_dir=V,/media/Peliculas
media_dir=P,/media/Fotos
media_dir=A,/media/Musica
#+END_SRC

Si nuestro carpeta contiene, por ejemplo, vídeos y fotos, especificaremos de la siguiente manera:

=media_dir=PV,/media/Peliculas_y_ Fotos=

Si tenemos nuestros archivos multimedia en dos o más carpetas, podemos especificarlo así:
#+BEGIN_SRC 
media_dir=A,~/Música
media_dir=A,/media/Musica
#+END_SRC

** Descubrir el servidor en nuestra Red

Quitaremos la "#" delante de inotify y pondremos *yes*.
#+BEGIN_SRC  
# Automatic discovery of new files in the media_dir directory. 
inotify=yes
#+END_SRC

** Poner nombre a nuestro servidor

Aquí podremos poner nombre a nuestro servidor:
#+BEGIN_SRC
# Name that the DLNA server presents to clients.
friendly_name=Mi Servidor DLNA
#+END_SRC

** Añadir nuevo contenido Multimedia 
Para que todos los nuevos archivos multimedia que añadamos, sean añadidos de forma automática a nuestro servidor, deberemos tener habilitada esta opción en el archivo de configuración:
#+BEGIN_SRC 
# Automatic discovery of new files in the media_dir directory.
inotify=yes
#+END_SRC
**  Crear nueva base de datos
Para crear una nueva base de datos en nuestro servidor y eliminar la actual, por ejemplo, en el caso que cambiemos las carpetas donde esté nuestro contenido multimedia:

Borraremos la base de datos:  

=sudo rm -f /var/cache/minidlna/files.db=

Reiniciaremos el servidor

=sudo service minidlna restart=

Como has podido ver en este paso anterior, la base de datos así como las portadas de los archivos multimedia, están defecto en la carpeta */var/cache/minidlna*. Pero en el archivo de configuración, podemos cambiar la ruta. Para ello desmarcaremos la almohadilla y especificaremos la ruta deseada.

#+BEGIN_SRC 
# Path to the directory that should hold the database and album art cache.                                                                  
#db_dir=/var/cache/minidlna  
#+END_SRC

** Iniciar, Detener, Restaurar servicio

=exec /usr/sbin/service minidlna start=

o

=sudo systemctl start minidlna.service=

o

=sudo service minidlna start=

=sudo service minidlna stop=

=sudo service minidlna restart=



** Forzar el reescaneado

Cuando añadamos nuevo contenido a nuestra Biblioteca multimedia, es posible que no aparezca, esto se soluciona forzando la recarga de nuestra base de datos:

=sudo minidlnad -R ; sudo service minidlna restart=

o sino, podemos hacer:

=sudo service minidlna force-reload=

Si accedemos a nuestra IP:8200, veremos todo el contenido disponible a través de nuestro servidor DLNA.
** Puertos

En caso de tener cortafuegos, recordar abrir los puertos del servicio para poder acceder:
- TCP = 8200
- UDP = 1900

* TODO Kde Connect en Emacs
:PROPERTIES:
:TITLE:    Kde Connect en Emacs
:EXPORT_FILE_NAME: kde-connecte-en-emacs
:DESCRIPTION: Por culpa del [[https://www.atareao.es/podcast/integrando-android-con-ubuntu/][Podcast de atareao.es]], he estado probando Kde Connect y la verdad es que ha pasado a ser una aplicación imprescindible en mi día a día. Tal como explica en su Podcast, existe la posibilidad de utilizarla con Emacs y como podéis imaginar, no me he podido resistir a probarla. Os explico como utilizarla
:EXPORT_DATE: 2018-12-31 22:00
:CATEGORY: emacs
:TAG:      emacs,sincronización,kdeconnect
:IMAGE: ./images-blog/ugeek.png
:END:

Por culpa del [[https://www.atareao.es/podcast/integrando-android-con-ubuntu/][Podcast de atareao.es]], he estado probando Kde Connect y la verdad es que ha pasado a ser una aplicación imprescindible en mi día a día. Tal como explica en su Podcast, existe la posibilidad de utilizarla con Emacs y como podéis imaginar, no me he podido resistir a probarla. Os explico como utilizarla:

** Instalación

Teniendo los repositorios de Melpa:

    1) Instalación: *M-x package-install RET kdeconnect*
    2) Listamos los dispositivos de nuestra red local: *M-x kdeconnect-list-devices*
    3) Buscamos los búfer anteriores para copiar los id de nuestros dispositivos (C-x Izquierda)
    4) Introducimos el id de nuestro dispositivo: *M-x kdeconnect-select-active-device RET id*
    5) Hacemos un ping para comprobar que se ha conectado correctamente: *M-x kdeconnect-ping*

YA ESTA!!!

*Ahora si copiamos un texto en el portapapeles de nuestro Emacs, podremos pegarlo en el otro dispositivo gracias a Kde Connect.*

Vamos a enviar un texto desde Emacs al otro dispositivo *M-x kdeconnect-ping-msg RET Texto*

Os dejo el resto de funciones para que juguéis y el repositorio donde está toda la información:

** Resto de Funciones disponibles

| Función                         | 	Descripción                                                               |
|---------------------------------+-----------------------------------------------------------------------------|
| kdeconnect-get-active-device    | 	Mostrar el dispositivo activo                                             |
| kdeconnect-list-devices         | 	Muestra todos los dispositivos visibles, incluso los no disponibles.      |
| kdeconnect-ping                 | 	Enviar una notificación al dispositivo activo.                            |
| kdeconnect-ping-msg             | 	Envía una notificación con un mensaje personalizado al dispositivo activo |
| kdeconnect-refresh              | 	Escanee la red y actualice las conexiones disponibles                     |
| kdeconnect-ring                 | 	Hacer que suene el dispositivo activo (útil para encontrarlo)             |
| kdeconnect-select-active-device | 	Seleccione el dispositivo activo de kdeconnect-devices                    |
| kdeconnect-enviar-archivo       | 	Enviar el archivo seleccionado al dispositivo activo                      |
| kdeconnect-enviar-sms           | 	Enviar un SMS al destino especificado                                     |

[[https://github.com/carldotac/kdeconnect.el][Repositorio en GitHub]]

* TODO Descargar todos los episodios de un Podcast con wget
:PROPERTIES:
:TITLE:    Descargar todos los episodios de un Podcast con wget
:EXPORT_FILE_NAME: descargar-todos-los-episodios-de-un-podcast-con-bash
:DESCRIPTION: Si estas en esta web probablemente conozcas mi Podcast y quizás te hayas planteado alguna vez si existe un método para descargar todos los Podcast disponibles sin necesidad de hacer uso de un programa sino desde la terminal y con wget.
:EXPORT_DATE: 2018-12-28 10:00
:CATEGORY: terminal
:TAG:      bash,podcast,unix,terminal
:IMAGE: ./images-blog/ugeek.png
:END:

Si estas en esta web, probablemente conozcas mi Podcast y quizás te hayas planteado alguna vez si existe un método para descargar todos los Podcast disponibles, sin necesidad de hacer uso de un programa, sino desde la terminal y con wget.

Tan simple como escribir esta única línea sustituyendo *"FEED"*, por el Feed del Podcast que desees descargar.
#+BEGIN_SRC 
wget -q -O- "FEED" | grep -o '<enclosure url="[^"]*' | grep -o '[^"]*$' | xargs wget -c
#+END_SRC

Como ejemplo, te dejo el Podcast de uGeek 😜
#+BEGIN_SRC  
wget -q -O- "http://feeds.feedburner.com/ugeek" | grep -o '<enclosure url="[^"]*' | grep -o '[^"]*$' | xargs wget -c
#+END_SRC
A disfrutar con la magia de la terminal...

* TODO Visualiza tus Notas Markdown Versión Web con MkDocs
:PROPERTIES:
:TITLE:    Visualiza tus Notas Markdown Versión Web con MkDocs
:EXPORT_FILE_NAME: Visualiza tus Notas Markdown Version Web con MkDocs
:DESCRIPTION: Voy a explicaros como instalar MkDocs, levantar un servidor y poder ver todas vuestras nota en una interfaz web.
:EXPORT_DATE: 2019-01-03 12:05
:CATEGORY: servidor
:TAG:      servidor,raspberry,markdown,notas
:IMAGE: ./images-blog/ugeek.png
:END:

Voy a explicaros como instalar MkDocs, levantar un servidor y poder ver todas vuestras nota en una interfaz web.

** Instalación

Instalaremos en debian, ubuntu,… con:

=sudo apt install mkdocs=

También podemos hacerlo por Python así:

=sudo pip install mkdocs=

** Iniciando

Ahora vamos a crear un nuevo proyecto, una carpeta donde depositaremos todas nuestras notas para después verlas en la web.
#+BEGIN_SRC 
mkdocs new my-project
cd my-project
#+END_SRC

** Iniciamos el servidor

=mkdocs serve=

Para acceder remotamente, desde cualquier dispositivo dentro de nuestra red local, ejecutaremos dentro de la carpeta anteriormente creada:

=mkdocs serve -a 0.0.0.0:8000=

Ahora nos conectaremos desde cualquier dispositivo a: http://ip:8000

Si quieres publicarlo en tu servidor web de un modo permanente, con un comando podremos generar un sitio estático a partir de nuestro MkDocs.

Nos situamos en la raíz de la carpeta, donde arrancamos el servidor y ejecutamos:

=mkdocs build=

Esto creará una carpeta llamada site, que contendrá todos los archivos de nuestra web estática.

* TODO El poder de la terminal y el scripting
:PROPERTIES:
:TITLE:    El poder de la terminal y el scripting
:EXPORT_FILE_NAME: El poder de la terminal y el scripting
:DESCRIPTION: Hace más de medio año que los chicos de Slimbook crearon lo que llaman un Centro de divulgación y aprendizaje de GNU/Linux y tecnologías abiertas, Linux Center
:EXPORT_DATE: 2019-01-03
:CATEGORY: unix
:TAG:      bash,terminal,scrits
:IMAGE: ./images-blog/ugeek.png
:END:

Hace más de medio año que los chicos de [[https://slimbook.es/][Slimbook]] crearon lo que llaman un Centro de divulgación y aprendizaje de GNU/Linux y tecnologías abiertas, [[https://linuxcenter.es/][Linux Center]].
El objetivo principal, es el de dar conocimiento tanto del Software Libre como de GNU/Linux. Allí se brinda la posibilidad, tanto de ofrecer charlas como asistir a ellas de forma totalmente gratuita. Afortunadamente, todos aquellos que vivimos lejos de Valencia, podemos ver estas a través de su [[https://www.youtube.com/channel/UCEGWt2UciVyz1MC7rYtBg6w][canal en YouTube]]. Os dejo esta charla muy interesante sobre la terminal que impartió  Raúl Rodrigo.


#+HTML: <center>
#+HTML: <iframe width="560" height="315" src="https://www.youtube.com/embed/AgvRdj2-Yog" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  
#+HTML: </center>


* TODO Crear un Blog en GitLab. GitLab Pages
:PROPERTIES:
:TITLE:    Crear un Blog en GitLab. GitLab Pages
:EXPORT_FILE_NAME: Crear un Blog en GitLab. GitLab Pages
:DESCRIPTION: Crear un blog en GitLab no es una mala decisión, teniendo en cuenta que nos proporciona un hosting totalmente gratuito, a través de las GitLabPages y sin límite de espacio ni tráfico.
:EXPORT_DATE: 2019-01-04 14:36
:CATEGORY: git
:TAG:      gitlab, servidor, blog, html, git
:IMAGE: ./images-blog/ugeek.png
:END:

#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>

** Intro

Crear un blog en GitLab no es una mala decisión, teniendo en cuenta que nos proporciona un hosting totalmente gratuito, a través de las [[https://pages.github.com/][GitLabPages]] y sin límite de espacio ni tráfico. El único limite, creo recordar, es que los archivo que subamos no pueden exceder de 15mb. Aún así, para mi es más que suficiente. 

Dando por hecho que ya tienes una cuenta creada, solo falta decidir si el repositorio que vas a crear, será como uno de tus proyectos o vas a crear un grupo. El punto positivo de crear el grupo, es que podrás elegir una url tipo miblog.gitlab.io.

También decir que el repositorio que crees, a diferencia de GitHub, podrás hacerlo tanto público como privado. Eso no exime el correcto funcionamiento de la Página en el servidor web. 

Imaginar tener vuestra Raspberry con git instalado y enviando información a nuestro servidor GitLab mediante cron. Esto puede ser muy muy interesante, una puerta de acceso al mundo exterior. jejeje

** Creamos el repositorio

Una vez creado el repositorio, tendremos que crear un archivo llamado  *.gitlab-ci.yml* y dentro de este, escribir el siguiente código:
#+BEGIN_SRC 
pages:
  script:
  - mkdir .public
  - cp -r * .public
  - mv .public public
  artifacts:
    paths:
    - public
  only:
  - master
#+END_SRC

** Crear el servidor

1) Vamos al apartado *CI/CC*
2) Vamos a *Configuración -> General -> Avanced -> Expand*
3) En Path, añadimos junto al proyecto, el dominio que queremos utilizar. Ejem: miblog.gitlab.io
4) Esperamos aproximadamente un minuto, veremos desde la página de GitLab una animación de una redonda que va cargando y...

Ya Está!!! Nuestro servidor esta funcionando!!!

* TODO Elimina archivos duplicados con fdupes
:PROPERTIES:
:TITLE:    Elimina archivos duplicados con fduples
:EXPORT_FILE_NAME: Elimina archivos duplicados con fduples
:DESCRIPTION: fduples es una herramienta que está disponible en los repositorios y nos permite eliminar ficheros duplicados
:EXPORT_DATE: 2019-01-05 11:39
:CATEGORY: terminal
:TAG:      bash,unix,terminal
:IMAGE: ./images-blog/ugeek.png
:END:

fduples es una herramienta que está disponible en los repositorios y nos permite eliminar ficheros duplicados:

** Instalación

=sudo apt install fdupes=

** Ver cuantos archivos duplicados tenemos

Para *ver los archivos duplicados* en una carpeta, utilizaremos el siguiente comando:

=fdupes ~/ruta=

** Eliminar archivos duplicados

En caso de aparecer archivos, para eliminarlos, utilizaremos =-d=:

=fdupes -d ~/ruta=

Tranquilo, esto no eliminará los archivos, simplemente mostrará un asistente donde aparecerán los archivos repetidos y cual de ellos, mediante un número delante, queremos conservar:

#+BEGIN_SRC 
Set 1 of 147, preserve files [1 - 2, all]: 1

   [+] /home/angel/fotos/photo_0001.jpg
   [-] /home/angel/fotos/2019-01-05-15:15.jpg
#+END_SRC
Para entrar recursivamente a subcarpetas dentro de esta, utilizaremos como siempre =-r=

=fdupes -d ~/ruta=
* TODO NextcloudPi. Nextcloud en Raspbian con Docker
:PROPERTIES:
:TITLE:    NextcloudPi. Nextcloud en Raspbian con Docker
:EXPORT_FILE_NAME: NextcloudPi. Nextcloud en Raspbian con Docker
:DESCRIPTION: Tal como os prometí en el podcast, entro más al detalle con la instalación del Docker oficial de Nextcloud para Raspberry. NextcloudPi
:EXPORT_DATE: 2019-01-06 14:33
:CATEGORY: servidor
:TAG:      docker, nextcloud
:IMAGE: ./images-blog/ugeek.png
:END:

** Descargar Imagen y Crear Contenedor NextcloudPi

Tal como os prometí en el podcast, entro más al detalle con la instalación del Docker oficial de Nextcloud para Raspberry. NextcloudPi.

Si tenemos un servidor como apache2, vamos a detener el servicio para no utilizar el puerto 80, que éste utiliza por defecto.

Tendrás que modificar en este comando el usuario *pi* por tu usuario y la ip *192.168.1.100* por la ip local de tu raspberry.

#+BEGIN_SRC 
sudo docker run -d -p 4443:4443 -p 443:443 -p 80:80 -v /home/pi/docker/nextcloudplus/:/data --name nextcloudpi ownyourbits/nextcloudplus-armhf 192.168.1.100
#+END_SRC

** Iniciar Nextcloud

Una vez montado, nos conectaremos a nuestra ip:443. Nos aparecerá una web con el usuario ncp y dos contraseñas creadas de forma aleatoria.

Guardamos las 2 contraseñas y le damos a *Activar* en la parte inferior.

Una contraseña será para la web de administración de *NextcloudPi* por el puerto 4443 y la otra contraseña será para el servicio *Nextcloud* por el puerto 80 o 443.

** Crear Certificado

Si no tenemos una ip pública estática, recomiendo el utilizar un servicio como Duck DNS.

Ahora vamos a ip::4443 y vamos a crear el certificado en el apartado: Let’s Encrypt.

Abriremos los puertos 443 y 80 de nuestro Router, dirigiendo el tráfico a la ip local de nuestra Raspberry y clicaremos *Ejecutar*.

De forma automática, nos generará el certificado por 3 meses.

[[https://ownyourbits.com/nextcloudpi/][NextcloudPi]]

* TODO Crear un Blog en GitHub. GitHub Pages
:PROPERTIES:
:TITLE:    Crear un Blog en GitHub. GitHub Pages
:EXPORT_FILE_NAME: Crear un Blog en GitHub. GitHub Pages
:DESCRIPTION: Vamos a utilizar GitHub para publicar un blog, una web estática, incluso podríamos ver archivos formato en markdown
:EXPORT_DATE: 2019-01-08 17:14
:CATEGORY: git
:TAG:      git, servidor, blog, html
:IMAGE: ./images-blog/ugeek.png
:END:

Vamos a utilizar GitHub para publicar un blog, una web estática, incluso podríamos ver archivos formato en markdown.

Ya os expliqué hace días como hacerlo en GitLab, deciros que en GitHub hay un poco mas de limitaciones, pero al final, podemos hacerlo.

Algunas de las limitaciones de GitHub Pages son que las páginas no pueden ocupar mas de 1Gb, el ancho de banda no puede superar los 100Gb al mes y solo permite 10 actualizaciones por hora de la web.

Me he vuelto un poco loco con las carpetas donde estaban las imágenes, ya que las había nombrado como "__icon", "__css"... y a GitHub Pages no le gustaba que se nombraran de este modo, ya que no las mostraba. Importante, si quieres que las carpetas sean accesibles desde el servidor web, que no empiecen con símbolos raros.

** Creando la Web estática con GitHub Pages

1) Creamos el repositorio en GitHub
2) Bajamos este, a nuestro dispositivo haciendo un =git clone repositorio=
3) Ya tenemos nuestra carpeta de GitHub en local. Añadimos los archivos .html que queremos subir a nuestro GitHub Pages
4) Subimos todos los archivos a GitHub con los comandos: =git add . ; git commit -m "primer commit" ; git push=
5) Ahora vamos a habilitar el servidor web. Vamos a *Settings*
6) En el apartado *GitHub Pages*, en *Source*, cambiamos el estado de *None* a *Master Branch*. Despues pulsaremos el boton *Save*
7) Ya está guardado y si volvemos a este apartado de *GitHub Pages*, aparecerá la nueva url creada para nuestro nuevo servidor web, tipo:  https://ugeek.github.io/nombre_del_repositorio/ 

* TODO Ignorar archivos que no queremos que suban a Git
:PROPERTIES:
:TITLE:    Ignorar archivos que no queremos que suban a Git
:EXPORT_FILE_NAME: Ignorar archivos que no queremos que suban a Git
:DESCRIPTION: Es muy probable que no queramos que suban absolutamente todos nuestros archivos a nuestro repositorio en GitHub, GitLab, etc... Esto tiene un a fácil solución:
:EXPORT_DATE: 2019-01-12 21:00
:CATEGORY: git
:TAG:      git
:IMAGE: ./images-blog/ugeek.png
:END:
 Es muy probable que no queramos que suban absolutamente todos nuestros archivos a nuestro repositorio en GitHub, GitLab, etc... Esto tiene una fácil solución:
** Creando el archivo *.gitignore* para ignorar archivos 
Para determinar los archivos que queremos que no suban al repositorio, tenemos que crear una archivo de texto plano oculto llamado *.gitignore en la raíz de la carpeta en la que queramos ignorar ese tipo de archivo.*

Hay que tener en cuenta, que si lo ponemos en la raíz inicial del proyecto, esto excluirá a esa carpeta y resto de subcarpetas de este repositorio.

La sintaxis es prácticamente igual que si hiciéramos un scritp en bash. "#" podemos utilizarlo para los comentarios.

- Si no queremos que *no* suban los archivos extensión .log, utilizariamos:
 
 =*.log=
  
* TODO GPG. Cifrado de archivos simétrico
:PROPERTIES:
:TITLE:    GPG. Cifrado de archivos simétrico
:EXPORT_FILE_NAME: GPG Cifrado de archivos simetrico
:DESCRIPTION: En este post vamos a ver como cifrar simetricamente, con una contraseña, archivos mediante gpg
:EXPORT_DATE: 2019-01-17 21:20
:CATEGORY: seguridad
:TAG:      gpg, nube, servidor, raspberry
:IMAGE: ./images-blog/ugeek.png
:END:

En este post vamos a ver como cifrar simetricamente, con una contraseña, archivos mediante gpg.
 
** Cifrado

=gpg -c archivo.txt=
 
Te pedirá contraseña para cifrar el archivo.

Si eres como yo y te gusta incluirlo en un script para automatizar y no tener poner contraseña:
#+begin_src
gpg --yes --batch --passphrase="pon aquí tu contraseña" -c archivo.txt
#+end_src
** Descifrado

=gpg archivo.txt.gpg=


Para automatizar como en el caso anterior...
#+begin_src 
gpg --yes --batch --passphrase="pon aquí tu contraseña" archivo.txt.gpg
#+end_src
** Conclusión
Hablaré en más posts de como cifrar con diferentes métodos. Aunque el cifrado simétrico no es altamente seguro, si lo incluimos en un script, podriamos darle varias pasaditas de cifrado automatizando el proceso, dandole un poco mas de seguridad.



* TODO Servidor de Mensajería Matrix para Raspberry. Cliente Riot.
:PROPERTIES:
:TITLE:    Servidor de Mensajería Matrix para Raspberry. Cliente Riot
:EXPORT_FILE_NAME: Servidor de Mensajeria Matrix para Raspberry Cliente Riot
:DESCRIPTION: Hace algo mas de un mes, estoy utilizando Matrix Synapse, juntamente con el cliente Riot, a través de mi servidor-raspberry de forma totalmente privada y teniendo la totalidad de la gestión del servicio como los usuarios registrados. De momento, no he federado mi servidor, de manera que únicamente podremos comunicarnos los usuarios registrados en este servidor.
:EXPORT_DATE: 2019-01-20 19:26
:CATEGORY: mensajeria
:TAG:      servidor, raspberry
:IMAGE: ./images-blog/ugeek.png
:END:

Hace algo mas de un mes, estoy utilizando Matrix Synapse, juntamente con el cliente Riot, a través de mi servidor-raspberry de forma totalmente privada y teniendo la totalidad de la gestión del servicio como los usuarios registrados. De momento, no he federado mi servidor, de manera que únicamente podremos comunicarnos los usuarios registrados en este servidor.

Voy a explicaros paso a paso, como crear vuestro servidor en raspbian y si abrís los puertos del servicio, podréis comunicaros dentro y fuera de vuestra red local, con una de las aplicaciones de comunicación de Software Libre, mas seguras que existen en la actualidad, ya que posee de doble cifrado de datos.

Características:

  - Mensajería
  - Ilimitadas Salas donde poder compartir mensajes, imágenes, archivos,…
  - Llamadas
  - Video Llamadas
  - Doble Cifrados
  - Varios Clientes y totalmente multiplataforma

** INSTALACIÓN DEL SERVIDOR EN RASPBIAN
#+begin_src 
sudo apt-get install build-essential python2.7-dev libffi-dev \
                     python-pip python-setuptools sqlite3 \
                     libssl-dev python-virtualenv libjpeg-dev
sudo pip install --upgrade pip
sudo pip install --upgrade ndg-httpsclient
sudo pip install --upgrade virtualenv
#+end_src

Este segunda comando ten paciencia, se crearan los certificados, etc … y *tardará mucho tiempo, probablemente una hora*, recomiendo detener servicios

#+begin_src 
virtualenv -p python2.7 ~/.synapse
source ~/.synapse/bin/activate
pip install --upgrade pip
pip install --upgrade setuptools
pip install https://github.com/matrix-org/synapse/tarball/master
#+end_src

Instala también el modulo para synapse.app.

=pip install (--upgrade) synapseclient=

** CONFIGURAR SYNAPSE

    Recuerda sustituir el nombre del servidor *my.domain.name*
    En –report-stats= tienes que seleccionar *yes o no*.

=cd ~/.synapse=

#+begin_src 
python2.7 -B -m synapse.app.homeserver \
    --server-name=my.domain.name \
    --config-path=homeserver.yaml \
    --generate-config \
    --report-stats=[yes|no]
#+end_src


** INICIAR SERVIDOR

1) Nos situamos en la carpeta de *synapse*

=cd ~/.synapse=

2) Iniciar el servidor

=source ./bin/activate ; synctl start=

La Terminal nos devolverá que por el puerto 8008, encontraremos una inferfaz de gestión. Esta es antigua, *no te recomiendo que la uses*, te recomiendo crear ususarios mediante el comando que veremos mas adelante.
*Detener el servicio, si lo deseamos:*

=source ./bin/activate ; synctl stop=

CREAR USUARIOS

Iniciamos el servidor y situándonos dentro del directorio *.synapse*

=cd ~/.synapse=

Ejecutaremos el siguiente comando:

=register_new_matrix_user -c homeserver.yaml https://localhost:8448=

Ahora nos preguntará por el usuario, contraseña y si este usuario es administrador o no.
** UTILIZAR EL CLIENTE RIOT

[[./images-blog/riot.png]]


1) Pondermos en nombre de usuario y contraseña
2) Habilitamos opciones de servidor propietarias
3) En servidor, ponemos https://ip:8448
ENCONTRARSE LOS USUARIOS

1) Creamos una sala
2) En configuración de la sala, en *acceso a la Sala* y seleccionamos:
 
“Los que saben el enlace de la sala, incluso huespedes”

3 )Ahora en *Avanzado*, compartimos al otro usuario *La identificación interna de esta Sala*
  
* TODO Crear el Feed para el podcast en tu Blog con Jekyll
:PROPERTIES:
:TITLE:    Crear el Feed para el podcast en tu Blog con Jekyll
:EXPORT_FILE_NAME: Crear el Feed para el podcast en tu Blog con Jekyll
:DESCRIPTION: Voy a explicar en este post, como generar el Feed del podcast de forma automática.
:EXPORT_DATE: 2019-01-21 16:16
:CATEGORY: jekyll
:TAG:      servidor, jekyll,rss
:IMAGE: ./images-blog/ugeek.png
:END:

Voy a explicar en este post, como generar el Feed del podcast de forma automática.

** Creamos un archivo podcast.xml en la raiz, con el siguiente contenido:
#+begin_src 
---
layout: null
---
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
xmlns:content="http://purl.org/rss/1.0/modules/content/"
xmlns:wfw="http://wellformedweb.org/CommentAPI/"
xmlns:dc="http://purl.org/dc/elements/1.1/"
xmlns:atom="http://www.w3.org/2005/Atom"
xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd"
xmlns:rawvoice="http://www.rawvoice.com/rawvoiceRssModule/"
>
 
<channel>
<title>{{ site.podcast_title }}</title>
<atom:link href="{{ site.url }}/feed/podcast" rel="self" type="application/rss+xml" />
<link>{{ site.url }}</link>
<description>{{ site.podcast_description }}</description>
<lastBuildDate>{{ site.time | date: "%a, %d %b %Y %H:%M:%S %z" }}</lastBuildDate>
<language>es-es</language>
<sy:updatePeriod>hourly</sy:updatePeriod>
<sy:updateFrequency>1</sy:updateFrequency>
<generator>http://jekyllrb.com</generator>
<itunes:summary>{{ site.podcast_summary }}</itunes:summary>
<itunes:author>{{ site.podcast_author }}</itunes:author>
<itunes:explicit>{{ site.podcast_explicit }}</itunes:explicit>
<itunes:image href="{{ site.url }}{{ site.podcast_album_art }}" />
<itunes:owner>
<itunes:name>{{ site.podcast_owner }}</itunes:name>
<itunes:email>{{ site.podcast_email }}</itunes:email>
</itunes:owner>
<managingEditor>{{ site.podcast_email }} ({{ site.podcast_owner }})</managingEditor>
<itunes:subtitle>{{ site.podcast_subtitle }}</itunes:subtitle>
<image>
<title>{{ site.podcast_title }}</title>
<url>{{ site.url }}{{ site.podcast_album_art }}</url>
<link>{{ site.url }}</link>
</image>
<itunes:category text="{{ site.podcast_category }}">
<itunes:category text="{{ site.podcast_subcategory_one }}" />
<itunes:category text="{{ site.podcast_subcategory_two }}" />
</itunes:category>
{% for ep in site.categories.podcast %}
  <item>
    <title>{{ ep.title }}</title>
    <link>{{ site.url }}{{ ep.url }}</link>
    <comments>{{ site.url }}{{ ep.url }}#comments</comments>
    <pubDate>{{ ep.date | date: "%a, %d %b %Y %T %z" }}</pubDate>
    <dc:creator><![CDATA[{{ site.author | cdata_escape }}]]></dc:creator>
{% for category in ep.categories %}
    <category><![CDATA[{{ category | cdata_escape }}]]></category>
{% endfor %}
{% for category in ep.tags %}
    <category><![CDATA[{{ category | cdata_escape }}]]></category>
{% endfor %}
    <guid isPermaLink="{% if ep.podcast_guid %}false{% else %}true{% endif %}">{{ site.url }}{% if ep.podcast_guid %}/{{ ep.podcast_guid }}{% else %}{{ ep.url }}{% endif %}</guid>
    <description>
        <![CDATA[{{ ep.excerpt | strip_html | truncatewords: 50 | expand_urls: site.url | cdata_escape }}]]>
    </description>
    <content:encoded>
        <![CDATA[{{ ep.content | expand_urls: site.url | cdata_escape }}]]>
    </content:encoded>

    <enclosure url="{{ ep.podcast_link }}" length="{{ ep.podcast_length }}" type="audio/mpeg" />
    <itunes:subtitle><![CDATA[{{ ep.excerpt | strip_html | truncatewords: 50 | expand_urls: site.url | cdata_escape }}]]></itunes:subtitle>
    <itunes:summary><![CDATA[{{ ep.content | expand_urls: site.url | cdata_escape }}]]></itunes:summary>
    <itunes:author>{{ site.podcast_author }}</itunes:author>
    <itunes:image href="{{ site.url }}{{ site.podcast_album_art }}" />
    <itunes:explicit>{{ site.podcast_explicit }}</itunes:explicit>
    <itunes:duration>{{ ep.podcast_duration }}</itunes:duration>
  </item>
{% endfor %}
</channel>
</rss>
#+end_src

** Añadimos en el archivo _config.yml, el siguiente contenido:

#+begin_src 
# Podcast Feed Settings
podcast_url: https://ugeek.github.io
podcast_album_art: https://ugeek.github.io/img/ugeek.png
podcast_title: uGeek
podcast_owner: Angel
podcast_email: ugeekpodcast@gmail.com
podcast_category: Technology
podcast_subcategory_one: Linux
podcast_subcategory_two: Gadgets
podcast_explicit: "no"
podcast_author: Angel
podcast_description: Podcast de Tecnología en el que hablo de GNU/Linux, Raspberry Pi, servidores y tecnología en general.
podcast_summary: Podcast de Tecnología en el que hablo de GNU/Linux, Raspberry Pi, servidores y tecnología en general.
podcast_subtitle: Podcast de Tecnología en el que hablo de GNU/Linux, Raspberry Pi, servidores y tecnología en general.
#+end_src
** Por último, añadiremos en cada post, que es un podcast, el link del mp3, imagen, tags, etc…
#+begin_src 
---
layout: post
title: "046. Sincronización de carpetas entre dispositivos. Syncthing, Resilio y Dukto"
date: 2017-04-21
categories: podcast
image: img/ugeek.png
podcast_link: https://ia601509.us.archive.org/6/items/046SyncthingResilioYDukto/%23046%20Syncthing%2c%20Resilio%20y%20Dukto%20.mp3
tags: [syncthing, resilio, dukto, sincronización carpetas, podcast]
comments: true
---
#+end_src

* TODO Utilizando Git con la Terminal. GitHub 
:PROPERTIES:
:TITLE:    Utilizando Git con la Terminal. GitHub
:EXPORT_FILE_NAME: Utilizando Git con la Terminal GitHub
:DESCRIPTION: Como siempre os he comentado, utilizar la terminal al principio impresiona, pero hay que reconocer que no hay herramienta más productiva y potente que esta. Vamos a aprovechar que GitHub ha añadido repositorios privados, para utilizar más Git y vía terminal
:EXPORT_DATE: 2019-01-21 15:16 
:CATEGORY: git
:TAG:      terminal,github
:IMAGE: ./images-blog/ugeek.png
:END:

Como siempre os he comentado, utilizar la terminal al principio impresiona, pero hay que reconocer que no hay herramienta más productiva y
potente que esta. Vamos a aprovechar que GitHub ha añadido repositorios privados, para utilizar más Git y vía terminal.

** Instalando Git
=sudo apt install git=

** Comprobar si tenemos clave pública ssh
Vamos a comprobar si tenemos clave pública ssh generada. Para ello, entramos en *~/.ssh* y miraremos si existe el archivo **.pub*. 
** Generando tu clave pública ssh
Si no existe, vamos a generarlo.

Ejecutaremos el comando:

=ssh-keygen=

Saldrán una serie de preguntas. puedes ir pulsando intro para dejar los valores por defecto. eso no influye en nada.

Cuando termine, aparecerán un par de ficheros dentro de *~/.ssh/* se llamarán *id_rsa* y *id_rsa.pub* o adquirirán el nombre que has elegido si has puesto alguno en el paso anterior.

Ahora abre el fichero acabado en *.pub* con algún editor de textos y copia el contenido. Yo recomiendo utilizar la terminal:

=cat id_rsa.pub=

** Añadiendo la  clave en GitHub
Haz click en tu foto de perfil de arriba a la derecha, después ve a *settings > SSH and GPG keys > New SSH key*. Pega la clave  y pulsa finalizar.

A partir de ahora ya tienes permisos para subir cambios a tus repositorios en local.

Comprobaremos la conexión con GitHub

=ssh -T git@github.com=

** Iniciando cuenta con GitHub

Solo la primera vez, especificamos nuestro correo y nombre de usuario:

=git config --global user.email "tucorreo@gmail.com"=

=git config --global user.name "Tu Nombre"=

Para ver el archivo de configuración:

=cat ~/.gitconfig=

** Clonar Repositorio en local
Ves al repositorio de GitHub y haz click en *Clone or download* en la zona de la derecha, te saldrá *Clone with HTTPS o Clone with SSH GitHub*

Haz click sobre *Use SSH* y después pulsa sobre el botón de copiar que hay debajo.
 
Ahora vamos a la terminal y pegamos la url con *git clone* para clonar el repositorio:

=git clone git@github.com:ugeek/ugeek.github.io.git=

Se descargará todo el repositorio descomprimido en nuestra máquina. Ya podrás trabajar en local!


** Comandos Básicos
Resumen de pasos básicos para enviar archivos a una rama master de GitHub, serian estos:

- Ver estado desde el último cambio  =git status=
- Añadimos a git todos los cambios de archivos que hemos creado o cambiado en local =git add .=
- Igual que el anterior, pero solo una archivo =git add archivo= 
- Commit es una breve explicación del cambio o nuevo archivo que enviamos =git commit -m "nuevo post"=
- Empujamos el archivo, ahora si, a GitHub con =git push origin master=. Si se ponemos =git push --set-upstream origin master=, las siguientes veces funcionará poniendo sólo =git push=

    
Si tenemos instalado GitHub en dos dispositivos, antes de editar, deberíamos verificar o descargar el contenido remoto de GitHub a local.
- Para ello escribiremos en la terminal =git pull origin master=, después, igual que el caso anterior, podremos utilizar =git pull= a secas.

** Resumen
Esta guía sirve tanto para GitHub, GitLab y resto de servidores con Git. Como veis, parece muy complicado por ver muchos comandos, pero en el día a día, todo se resume en *subir* y *bajar*, los archivos de una carpeta al repositorio remoto.

Todo se resume en:

Subir

=git add . ; git commit -m "comentario" ; git push=

Bajar

=git pull=
* TODO Antergos. Comandos para terminal y derivadas de Arch Linux
:PROPERTIES:
:TITLE:    Antergos. Comandos para terminal y derivadas de Arch Linux
:EXPORT_FILE_NAME: Antergos Comandos para terminal y derivadas de Arch Linux
:DESCRIPTION: Los que venimos de Ubuntu, tenemos problemas al pasar a una dervada de Arch, porque no conocemos bien las instrucciones para actualizar el Sistema Operativo, instalar y demás
:EXPORT_DATE: 2019-01-21 18:30 
:CATEGORY: arch
:TAG:      antergos,comandos,terminal
:IMAGE: ./images-blog/ugeek.png
:END:

Los que venimos de Ubuntu, tenemos problemas al pasar a una dervada de Arch, porque no conocemos bien las instrucciones para actualizar el
Sistema Operativo, instalar y demás…

Aquí iré añadiendo periodicamente comandos para ir conociendolos.

** pacman
Pacman es el sistema de paquetes de Arch oficial, supervisado por ellos.
*** Actualizar el Sistema Operativo y repositorios
=sudo pacman -Syyuu=   
*** Buscar en los repositorios (usaremos de ejem: gimp)
=sudo pacman -Ss gimp=
*** Instalar aplicaciones
=sudo pacman -S gimp=
   
** yaourt
Las aplicaciones que no esten en los repositorios oficiales de Arch, estan en AUR. AUR (Arch User Repository) es el lugar donde la
comunidad de Arch Linux puede subir los PKGBUILD de las aplicaciones, bibliotecas, etc.,

Para instalar desde Aur utilizaremos yaourt.

*** Actualizar los repositorios
=yaourt -Syu=
   
*** Buscar en yaourt (usaremos de ejem: utext)
=yaourt -Ss utext=
   
*** Instalar aplicaciones que no encontremos en Pacman (como utext)
=yaourt -S utext=
   

** Guía de comandos básicos de Pacman
*** Instalar paquetes
- =pacman -S “paquete”=  Instala un paquete.
- =pacman -Sy “paquete”= Sincroniza repositorios e instala el paquete.
   
*** Actualizar paquetes
- =pacman -Sy=  Sincroniza repositorios.
- =pacman -Syy=  Fuerza la sincronización de repositorios incluso para paquetes que parecen actualizados.
- =pacman -Syu=  Sincroniza repositorios y actualiza paquetes.
- =pacman -Syyu=  Fuerza sincronización y actualiza paquetes.
- =pacman -Su=  Actualiza paquetes sin sincronizar repositorios.
   
*** Buscar paquetes
- =pacman -Ss “paquete”=  Busca un paquete.
- =pacman -Si “paquete”=  Muestra información detallada de un paquete.
- =pacman -Sg “grupo”=  Lista los paquetes que pertenecen a un grupo.
- =pacman -Qs “paquete”=  Busca un paquete YA instalado.
- =pacman -Qi “paquete”=  Muestra información detallada de un paquete YA instalado.
- =pacman -Qdt=  Muestra paquetes huerfanos.
   
*** Eliminar paquetes
- =pacman -R “paquete”=  Borra paquete sin sus dependencias.
- =pacman -Rs “paquete”=  Borra paquete y sus dependencias no utilizadas.


Fuente: sobrebits.com
  
** Aplicaciones Imprescindibles
Navegador Chrome

=yaourt -S google-chrome=

Editor de video

=sudo pacman -S openshot=

Notas de Nextcloud

=yaourt -S qownnotes=

Descarga videos de youtube

=sudo pacman -S clipgrab=

Hacer capturas de pantalla

=yaourt -S shutter=

Convertir audios de m4a a MP3

=sudo pacman -S soundconverter=

Editor de Fotografía

=sudo pacman -S gimp=

Instalar Inkscape

=sudo pacman -S inkscape=

Transmission

=sudo pacman -S transmission-gtk=

Skype

=sudo pacman -S skype=

* TODO Paquetes Snap
:PROPERTIES:
:TITLE:    Paquetes Snap
:EXPORT_FILE_NAME: paquetes Snap
:DESCRIPTION: Snap es muy fácil de utilizar desde la terminal. Aquí dejo los comando más utilizados, para consultarlos cada vez que quieras y no olvidarlos. También una breve explicación de donde están los snaps en tu disco y la tienda de aplicaciones. 
:EXPORT_DATE: 2019-01-24 21:30 
:CATEGORY: snap
:TAG:      paquetes
:IMAGE: ./images-blog/ugeek.png
:END:
Snap es muy fácil de utilizar desde la terminal. Aquí dejo los comando más utilizados, para consultarlos cada vez que quieras y no olvidarlos. También una breve explicación de donde están los snaps en tu disco y la tienda de aplicaciones. 

** Tienda de aplicaciones
El amplio catalogo de snaps, los encontraras en una web gestionada por Canonical.
- https://snapcraft.io/store
** Instalación de snap, si no está en tu distro derivada de debian
=sudo apt install snapd=

Para otras distribuciones, visita https://snapcraft.io/
** Ubiación de los paquetes snap en nuestro sistema
Una vez instalado los paquetes, estos van a la ubicación */snap/bin/nombre_de_paquete*. Podemos conocer la ubicación con:

=which paquete=

También creará una carpeta llamada snap en el $HOME de nuestro usuario */home/usuario/snap/*, donde depositará snap los archivos de configuración de los paquetes.
** Tabla de comandos básicos snap

| Comando                                 | Utilidad                          |
|-----------------------------------------+-----------------------------------|
| =sudo snap refresh=                       | Actualizar todos los paquetes     |
| =sudo snap refresh paquete=               | Actualizar un determinado paquete |
| =snap list=                               | Listar los paquetes instalados    |
| =snap search paquete= o =snap find paquete= | Buscar Paquetes                   |
| =sudo snap install paquete=               | Instalar paquete                  |
| =sudo snap remove paquete=                | Desinstalar paquete               |
| =snap info paquete=                       | Información del paquete           |
| =snap disable paquete=                    | Deshabilitar un servicio          |
| =snap enable paquete=                     | Habilitar                         |
| =snap version=                            | Conocer la versión de snap        |
| =snap help=                               | Ayuda                             |


- Desde mi raspberry, no he podido actualizar con *snap refresh* y he tenido que utilizar *snap refresh syncthing,* en el caso de la versión 1.0 de Syncthing.
- Con *snap info paquete* nos aparece toda la información de este paquete,así como las actualizaciones que ha ido teniendo este.
- Utilizar la instrucción *disable*, deshabilitará por completo el paquete, no solo lo detendrá, sino que lo dejará inaccesible para el sistema. Como si no estuviera instalado.
* TODO Castero. Podcatcher  ligero para Terminal
:PROPERTIES:
:TITLE:    Castero. Podcatcher  ligero para Terminal
:EXPORT_FILE_NAME: Castero Podcatcher ligero para Terminal
:DESCRIPTION: Hay muchas aplicaciones para escuchar podcast, pero ninguna tan ligera como esta. Desarrollada en python, [[https://github.com/xgi/castero][Castero]] nos permite suscribirnos a nuestro podcast favoritos y tanto descargarlos como escucharlos desde la terminal.
:EXPORT_DATE: 2019-01-26 14:00 
:CATEGORY: terminal
:TAG:      podcast,bash
:IMAGE: ./images-blog/castero.png
:END:
Hay muchas aplicaciones para escuchar podcast, pero ninguna tan ligera como esta. Desarrollada en python, [[https://github.com/xgi/castero][Castero]] nos permite suscribirnos a nuestro podcast favoritos y tanto descargarlos como escucharlos desde la terminal.
#+HTML: <center>
[[./images-blog/castero.png]]
#+HTML: </center>

** Instalación

Si no tenemos los módulos de python pip:
=sudo apt install python3-pip=

Instalación de castero:

=sudo pip3 install castero=

Para poder escuchar los podcast, requiere de aplicaciones externas como vlc versión 2.2.3 o superior o mpv con libmpv

** Iniciando Castero
Tan simple como escribir en tu terminal 

=caster=

Se abrirá una pantalla dividida en 3 partes:
- Feed: Los podcast que estamos suscritos a través de su Feed
- Episodies: Los episodios disponibles para ser escuchados
- Metadata: La información del episodio seleccionado

** Uso
La verdad es que es muy sencillo de utilizar. No iremos desplazando por las columnas de la pantalla con los cursores de izquierda, derecha, arriba, abajo.

Para salir, como la mayoría de las app's de ternimal *q*.

Para añadir el Feed deseado *a*...
#+BEGIN_SRC 
Comandos
    h - pantalla de ayuda
    q - salir del cliente
    a - añadir un feed
    d - eliminar el feed seleccionado
    r - recargar / actualizar feeds
    s - guardar el episodio para la reproducción sin conexión
    flechas - navegar por los menús
    página arriba / abajo - menús de desplazamiento
    entrar - reproducir el feed / episodio seleccionado
    espacio - agregar el feed / episodio seleccionado a la cola
    c - borrar la cola
    n - ir al siguiente episodio en la cola
    i - Invertir el orden del menú
    p o k - pausa / reproducir el episodio actual
    f o l - buscar hacia adelante
    b o j - buscar hacia atrás
#+END_SRC


** Archivos de configuración
El archivo de configuración se encuentra en {HOME}/.config/castero/ después de que el cliente se haya ejecutado al menos una vez.
La información de los Podcast está en {HOME}/.local/share/castero/feeds , pero este archivo no se puede editar de forma manual.



- [[https://github.com/xgi/castero][Repositorio de Castero]] 
* TODO Lee Super rápido en Emacs con Spray
:PROPERTIES:
:TITLE:    Lee Super rápido en Emacs con Spray
:EXPORT_FILE_NAME: Lee Super rapido en Emacs con Spray
:DESCRIPTION: No se si recordáis la aplicación Spritz, aquella aplicación que apareció a principios del año 2014 y que sus desarrolladores prometían que podríamos doblar o triplicar la velocidad de lectura. Si eres de aquellos que quieren leer más rápido o te cuesta concentrarte en la lectura de tus orgmode, voy a explicarte como instalarlo en el propio emacs de un modo sencillo.
:EXPORT_DATE: 2019-01-27 19:15 
:CATEGORY: emacs
:TAG:      melpa
:IMAGE: ./images-blog/ugeek.png
:END:
#+HTML: <center>

[[./images-blog/spray.gif]]
#+HTML: </center>

No se si recordáis la aplicación Spritz, aquella aplicación que apareció a principios del año 2014 y que sus desarrolladores prometían que podríamos doblar o triplicar la velocidad de lectura. Si eres de aquellos que quieren leer más rápido o te cuesta concentrarte en la lectura de tus orgmode, voy a explicarte como instalarlo en el propio emacs de un modo sencillo.
** Instalación
Instalaremos desde los repositorios de Melpa:

=M-x package-install RET spray=

**  Atajo de Teclado
La verdad es que si utilizamos un atajo instantáneo, tal como recomienda su desarrollador, aunque a priori pueda parecer una tontería, es un paquete que puede ser muy interesante tener instalado. El desarrollador recomienda utilizar la tecla *F6* para hacer uso de *spray*, aunque como sabes, puedes utilizar cualquier otro atajo si este ya lo tienes ocupado.

Para añadir este atajo, tenemos que añadir a nuestro archivo de configuración de emacs, ya sea el archivo *.emacs* o *init.el*, la siguiente línea:

=(global-set-key (kbd "<f6>") 'spray-mode)= 

** Modo de uso
La verdad es que es muy fácil de utilizar. Simplemente tenemos que situarnos el la parte del texto que deseamos leer y pulsar la tecla *F6*. Para salir de *spray*, pulsaremos nuevamente la tecla *F6*.

Algunos atajos mas:

| spray-start/stop (SPC)          | pausar o reanudar la fumigación              |
| spray-backward-word (h, <left>) | hacer una pausa y volver a la última palabra |
| spray-forward-word (l, <right>) | inversa de spray-backward-word               |
| spray-faster (F)                | aumenta la velocidad                         |
| spray-slower (s)                | disminuye la velocidad                       |
| spray-quit (q, <return>)        | dejar spray-mode                             |

Hay muchas mas opciones como cambiar la posición de spray en la pantalla, así como cambiar los colores. Si quieres entrar mas en profundidad, te recomiendo visitar el [[https://gitlab.com/iankelling/spray][repositorio del desarrollador.]]

- [[https://gitlab.com/iankelling/spray][Repositorio]]
* TODO Crear ramas con Git
:PROPERTIES:
:TITLE:    Crear ramas con Git
:EXPORT_FILE_NAME: Crear ramas con Git
:DESCRIPTION: Todos los repositorios de git, tienen la rama master (este sería el repositorio en producción) Cuando queremos hacer una modificación de un archivo en un repositorio que está en producción, crearemos una rama alternativa con la que podremos trabajar y así no alterar el funcionamiento del repositorio master
:EXPORT_DATE: 2019-01-28 21:15 
:CATEGORY: git
:TAG:      git
:IMAGE: ./images-blog/ugeek.png
:END:
Todos los repositorios de *git*, tienen la rama *master* (este sería el repositorio en producción) Cuando queremos hacer una modificación de un archivo en un repositorio que está en producción, crearemos una rama alternativa con la que podremos trabajar y así no alterar el funcionamiento del repositorio *master*. 
#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>

** Crear rama
Para crear una rama, utilizaremos el comando *git branch*. Vamos a crear una rama que llamaremos *test*

=git branch test=

** Cambiar de rama
Ahora tenemos una nueva rama, la rama *test*. Para acceder a ella, utilizaremos el comando *git checkout*

=git checkout test=

Si hemos introducido este comando, ya no estaremos en la rama *master* , sino que en la rama test, de manera que podremos hacer todos los cambios que deseemos sin miedo a romper nada.

Antes de volver nuevamente a la rama *master*, tenemos que hacer un *git push* y poner al día la rama *test*.

Para volver a la rama *master*:

=git checkout master=

Ya estamos de nuevo en la rama *master*

** Borrar una rama
Si ya hemos acabado con la rama *test* y queremos eliminarla en el repositorio local, utilizaremos el comando *git branch -d*

=git branch -d test=

Para forzar el borrado en caso de algún error:

=git branch -D test=


Para eliminar el repositorio remosto *git push origin :*

=git push origin :test=

 
* TODO Navegar por el Historial de comandos en Bash
:PROPERTIES:
:TITLE:    Navegar por el Historial de comandos en Bash
:EXPORT_FILE_NAME: Navegar por el Historial de comandos en Bash
:DESCRIPTION: Hace unas semanas, en el blog de Linuxito, vi este truquillo para navegar por el historial de comandos de nuestra terminal, utilizando las flechas de arriba y abajo. La verdad es que me he vuelto dependiente de este truco y quería compartirlo con vosotros. Igualmente, os recomiendo visitar el blog de Linuxito
:EXPORT_DATE: 2019-01-28 22:15 
:CATEGORY: bash
:TAG:      terminal
:IMAGE: ./images-blog/ugeek.png
:END:

Hace unas semanas, en el blog de [[https://www.linuxito.com/][Linuxito]], vi este truquillo para navegar por el historial de comandos de nuestra terminal, utilizando las flechas de arriba y abajo. La verdad es que me he vuelto dependiente de este truco y quería compartirlo con vosotros. Igualmente, os recomiendo visitar el blog de [[https://www.linuxito.com/][Linuxito]], que siempre crea artículos muy interesantes.

** Creamos archivo .inputrc
En la raíz del directorio $HOME, crearemos el archivo oculto *.inputrc*. Utilizaremos por ejemplo *nano*, para crear el archivo.

=nano .inputrc=

Una vez abierto, copiaremos en el siguiente contenido:
#+BEGIN_SRC 
## Flecha Arriba
"\e[A":history-search-backward
## Flecha Abajo
"\e[B":history-search-forward
#+END_SRC
Espero que disfrutéis de este truquillo igual que yo.

- [[https://www.linuxito.com/2-uncategorised/1160-configurar-bash-para-que-las-flechas-de-teclado-se-comporten-como-en-csh][Fuente]]

* TODO Que aparezca en el Prompt en que rama estamos   
:PROPERTIES:
:TITLE:    Que aparezca en el Prompt en que rama estamos
:EXPORT_FILE_NAME: Que aparezca en el Prompt en que rama estamos
:DESCRIPTION: Una vez te familiarizas con git, comienzas a crear ramas y llega un momento en el que vas un poco perdido, sin saber bien donde estás.Es cierto que con un git status, te dice en que tema estas trabajando, pero mucho mejor que te lo informe directamente el prompt. Para hacer esto, sigue estos simples pasos
:EXPORT_DATE: 2019-01-29 16:15 
:CATEGORY: bash
:TAG:      terminal
:IMAGE: ./images-blog/ugeek.png
:END:
Una vez te familiarizas con git, comienzas a crear ramas y llega un momento en el que vas un poco perdido, sin saber bien donde estás.  
Es cierto que con un *git status*, te dice en que tema estas trabajando, pero mucho mejor que te lo informe directamente el prompt. Para hacer esto, sigue estos simples pasos:

** Descargando .git-prompt.sh
Descargamos con wget .git-prompt.sh:

=wget https://raw.githubusercontent.com/git/git/master/contrib/completion/git-prompt.sh -O ~/.git-prompt.sh=

** Editamos ~/.bashrc
Vamos al archivo de configuración de bash *~/.bashrc* para editarlo con emacs:

=emacs ~/.bashrc=

Y añadimos el siguiente código:
#+BEGIN_SRC
source ~/.git-prompt.sh
PS1="\n[\[\033[32m\]\w]\[\033[0m\]\$(__git_ps1)\n\[\033[1;33m\]\u\[\033[32m\]$ \[\033[0m\]"
#+END_SRC

** Personalizando
Aquí te dejo esta tabla, por si quieres personalizar a tu gusto un poco mas el prompt:

*** Texto

#+BEGIN_SRC 
 Usuario, nombre de host y su color de visualización = \u@\h \[\033[32m\]               
 Directorio de trabajo actual y su color de visualización = \w\[\033[33m\]                  
 Nombre de rama de git y su color de visualización = \$(parse_git_branch)\[\033[00m\] 
#+END_SRC

*** Colores

#+BEGIN_SRC 
 Rojo = \[\033[0;31m\]  
 Amarillo = \[\033[0;33m\]  
 Verde = \[\033[0;32m\]" 
 Sin color = \[\033[0m\]"    
#+END_SRC


* TODO Comprimir archivos de forma automatizada en rar a 1.4Gb, para subirlos a Telegram u otra nube pública 
:PROPERTIES:
:TITLE:    Comprimir archivos de forma automatizada en rar a 1.4Gb, para subirlos a Telegram u otra nube pública
:EXPORT_FILE_NAME: Comprimir archivos de forma automatizada en rar para subirlos a telegram u otra nube publica
:DESCRIPTION: Telegram nos proporciona una nube ilimitada... pero con limitaciones. Telegram permite subir archivos que no superen los 1.5Gb y eso puede ser una limitación a subir vídeos domésticos en 4K o incluso alguna distro. Para solucionar este problema, podemos comprimir los archivos en rar y trocearlos
:EXPORT_DATE: 2019-01-29 22:15 
:CATEGORY: bash
:TAG:      telegram
:IMAGE: ./images-blog/ugeek.png
:END:
Telegram nos proporciona una nube ilimitada... pero con limitaciones. Telegram permite subir archivos que no superen los 1.5Gb y eso puede ser una limitación a subir vídeos domésticos en 4K o incluso alguna distro. Para solucionar este problema, podemos comprimir los archivos en rar y trocearlos. Después desde Telegram Desktop los podremos subir sin problemas. Tengo constancia de gente que ha subido archivos de hasta 2Gb, pero en este artículo, ya que no hay limitación en el número de archivos a subir, vamos a limitar a 1,4Gb el tamaño. Este artículo no solo vale para Telegram, Box.com también tiene limitación a 50mb, así que cambiando el número del comando, podrás dividir el archivo al tamaño que desees.

El Objetivo de este artículo, no solo es el aprender a trocear estos, sino también, como a mi me gusta, automatizar esta tarea. Así que en la primera parte, trocearemos archivos que están dentro de una carpeta y en la segunda, trocearemos archivos que están dentro de subcarpetas.

** Instalando rar

Para poder crear archivos rar, necesitamos instalar rar:

=sudo apt install rar=


unrar nos permitirá descomprimir los archivos, así que también lo instalaremos

=sudo apt install unrar=


** Comprimir archivos que estén dentro de una carpeta
Nos situaremos en la carpeta que contenga los archivos superiores a 1.4Gb y ejecutaremos este comando:
#+BEGIN_SRC
for directorio in *; do rar a -va1400m "${directorio%/}.rar" -r "$directorio" ; done
#+END_SRC
Como resultado, tendremos archivos con un tamaño máximo de 1.4Gb, con el nombre del archivo original y numerados.


** Comprimir archivos que estén dentro de subcarpetas
En este caso, vamos a comprimir archivos ubicados en subcarpetas y que su tamaño también superen los 1,4Gb. Nos situaremos en la carpeta raiz de estas subcarpetas y ejecutaremos el comando:
#+BEGIN_SRC
for directorio in */; do rar a -va1400m "${directorio%/}.rar" -r "$directorio" ; done
#+END_SRC
Del mismo modo que en el caso anterior, tendremos los archivos troceados, renombrados y numerados, en la carpeta que estamos situados.

** Reconstruir el archivo original 
Teniendo todos los archivos que previamente habíamos troceado, ahora vamos a transformarlo en el archivo original. Para ello, tenemos que tener instalado *unrar* como comenté al principio y tanto desde la interfaz gráfica, como la terminal, necesitamos que todos los archivos estén en la misma carpeta. Nos situaremos dentro de esta, descomprimiremos el número 1 y unrar se encargará de ir uniendo los trozos y devolvernos el archivo original.

=unrar x archivo.rar=

=unrar x archivo.rar /ruta_donde_enviar_el_archivo= 

Espero que os haya gustado este artículo y a darle caña a la terminal


* TODO Crear Alias 
:PROPERTIES:
:TITLE:    Crear Alias
:EXPORT_FILE_NAME: Crear Alias
:DESCRIPTION: Para facilitar la introducción de comandos largos y complejos, que son difíciles de recordar o simplemente porque utilizamos comandos repetitivos, utilizaremos los alias. Los alias son una palabra que introduciremos en la terminal y bash lo interpretará como una línea de comando
:EXPORT_DATE: 2019-01-31 21:15 
:CATEGORY: bash
:TAG:      terminal,zsh
:IMAGE: ./images-blog/ugeek.png
:END:
Para facilitar la introducción de comandos largos y complejos, que son difíciles de recordar o simplemente porque utilizamos comandos repetitivos, utilizaremos los *alias*. Los alias son una palabra que introduciremos en la terminal y bash lo interpretará como una línea de comando.
** Crear Alias
Para crear el alias, editaremos el archivo *.bashrc*
*/home/usuario/.bashrc*
#+BEGIN_SRC 
sudo nano /home/usuario/.bashrc
#+END_SRC

Al final del contenido de este archivo, iremos introduciendo los alias así:
#+BEGIN_SRC 
alias palabra='comando'
#+END_SRC
** Ejemplo de Alias
Si añadimos esta línea en Ubuntu, cada vez que escribamos en la terminal *actualizar*, se ejecutará los comandos para actualizar y además al final aparecerá un mensaje de: "Sistema Operativo Actualizado"
#+BEGIN_SRC
alias actualizar='sudo apt update && sudo apt upgrade && clear && echo "Sistema Operativo Actualizado"'
#+END_SRC

Con una simple palabra, hemos actualizado nuestro Ubuntu. Practica y diviértete creando *alias*
* TODO OrgMode: Buscar solo en las Cabeceras
:PROPERTIES:
:TITLE:    OrgMode: Buscar solo en las Cabeceras
:EXPORT_FILE_NAME: orgmode Buscar solo en las Cabeceras
:DESCRIPTION: Tomar muchas notas, es muy sencillo, lo complicado es después encontrarlas. Cuando decides el crear un único archivo orgmode para tomar tus notas y este crece de forma desmesurada, empiezas a tener problemas cuando quieres localizar notas que sabes que has tomado, pero mediante una búsqueda sencilla por palabras, aparecen cientos de resultados
:EXPORT_DATE: 2019-02-01 21:45 
:CATEGORY: emacs
:TAG:      orgmode
:IMAGE: ./images-blog/ugeek.png
:END:

Tomar muchas notas, es muy sencillo, lo complicado es después encontrarlas. Cuando decides el crear un único archivo orgmode para tomar tus notas y este crece de forma desmesurada, empiezas a tener problemas cuando quieres localizar notas que sabes que has tomado, pero mediante una búsqueda sencilla por palabras, aparecen cientos de resultados.

Lo ideal sería poder buscar palabras solo en la cabeceras y no a lo largo del orgmode. En este [[https://mentat.za.net/blog/2016/12/15/org-mode-header-search/][Post de https://mentat.za.net]], explica como hacer búsqueda solo en las cabecera de primer nivel. Yo, tal como tengo estructuradas mis notas, necesitaba que buscara en todas las cabeceras. Así que he hecho una pequeña modificación al código y aquí os explico el resultado.

** Búsqueda en  cabeceras de mi orgmode

Pensé en replicar tantas veces como fuera necesario, la línea '(setq unread-command-events (listify-key-sequence "^* "))', e ir añadiendo Cabeceras, pero solo me ha bastado una, como aparece en esta cajetilla de código, para que entienda emacs que debe buscar en todas las Cabeceras. No me parece que sea una forma correcta, pero... Funciona!!!!

Añade en *init.es* o *.emacs*, las siguientes líneas:
#+begin_src 
(defun stefan/isearch-heading ()
  (interactive)
  (setq unread-command-events (listify-key-sequence "^* "))
  (setq unread-command-events (listify-key-sequence "^** "))
  (isearch-mode t t nil t))


(defun org-mode-keys ()
  (interactive)
  (local-set-key (kbd "C-c h") 'stefan/isearch-heading)
)
(add-hook 'org-mode-hook 'org-mode-keys)
#+end_src
** Hacer Búsquedas
Para buscar una palabra que estará en cualquiera de las cabeceras, pulsaremos las teclas *C-c h*. Recuerda que podrás personalizar el atajo que desees cambiando este en el código. 

Una vez hecha la primera búsqueda, si tienes mas cabeceras con la misma palabra que deseas buscar, debes de pulsar *C-s* todo el rato, ara ir avanzando a lo largo de las coincidencias

Tengo que decir que el único punto negativo, es que encuentra la palabra, siempre que sea la primera que aparece en el título de la cabecera. Si está a lo largo del título, no la encuentra. De ahí, que en el código aparece "^*". Es una cosa que tenemos que tener en cuenta cuando creemos nuestras notas. 
** Buscar en Cabeceras de Primer Nivel
Código para solo Buscar en cabeceras de primer nivel:
#+begin_src
(defun stefan/isearch-heading ()
  (interactive)
  (setq unread-command-events (listify-key-sequence "^* "))
  (isearch-mode t t nil t))


(defun org-mode-keys ()
  (interactive)
  (local-set-key (kbd "C-c h") 'stefan/isearch-heading)
)
(add-hook 'org-mode-hook 'org-mode-keys)
#+end_src
* TODO Cambiar, mover ruta y contraseña de usuario en tu Raspberry Pi
:PROPERTIES:
:TITLE:    Cambiar, mover ruta y contraseña de usuario en tu Raspberry Pi
:EXPORT_FILE_NAME: Cambiar  mover ruta y contrasena de usuario en tu Raspberry Pi
:DESCRIPTION: En este artículo, vamos a ver como cambiar el usuario y contraseña así como la ruta del usuario, en nuestra raspberry
:EXPORT_DATE: 2019-02-01 23:45 
:CATEGORY: raspberry
:TAG:      raspberry
:IMAGE: ./images-blog/ugeek.png
:END:


Vamos a cambiar el usuario "Pi", por defecto, por el usuario que deseemos, cambiando la carpeta /home/pi por /home/Nuevo_usuario

** Habilitando el usuario root 
Vamos a habilitar el usuario root, que por defecto esta deshabilitado

=sudo passwd root=

Ahora deberemos habilitar el acceso a root desde ssh:
Buscaremos la sección *#Authentication:* y en PermitRootLogin, cambiaremos el valor que haya a continuación por yes.
#+BEGIN_SRC 
#PermitRootLogin prohibit-password
PermitRootLogin yes
#+END_SRC
Quitar el "#" para que surja efecto.

=sudo nano /etc/ssh/sshd_config=

Reiniciamos el servidor ssh *en caso de problemas también la raspberry*

=sudo service ssh restart=

*En caso de tener algún servicio instalado, detener todos los servicios*

** Entrando como root
*Entramos por ssh como root* (salimos de la sesión actual y entramos como root) y vamos a cambiar el nombre de usuario por el que deseemos

=sudo usermod -l nuevo_usuario pi -md /home/nuevo_usuario=

El usuario Pi, seguirá en la máquina. Cambiaremos este por nuestro nuevo usuario:

=sudo groupmod -n nuevo_ de_grupo  pi=

Salimos del ssh y nos logueamos con el nuevo nombre de usuario

Deshabilitamos root, quitando la contraseña de root

=sudo passwd –l root=

** Cambiar contraseña

=passwd=
Nos pedirá la nueva contraseña y que la repitamos.
* TODO Instalar Docker en Raspberry Pi con Raspbian
:PROPERTIES:
:TITLE:    Instalar Docker en Raspberry Pi con Raspbian
:EXPORT_FILE_NAME: Instalar Docker en Raspberry Pi con Raspbian
:DESCRIPTION: En los repositorios de Raspbian, esta disponible el paquete Docker. Aún así, el método de instalación que no te dará errores y funcionará sin ningún problema, es este
:EXPORT_DATE: 2019-02-03 19:45 
:CATEGORY: docker
:TAG:      raspberry,raspbian
:IMAGE: ./images-blog/ugeek.png
:END:

En los repositorios de Raspbian, esta disponible el paquete Docker. Aún así, el método de instalación que no te dará errores y funcionará sin ningún problema, es este.
** Instala primero algunos paquetes que necesitamos
=sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common=

** Obtener la clave de firma Docker para paquetes

=sudo curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo apt-key add -=

** Añadimos los repositorios oficiales
#+BEGIN_SRC 
sudo echo "deb [arch=armhf] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") \
     $(lsb_release -cs) stable" | \
    sudo tee /etc/apt/sources.list.d/docker.list
#+END_SRC
** Instalamos Docker
#+BEGIN_SRC 
sudo apt update
sudo apt install docker-ce
#+END_SRC
** Iniciamos Docker y lo habilitamos para que se inicie al reiniciar
#+BEGIN_SRC 
sudo systemctl enable docker
sudo systemctl start docker
#+END_SRC

** Crear el grupo Docker, para no tener que poner sudo
#+BEGIN_SRC 
sudo groupadd docker
sudo usermod -aG docker $USER
#+END_SRC
Salir de la terminal y volver a entrar
** Instalar Portainer
 
=docker run -d --name=Portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer=
* TODO Instalando una Dokuwiki en 4 pasos
:PROPERTIES:
:TITLE:    Instalando una Dokuwiki en 4 pasos
:EXPORT_FILE_NAME: Instalando una Dokuwiki en 4 pasos
:DESCRIPTION: Dokuwiki puede servirnos tanto para tomar nuestras notas, como previsualizar y editar contenido generado por nuestros scripts. En este post os explico como instalar Dokuwiki en tan solo 4 pasos. En este post, doy por hecho que tienes instalado apache2.
:EXPORT_DATE: 2019-02-06 15:15 
:CATEGORY: servidor
:TAG:      raspberry,notas
:IMAGE: ./images-blog/dokuwiki.png
:END:
#+HTML: <center>
[[./images-blog/dokuwiki.png]]
#+HTML: </center>


Dokuwiki puede servirnos tanto para tomar nuestras notas, como previsualizar y editar contenido generado por nuestros scripts.
En este post os explico como instalar Dokuwiki en tan solo 4 pasos. Doy por hecho que tienes instalado apache2.

=sudo apt install apache2=

Lo bueno que tiene dokuwiki, es que no tenemos que instalar base de datos y todas nuestras entradas están en formato texto plano.
** Descargando Dokuwiki 
Hay Versiones estables y no estables. Descargamos con wget, por ejemplo, la versión estable copiando el link de la ruta desde la web de [[https://www.dokuwiki.org/dokuwiki][DokuWiki]].

Nos situamos en  =/var/www/html/=, raiz de nuestro servidor web y descargamos ahí el archivo comprimido con *wget*:

Si no tenemos permisos, podremos descargarlo utilizando *sudo*. Posteriormente, para descomprimir la carpeta, también tendremos que usarlo. =sudo wget ...=, =sudo tar ...=, =sudo mv ...=

=wget https://download.dokuwiki.org/src/dokuwiki/dokuwiki-stable.tgz=

** Descomprimamos
Descomprimimos el archivo descargado. Si no es este el nombre, utiliza el nombre del archivo.

=tar -xzvf dokuwiki-stable.tgz=

Renombra la carpeta con el nombre que desees, yo en mi caso, le podré *dokuwiki*:

=mv dokuwiki-stable/ dokuwiki/=

Ahora vamos a dar permisos de visualización y edición desde el navegador

=sudo chown -R www-data:www-data /var/www/html/dokuwiki=

** Dando el último paso
Accedemos desde el navegador web, a la ip de nuestro servidor y la siguiente ruta:
http://ip/dokuwiki/install.php

Rellenamos los datos de administrador y pulsamos al final para que se inicie la instalación.

Elimina el archivo *install.php*

** Habilitar código embebido html y php
Para poder ver código embebido en html en nuestra dokuwiki, como vídeos de Youtube,etc...  accederemos a traves de la cuenta de administrador a:

Administrar -> Parámetros de Configuración

  
* TODO Papelera Reciclaje desde la Terminal
:PROPERTIES:
:TITLE:    Papelera Reciclaje desde la Terminal
:EXPORT_FILE_NAME: Papelera Reciclaje desde la Terminal
:DESCRIPTION: Cuando utilizamos cualquier tipo de escritorio con interfaz gráfica y borramos un archivo, como sabéis, este archivo en realidad no ha sido borrado, sino que ha sido movido a la papelera. Esto no sucede así cuando utilizamos nuestra terminal. Cuando borras el archivo desde la terminal, lo borras para siempre. Hoy os traigo una herramienta que en lugar de hacer *rm* y eliminarlo para siempre, nos va a llevar este archivo a la papelera. Así mismo, mediante una serie de comandos, nos va a permitir el gestionar todo el contenido de nuestra papelera desde la terminal.
:EXPORT_DATE: 2019-02-07 17:15 
:CATEGORY: bash
:TAG:      terminal,zsh
:IMAGE: ./images-blog/papelera.jpg
:END:
#+HTML: <center>
[[./images-blog/papelera.jpg]]
#+HTML: </center>



Cuando utilizamos cualquier tipo de escritorio con interfaz gráfica y borramos un archivo, como sabéis, este archivo en realidad no ha sido borrado, sino que ha sido movido a la papelera. Esto no sucede así cuando utilizamos nuestra terminal. Cuando borras el archivo desde la terminal, lo borras para siempre. Hoy os traigo una herramienta que en lugar de hacer *rm* y eliminarlo para siempre, nos va a llevar este archivo a la papelera. Así mismo, mediante una serie de comandos, nos va a permitir el gestionar todo el contenido de nuestra papelera desde la terminal.
** ¿Donde están los archivos de mi Papelera?
Todos los archivos que eliminamos por interfaz gráfica, van a la papelera. La ruta de esta, es:

=~/.local/share/Trash/files=
** Instalando trash-cli
La instalación de trash-cli, es muy simple, ya que está en los repositorios oficiales:

=sudo apt install trash-cli=

** Tabla de comandos
| trash-put     | Enviar archivos a la Papelera                |
| trash-empty   | Vaciar la papelera                           |
| trash-list    | Listar archivos que hay en la papelera       |
| trash-restore | Restaura un archivo de la papelera           |
| trash-rm      | Elimina archivos individuales de la papelera
** Buscar un Archivo en la Papelera
Si combinamos trash-cli con grep, podremos buscar archivos y carpetas que hay en nuestra papelera, mediante el nombre

=trash-list | grep foo=


También podriamos jugar con nuestro comandos favoritos, como conocer cuantos archivos y carpetas tenemos:

=trash-list | wc -l=

** Eliminar solo los archivos que coincidan con un patrón:
Aquí, por ejemplo, eliminaremos todos los archivos con extensión .txt

=trash-rm \ *.txt=

** Eliminar en función de los dias
Eliminar los archivos enviados a la papelera los últimos 10 dias.

=trash-empty 10=

** ¿Puedo alias rm a trash-put?
Si no me acuerdo de lo que hice ayer, menos me voy a acordar de esta magnífica aplicación. Así que para no borrar de una forma drástica mis archivos o carpetas y hacer uso de esta aplicación, he sustituido mediante el archivo de configuración *.bashrc*, que cuando ejecute el comando *rm*, en realidad ejecute el comando *trash-put* para que lo envie a la papelera.

Para hacer esto, vamos ha hacer uso de los alias:

Con tu editor de texto favorito en terminal, en este caso utilizaremos nano, añadiremos al final esta línea:

=nano ~/.bashrc=

#+BEGIN_SRC 
alias rm='trash-put'
#+END_SRC

Ahora cada vez que hagamos un *rm*, enviará los archivos o carpetas a la papelera.


Otra opción, sería el borrar los archivos mediante cron, programando periódicamente el borrado cada x días
** Conclusión
Como veis, gracias a esta aplicación y a nuestro ingenio con la terminal, podemos automatizar y tener mas controlados nuestros archivos. 

Disfrutar de la terminal 😜


- [[https://github.com/andreafrancia/trash-cli][Repositorio]]
 
* TODO No todo es echo. También existe printf 
:PROPERTIES:
:TITLE:    No todo es echo. También existe printf
:EXPORT_FILE_NAME: No todo es echo Tambien existe printf
:DESCRIPTION: Cuando hacemos scritps en bash, habitualmente utilizamos echo para imprimir o mostrar el resultado a través de la terminal. Si es un resultado simple, en principio no hay ningún problema. Los problemas vienen cuando utilizamos comillas dobles, simples, comillas dentro de una variable, etc... para poder previsualizar sin errores, necesitamos dar escape a las comillas. Esto no es del todo simple y puede frustrar. Para solucionar este problema, podemos utilizar printf.
:EXPORT_DATE: 2019-02-08 22:15 
:CATEGORY: bash
:TAG:      terminal
:IMAGE: ./images-blog/ugeek.png
:END:

Cuando hacemos scritps en bash, habitualmente utilizamos *echo* para imprimir o mostrar el resultado a través de la terminal. Si es un resultado simple, en principio no hay ningún problema. Los problemas vienen cuando utilizamos comillas dobles, simples, comillas dentro de una variable, etc... para poder previsualizar sin errores, necesitamos dar escape a las comillas. Esto no es del todo simple y puede frustrar. Para solucionar este problema, podemos utilizar printf.

** Iniciandonos con printf

printf es mucho mas simple que echo, vamos a comenzar con algunos simples ejemplos:


#+BEGIN_SRC 
$ printf "Hola Mundo"
Hola Mundo
#+END_SRC
** Salto de línea

Del mismo modo que *echo*, podemos hacer salto de líneas. Vamos a ver varios ejemplos:


#+BEGIN_SRC 
$ printf "%s\n" "Hola Mundo"
Hola Mundo
#+END_SRC


#+BEGIN_SRC 
$ printf "Hola \nMundo"
Hola
Mundo
#+END_SRC



#+BEGIN_SRC 
$ printf "%s\n" "Hola" "Mundo"
Hola
Mundo
#+END_SRC



#+BEGIN_SRC 
$ printf "%*s\n" $(tput cols) "Hola Mundo!"
Hola
Mundo
!
#+END_SRC

** Imprimir al final de la línea 

Ahora vamos a desplazar la línea al final del margen derecho:


#+BEGIN_SRC 
$ printf "%*s\n" $(tput cols) "Hola Mundo!"

                                 Hola Mundo!
#+END_SRC


** Llamada de Fechas, host, rutas  

Podemos llamar diferentes formatos de fecha, host, rutas,...


#+BEGIN_SRC 
$ printf 'Esta es la semana %(%U/%Y)T.\n' -1
Esta es la semana 05/2019.
#+END_SRC

Mostrando la fecha y host:


#+BEGIN_SRC 
$ printf "%s:%s\n" "$(date)" "$(hostname)"
vie feb  8 22:16:26 CET 2019:angel
#+END_SRC


Ruta de mi carpeta home:


#+BEGIN_SRC 
$ printf "La ruta de mi home es %s.\n" $HOME
La ruta de mi home es /home/angel.
#+END_SRC

Añadiendo el nombre con el que nos hemos logeado en la sesión:


#+BEGIN_SRC 
$ printf "Hola, Soy %s.\n" $LOGNAME
Hola, Soy angel.
#+END_SRC


Fecha y hora:


#+BEGIN_SRC 
$ printf "%(%m-%d-%Y %H:%M:%S)T\n" $(date +%s)
02-08-2019 21:10:35
#+END_SRC


Tabla con el código del formato de fecha:


| Código de Formato | Descripción                                                                       |
|-------------------+-----------------------------------------------------------------------------------|
| %%                | un% literal                                                                       |
| %a                | el nombre abreviado del día de la semana de locale (por ejemplo, Lun)             |
| %A                | el nombre completo del día laborable de la localidad (por ejemplo, domingo)       |
| %b                | el nombre abreviado del mes de la localidad (por ejemplo, enero)                  |
| %B                | el nombre completo del mes del local (por ejemplo, enero)                         |
| %c                | Fecha y hora del local (por ejemplo, jue 3 de marzo 23:05:25 2005)                |
| %C                | siglo; como% Y, excepto omitir los últimos dos dígitos (por ejemplo, 20)          |
| %d                | día del mes (por ejemplo, 01)                                                     |
| %D                | fecha; igual que% m /% d /% y                                                     |
| %e                | día del mes, espacio acolchado; igual que% _d                                     |
| %F                | fecha completa igual que% Y-% m-% d                                               |
| %g                | los dos últimos dígitos del año del número de semana ISO (ver% G)                 |
| %G                | año del número de semana ISO (ver% V); Normalmente útil solo con% V               |
| %h                | igual que% b                                                                      |
| %H                | hora (00..23)                                                                     |
| %I                | hora (01..12)                                                                     |
| %j                | día del año (001..366)                                                            |
| %k                | hora, espacio rellenado (0..23); igual que% _H                                    |
| %l                | hora, espacio acolchado (1..12); igual que% _I                                    |
| %m                | mes (01..12)                                                                      |
| %M                | minuto (00..59)                                                                   |
| %n                | una nueva linea                                                                   |
| %N                | nanosegundos (000000000..999999999)                                               |
| %p                | el equivalente local de AM o PM; en blanco si no se conoce                        |
| %P                | como% p, pero minúscula                                                           |
| %q                | trimestre del año (1..4)                                                          |
| %r                | el reloj de 12 horas del local (por ejemplo, 11:11:04 PM)                         |
| %R                | Hora y minuto de 24 horas; igual que% H:% M                                       |
| %s                | segundos desde 1970-01-01 00:00:00 UTC                                            |
| %S                | segundo (00..60)                                                                  |
| %t                | una pestaña                                                                       |
| %T                | hora; igual que% H:% M:% S                                                        |
| %u                | día de la semana (1..7); 1 es lunes                                               |
| %U                | Número de la semana del año, con el domingo como primer día de la semana (00..53) |
| %V                | Número de semana ISO, con el lunes como primer día de la semana (01..53)          |
| %w                | día de la semana (0..6); 0 es domingo                                             |
| %W                | Número de la semana del año, con el lunes como primer día de la semana (00..53)   |
| %x                | Representación de la fecha de la localidad (por ejemplo, 31/12/99)                |
| %X                | Representación del tiempo del local (por ejemplo, 23:13:48)                       |
| %y                | los dos últimos dígitos del año (00..99)                                          |
| %Y                | año                                                                               |
| %z                | + hhmm zona horaria numérica (por ejemplo, -0400)                                 |
| %:z               | + hh: mm zona horaria numérica (por ejemplo, -04: 00)                             |
| %::z              | + hh: mm: ss zona horaria numérica (por ejemplo, -04: 00: 00)                     |
| %:::z             | zona horaria numérica con: a la precisión necesaria (por ejemplo, -04, +05: 30)   |
| %Z                | abreviatura alfabética de la zona horaria (por ejemplo, EDT)                      |






** Editar texto 

Cortar Texto:


#+BEGIN_SRC 
$ printf "%.*s" 12 "Muestra solo las cinco primeras letras"
Muestra solo
#+END_SRC




#+BEGIN_SRC 
$ printf "Me llamo \"%s\".\nEs un placer conocerte." "Angel"
Me llamo "Angel".
Es un placer conocerte.
#+END_SRC


Indentado:

#+BEGIN_SRC 
$ printf "%*s\n" 25 "Hola Mundo"

               Hola Mundo
#+END_SRC

** Números


#+BEGIN_SRC 
$ printf "2 + 2 son %d\n" $((2+2))
2 + 2 son 4
#+END_SRC



#+BEGIN_SRC 
$ printf "Aquí en solo %d pondremos estos %d valores.\n\ndoble salto de línea" 1 2

Aquí en solo 1 pondremos estos 2 valores.

doble salto de línea
#+END_SRC


Creando 2 columnas:


#+BEGIN_SRC 
$ printf "%-10d %-10d\n" 1 500 2 550

1          500       
2          550
#+END_SRC


** Conclusión
Como podéis ver, printf tiene muchísimas posibilidades y aquí solo he descrito unas pocas. Si os soy sincero, soy un clásico y tiro por comandos como *date* y *echo*. Pero lo que si que es cierto, que si llegas a un momento de desesperación con las comillas en un script, printf es una gran solución.

** Fuentes
- https://www.computerhope.com/unix/uprintf.htm
- https://wiki.bash-hackers.org/commands/builtin/printf
- https://www.cyberciti.biz/faq/unix-linux-getting-current-date-in-bash-ksh-shell-script/
* TODO 2 Archivos de configuración, un Emacs
:PROPERTIES:
:TITLE:    2 Archivos de configuración, un Emacs
:EXPORT_FILE_NAME: 2 Archivos de configuracion un Emacs
:DESCRIPTION: Como sabéis, podemos utilizar Emacs tanto con interfaz gráfica como vía terminal. La verdad es que utilizo las dos versiones, pero cuando utilizo la versión vía terminal, quiero que sea ligera y muy rápida, pero sin perder cierta personalización como el acceso a los archivos .org, resaltar la sintaxis, corrector ortográfico... Para la interfaz gráfica, dejo la totalidad de paquetes instalados y eso hace que el arranque sea un poquito mas lento, pero con la totalidad de servicios disponibles como elfeed, temas, etc... En este post voy a explicaros como utilizo mis dos archivos de configuración init.el de Emacs, para las dos versiones
:EXPORT_DATE: 2019-02-08 23:15 
:CATEGORY: emacs
:TAG:      orgmode
:IMAGE: ./images-blog/ugeek.png
:END:

 Como sabéis, podemos utilizar Emacs tanto con interfaz gráfica como vía terminal. La verdad es que utilizo las dos versiones, pero cuando utilizo la versión vía terminal, quiero que sea ligera y muy rápida, pero sin perder cierta personalización como el acceso a los archivos .org, resaltar la sintaxis, corrector ortográfico... Para la interfaz gráfica, dejo la totalidad de paquetes instalados y eso hace que el arranque sea un poquito mas lento, pero con la totalidad de servicios disponibles como elfeed, temas, etc... En este post voy a explicaros como utilizo mis dos archivos de configuración *init.el* de Emacs, para las dos versiones.

** Archivo de configuración con Interfaz gráfica
Para la interfaz gráfica, dejo el archivo en la ruta por defecto. =~/.emacs.d/init.el= 
** Archivo de configuración versión terminal
En breve, publicaré un pequeño script en bash con el que gestiono mis *dotfile*. En esta carpeta donde los guardo, que la tengo sincronizada mediante syncthing con todos mis dispositivos, tengo mi archivo de configuración para la versión de terminal.

Lo que hago es crear un nuevo alias en *.bashrc*, llamado "e", para que cuando introduzca esta letra en la terminal, ejecute Emacs versión terminal con el archivo de configuración en mi carpeta de dotfiles:

#+BEGIN_SRC 
printf "alias e='emacs -nw -q --load ~/dotfile/emacs/init_terminal.el'" >> ~/.bashrc
#+END_SRC 

Mediante esta simple línea de terminal, añadirá el nuevo alias a *.bashrc*.

Crea un nuevo archivo de configuración y personaliza este. Personaliza también a tu gusto tanto el nombre del alias como la ruta del archivo de configuración.

Ya tienes Emacs con dos personalizaciones similares, pero diferentes 😜

A Disfrutar a tope con Emacs!!!
* TODO Servidor Jabber/XMPP en tu Raspberry mediante Docker y Dockerfile
:PROPERTIES:
:TITLE:    Servidor ejabberd/xmpp en tu Raspberry mediante Docker y Dockerfile
:EXPORT_FILE_NAME: Servidor ejabberd xmpp en tu Raspberry mediante Docker y Dockerfile
:DESCRIPTION: En el Podcast, os he hablado muchas veces de las virtudes de docker: sencillez, seguridad, etc... En el artículo de hoy, voy a instalar un servidor ejabberd para raspberry, que no he encontrado en el Docker Hub y porque no decirlo, para los mas paranoicos, porque no instalarlo paso a paso
:EXPORT_DATE: 2019-02-10 22:25 
:CATEGORY: docker
:TAG:      debian,alpinelinux,mensajeria,docker
:IMAGE: ./images-blog/ejabberd.png
:END:
#+HTML: <center>
[[./images-blog/ejabberd.png]]
#+HTML: </center>


En el Podcast, os he hablado muchas veces de las virtudes de docker: sencillez, seguridad, etc... En el artículo de hoy, voy a instalar un servidor ejabberd para raspberry, que no he encontrado en el Docker Hub y porque no decirlo, para los mas paranoicos, porque no instalarlo paso a paso...

El Dockerfile es una archivo en texto plano que nos permite, del mismo modo que hacemos en un script, escribir línea a línea todos los comandos que queremos que se ejecuten en el momento de crear el Docker. Partimos en la primera línea descargando de un sistema operativo y después sucesivamente se ejecutaran todos esos comandos, cerrando por último nuestra imagen.

Vamos a crear un servidor ejabberd de mensajería, partiendo de una distro debian para arm32v7.


En próximos posts explicaré como hacer Dockers partiendo de una distro que tan solo ocupa 5 Mb, Alpine Linux. Pero para ejabberd, no hay una versión estable del servicio para arm. Así que... Vamos a utilizar una debian que es lo que conozco bien.

** Dockerfile

Crea con tu editor texto favorito, un archivo sin extensión llamado *Dockerfile* y dentro copiar este contenido.

#+begin_src 
FROM arm32v7/debian:latest
MAINTAINER angel <ugeekpodcast@gmail.com>

RUN apt-get -y update; \
    apt-get -y upgrade; \
    apt-get -y install apt-utils \
    ejabberd; 


EXPOSE 5280
EXPOSE 5222
EXPOSE 5269

VOLUME /etc/ejabberd/


ENTRYPOINT service ejabberd start && /bin/bash
CMD ["bash"]
#+end_src

- La primera línea, *FROM*, nos descargará de Docker Hub la distro debian para arm32v7.
- *MAINTAINER*, son los datos de quien va a mantener el contenedor. En este caso no es necesario, ya que mi intención no es subirlo al Docker Hub, pero vamos a ponerlo.
- *RUN*, Comando que se ejecutaran del mismo modo que un script en bash. Actualizamos repositorios e instalamos todo aquello que necesitamos para crear nuestro servidor.
- *EXPOSE*, son los puertos que quedarán abiertos en el contenedor.
- *VOLUME*, es la carpeta del contenedor que deseamos que quede accesible desde fuera del contenedor. Esto es ideal en este caso para dejar el archivo de configuración fuera del contenedor y así si después actualizamos el Docker o se rompe, restaurando a partir de la imagen. Dejando el archivo de configuración, todo funcionará como si no hubiera pasado nada.
- *ENTRYPOINT*, Comando que ejecutaremos una vez montado el contenedor.


** Creando la Imagen

Nos situaremos en la carpeta donde está el archivo *Dockerfile* y ejecutaremos el siguiente comando:

=docker build -t ejabberd_imagen:dockerfile .=

** Veamos si se ha creado la imagen
Con este comando veremos todas las imágenes que tenemos en el servidor. La última, corresponderá la imagen que hemos creado:

=docker images=

Tenemos una nueva imagen de 155Mb con el nombre que habíamos puesto!!!
#+begin_src 
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
ejabberd_imagen           dockerfile          983bc10a3e5b        47 seconds ago      155MB
#+end_src

** Creando del Contenedor
Ya tenemos nuestra imagen, ahora vamos a crear el contenedor.
A la imagen la nombramos *ejabberd_imagen* y al contenedor, lo pondremos el nombre de *ejabberd*

Solo hay 2 valores que tiene que añadir:
- $USUARIO  : Escribe tu usuario
- $IMAGE_ID : Escribe el número de *IMAGE ID*, que te apareció en el paso anterior.

=docker run -dti --name ejabberd --restart=unless-stopped -p 5280:5280 -p 5222:5222 -v /home/$USUARIO/docker/ejabberd_config:/etc/ejabberd/  $IMAGE_ID=

En la carpeta =/home/$USUARIO/docker/ejabberd_config=, encontraremos el archivo de configuración del servidor.
** Entrar en el Docker
Ahora vamos a entrar al interior del Docker. Una vez dentro de este, estaremos en una versión de debian, con todo lo justo para que funcione nuestro servidor y para que sea del mínimo tamaño.

=docker exec -i -t ejabberd /bin/bash=

ejabberd es el nombre que habíamos dado a nuestro contenedor.
** Vamos a configurar nuestro servidor
Una vez dentro, mediante este comando, daremos nombre al servidor, nombre de administrador y contraseña del mismo.

=dpkg-reconfigure ejabberd=

Es posible que de error. Si es así, pararemos el servidor y lo volveremos a iniciar.

_Detener el servidor_

=service ejabberd stop=

_Iniciar el servidor_

=service ejabberd start=


** Configurando el servidor

Ahora nos conectamos a =https://ip:5280/admin=, que es la web de administración del servicio. Nos pedirá para acceder el nombre del servidor y usuario del administrador, que hemos puesto en el paso anterior.

Nombre de usuario: admin@localhost
Contraseña: password

Archivo de configuración está en: =/etc/ejabberd/ejabberd.yml=

** Añadir usuarios 
Para añadir usuarios desde la interfaz de administración web, seleccionaremos en el menú *Dominios Virtuales* -> *Dominio* -> *Usuarios*.
Ahí, añadiremos nuestros usuarios y sus contraseñas. Esto sería en el caso que únicamente el administrador del servidor, sea el único que permita el registro de usuarios, tal como viene por defecto. También podríamos hacer que cada usuario que quiera, pueda registrarse.


** Aumentar la velocidad de transferencia de archivos. TRAFFIC SHAPERS

Ejabberd/xmpp, no está diseñado para transferir archivos, aún así, notarás que la transferencia de archivos es muy lenta y es debido a que el archivo de configuración tiene limitación en la transferencia por defecto, por si el número de usuarios que van a utilizar el servidor es muy grande. También tiene limitado el tamaño máximo de archivo a compartir. Desmarca mediante *#* o personaliza a tu gusto los parametros en *ejabberd.yml*, Recuerda que puedes acceder desde fuera del contenedor, gracias al volumen que creamos al crear el mismo.

#+begin_src 
shaper:
  ##
  ## The "normal" shaper limits traffic speed to 1000 B/s
  ##
##########  normal: 10000000

  ##
  ## The "fast" shaper limits traffic speed to 50000 B/s
  ##
##########  fast: 50000

##
## This option specifies the maximum number of elements in the queue
## of the FSM. Refer to the documentation for details.
##
#max_fsm_queue: 1000
#+end_src

Podemos personalizar absolutamente nuestro servidor desde este archivo, pero es muy complejo. Visita la web de ejabberd para ver ejemplos y sobretodo, haz una copia del archivo antes de modificarlo. 


** Web ejabberd
- https://www.ejabberd.im/
* TODO Cliente dlna para tu escritorio 
:PROPERTIES:
:TITLE:   Cliente dlna para tu escritorio
:EXPORT_FILE_NAME: Cliente dlna para tu escritorio
:DESCRIPTION: Ya os expliqué como crear tu servidor dlna en raspberry o servidor Linux y como crear listas en m3u para el servidor, ahora tocaría el poder utilizar un cliente dlna en tu escritorio. Tenemos muchas aplicaciones para movil, smart TV,... pero, ¿Para escritorio?, no tendría sentido el montar un servidor multimedia solo para movil, tabletas y Tv. La verdad, es que escasean para escritorio, pero gracias a aplicaciones como Rhythmbox y sus plugins, podemos utilizar dlna de un modo muy sencillo. Aquí os explico como hacerlo
:EXPORT_DATE: 2019-02-16 20:30 
:CATEGORY: servidor
:TAG:      dlna
:IMAGE: ./images-blog/rhythmbox.png
:END:

#+HTML: <center>

[[./images-blog/rhythmbox.png]]
#+HTML: </center>

Ya os expliqué como [[https://ugeek.github.io/blog/post/2018-12-27-minidlna.html][crear tu servidor dlna en raspberry o servidor Linux]] y [[https://ugeek.github.io/blog/post/2019-01-02-crear-listas-m3u-para-minidlna-o-vlc.html][como crear listas en m3u para el servidor]], ahora tocaría el poder utilizar un cliente dlna en tu escritorio. Tenemos muchas aplicaciones para movil, smart TV,... pero, ¿Para escritorio?, no tendría sentido el montar un servidor multimedia solo para movil, tabletas y Tv. La verdad, es que escasean para escritorio, pero gracias a aplicaciones como [[https://wiki.gnome.org/Apps/Rhythmbox][Rhythmbox]] y sus plugins, podemos utilizar dlna de un modo muy sencillo. Aquí os explico como hacerlo:

** Instalaremos Rhythmbox

=sudo apt install rhythmbox=

Una vez instalado, en los menús, accederemos a: *Herramientas -> Complementos*, habilitaremos marcando el checklist: *Explorador de medios Grilo*

** Instalando en tu distro
Buscamos los plugins de Grilo en nuestra distro:

=sudo apt search grilo-plugins=

En Ubuntu 18.04, nos aparece *grilo-plugins-0.3*, dependerá la versión de que distro tengamos instalada. Instala la que tengas:

=sudo apt install grilo-plugins-0.3=

Ahora si abrimos Rhythmbox, tendría que aparecer nuestro servidor.

** VLC
[[./images-blog/vlc.png]]

Para los que utilizamos VLC y no nos apetece el instalar o utilizar Rhythmbox, sigue los siguientes pasos:

- Una vez abierto VLC, pulsa *CTRL + L*
- En la columna derecha, bajo *Red Local*, haz click en *Plug’n’Play Universal*
- En la parte derecha, nos aparecerán todos los Servidores dlna disponibles en nuestra red local


* TODO Instalar servicios o aplicaciones con Docker para tu Raspberry o cualquier servidor GNU/Linux
:PROPERTIES:
:TITLE:   Instalar servicios o aplicaciones con Docker para tu Raspberry o cualquier servidor GNU/Linux
:EXPORT_FILE_NAME: Instalar servicios o aplicaciones con Docker para tu Raspberry o cualquier servidor GNU-Linux
:DESCRIPTION: El objetivo del post de hoy, va a ser crear un contenedor con una sola línea de comandos, entrar dentro de este, instalar un servicio o aplicación e iniciarlo. Pero lo mejor de todo, es que vamos a utilizar una distro diferente para nuestro contenedor, creando un servidor con un Ubuntu 18.04 en una Raspberry con sistema operativo Raspbian
:EXPORT_DATE: 2019-02-24 17:30 
:CATEGORY: docker
:TAG:      docker
:IMAGE: ./images-blog/docker.png
:END:

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

El objetivo del post de hoy, va a ser crear un contenedor con una sola línea de comandos, entrar dentro de este, instalar un servicio o aplicación e iniciarlo. Pero lo mejor de todo, es que vamos a utilizar una distro diferente para nuestro contenedor, creando un servidor con un *Ubuntu 18.04* en una Raspberry con sistema operativo *Raspbian*.

De esta manera, podremos acceder a los repositorios de Ubuntu en su última versión, con paquetes totalmente actualizados utilizando Raspbian.

Parece muy complejo, pero es muy sencillo.
** Instalación
Vamos a instalar Docker desde los repositorios oficiales:

=sudo apt install docker=

También lo tenemos disponible en la paquetería snap, así que a dia de hoy, es muy sencilla su instalación.

** Crear el grupo docker, para no tener que poner siempre sudo
Para no tener que utilizar Docker como usuario root y así evitar el tener que poner siempre *sudo*, crearemos el grupo docker y añadiremos los usuarios.
#+BEGIN_SRC 
sudo groupadd docker
sudo usermod -aG docker $USER
#+END_SRC
También es muy útil a nivel de seguridad deshabilitar el usuario root, para iniciar y detener servicios con la sesión del propio usuario o mediante el cron este, programar el encendido y apagado de los contenedores. 

** Creando un contendedor con Ubuntu en su ultima versión
Creando el nuevo contenedor con la última versión de Ubuntu para Raspberry o cualquier arquitectura de procesador y entrando directamente a este contenedor una vez creado:

=docker run -t -i ubuntu:latest /bin/bash=

Para nuestra Raspberry, si queremos, también podemos especificar la arquitectura con la que queremos montar en nuestro contenedor:

=docker run -t -i arm32v7/ubuntu:latest /bin/bash=

La versión *"latest"*, es la 18.04, si queremos utilizar una en concreto, deberemos especificarlo.

Una vez creado el contenedor y dentro de él, podemos salir pulsando =exit= o =Ctrl-d=. Esto dentendrá nuestro contenedor, para que esto no suceda, pulsa =Ctrl+p+q=

** Listar todos los Contenedores de nuestro servidor
Vamos a listar todos los contenedores que tenemos en nuestro servidor, indistintamente si están corriendo ahora o no:

=docker ps -a=

No confundir con ver todos los contenedores que están corriendo ahora mismo en nuestro servidor, que lo haríamos así:

=docker ps=

** Iniciar o detener un contenedor
Super sencillo, con docker *start/stop*:

=docker start nombre_del_contenedor=

=docker stop nombre_del_contenedor=

** Entrar dentro del Docker vía terminal
Para entrar a la terminal de nuestro contenedor, tenemos que ejecutar:
=docker exec -i -t nombre_del_contenedor /bin/bash=

** Ejemplo práctico de todo lo visto. Descargar imagen y crear e iniciar contenedor
Voy a explicar, con el servicio garbera de ejemplo, como descargar la imagen, crear el contenedor e iniciarlo con una única línea de terminal. 

=docker run -t -i --name gerbera -p 1900:1900 -p 49152:49152 -v /home/usuario/docker/gerbera:/etc/gerbera/ -v /media:/root arm32v7/ubuntu:latest /bin/bash=

Vamos a entenderlo:
- Poner un nombre al contenedor que se creará =--name gerbera= El nombre será gerbera
- Crea imagen con la ultima versión de ubuntu con arquitectura para raspberry: =arm32v7/ubuntu:latest=. Si fuera para cualquier arquitectura y que se instale el más adecuado:  =ubuntu:latest=
- Que el contenedor creado, tenga abiertos los puertos 1900 y 49152 =-p 1900:1900 -p 49152:49152=
- Tener 2 carpetas de intercambio de archivos, entre carpetas del servidor y carpetas internas del contenedor =-v /home/usuario/docker/gerbera:/etc/gerbera/ -v /media:/root=

Una vez estemos dentro del contenedor, igual que haríamos si nos hubiéramos conectado a un servidor por ssh, instalaremos e iniciaremos el servicio:

 *Recuerda sustituir "usuario", por tu usuario, no hagas un copia y pega* 😜
** Borrar un contenedor
Si ya has acabado con tus pruebas, voy a explicarte algunos comando muy útiles, como borrar el contenedor, imagenes, etc... que ya no vamos a utilizar:

Detenemos el contentedor:

=docker stop nombre_del_contenedor=

Borramos el contendedor:

=docker rm nombre_del_contenedor=

** Listar y borrar imagenes
Es posible que quieras eliminar la imagen con la que habíamos creado nuestro Docker, para ello, listaremos y borraremos así:

Listar todas las imágenes:

=docker images=

Borrar la imagen (rm"i" de imágen, para recordar):

=docker rmi nombre_de_la_imagen=


** Renombrar Contenedor
En caso que quisieras cambiar el nombre del contenedor, haremos lo siguiente:

=docker rename nombre_actual nombre_nuevo= 

** Conclusiones
Con un poco de práctica, como ves, Docker puede ayudarte a probar, practicar y utilizar servicios o aplicaciones, dentro de estos de un modo muy limpio y sencillo. El punto fuerte es que no vas a romper nada del sistema operativo anfitrión, y además, en el caso de la Raspberry, utilizar aplicaciones a la última que no están disponibles en Raspbian. 
* TODO Simplenote en Emacs
:PROPERTIES:
:TITLE:   Simplenote en Emacs
:EXPORT_FILE_NAME: Simplenote en Emacs
:DESCRIPTION: Simplenote, es una aplicación de notas muy conocida de Software Libre, totalmente multiplataforma y gratuita. Podemos utilizar Simplenote en nuestro navegador web, aplicaciones de escritorio (incluso con paquete snap), Android, iOS... Y lo mejor de todo, podemos utilizarla en Emacs con el paquete simplenote2, disponible en los repositorios de Melpa.
:EXPORT_DATE: 2019-03-10 17:15 
:CATEGORY: emacs
:TAG:      orgmode,emacs
:IMAGE: ./images-blog/simplenote.png
:END:

#+HTML: <center>
[[./images-blog/simplenote.png]]
#+HTML: </center>


Simplenote, es una aplicación de notas muy conocida de Software Libre, totalmente multiplataforma y gratuita. Podemos utilizar Simplenote en nuestro navegador web, aplicaciones de escritorio (incluso con paquete snap), Android, iOS... Y lo mejor de todo, podemos utilizarla en Emacs con el paquete *simplenote2*, disponible en los repositorios de Melpa.

Simplenote va a permitir la sincronización de nuestras notas en texto plano o markdown por defecto. Pero ya que estamos en Emacs, *voy a habilitar el modo org y tener sincronizado mis archivos orgmode*.

El paquete *simplenote2*, crea una carpeta oculta en la raíz de nuestro Home, llamada *.simplenote2*. Dentro, encontraremos todas nuestras notas de un modo transparente, igual que si fuera una carpeta de sincronización de Dropbox. Así nuestras notas también estarán siempre en nuestro PC.

Si utilizamos Emacs en versión terminal, también podremos utilizar el paquete. Así que ya tenemos aplicación de notas desde nuestra terminal.

Recuerda que una de las virtudes de Simplenote, es compartir nuestras notas o documentos orgmode, tener un control de versiones y colaborar en equipo editando simultaneamente estas, varios usuarios.

Te recomiendo escuchar el Podcast donde hablo de todo esto.
** Instalación
Instalaremos desde Melpa:

=M-x package-install RET simplenote2 RET=
** Configuración
Añadiremos en nuestro archivo de configuración, ya sea *.emacs* o *init.el*, los siguientes requisitos:
#+begin_src 
(require 'simplenote2)
(setq simplenote2-email "email@ejemplo.com")
(setq simplenote2-password "tu_contraseña")
(simplenote2-setup)
#+end_src

Para acceder a la pantalla principal de Simplenote mediante un atajo (C-c C-s), he añadido el siguiente código:

=(global-set-key (kbd "C-c C-s") 'simplenote2-browse)=


Estas líneas son opcionales. Permiten crear mediante atajos: tags, así como empujar o descargar la nota que estamos editando en ese momento. 
#+begin_src 
(add-hook 'simplenote2-note-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c C-t") 'simplenote2-add-tag)
            (local-set-key (kbd "C-c C-c") 'simplenote2-push-buffer)
            (local-set-key (kbd "C-c C-d") 'simplenote2-pull-buffer)))
#+end_src


** Utilizando Simplenote
Para acceder a la pantalla principal de Simplenote sin el atajo antes descrito, introduciremos el comando: 

=M-x simplenote2-browse=

La primera vez que accedas, estará sin contenido, ejecuta en la parte superior *[Sync with server]*, para que descargue tus notas del servidor a la aplicación. Si no añadiste tu correo y contraseña, Simplenote te preguntará por ellas para que lo introduzcas.


A la parte derecha de cada nota, nos aparece *[Delete]*. Si pulsamos para borrar y después pulsamos *[Sync with server]* o sincronizamos pulsando la letra *g* (En el siguiente apartado, aparecen todos estos atajo), actualizará todas las notas y borrará la que habíamos seleccionado, enviándola a la papelera.


Como ves, la interfaz es muy intuitiva, podemos crear nuevas notas, editar o eliminar notas existentes... 

** Atajos
Estando *dentro de la ventana de Simplenote en Emacs*, podremos utilizar los siguientes atajos:

| Tecla | Acción                                                                               |
|-------+--------------------------------------------------------------------------------------|
| g     | sincronizar con el servidor (igual que M-x simplenote2-sync-notes)                   |
| a     | crear una nueva nota                                                                 |
| Enter | nota abierta sobre la linea actual                                                   |
| d     | marca nota en la línea actual para eliminar                                          |
| u     | desmarque la nota en la línea actual para eliminar                                   |
| t     | establecer etiquetas para el filtrado (igual que M-x simplenote2-filter-note-by-tag) |
| '^'   | alternar las condiciones de filtrado de etiquetas entre "AND" y "OR"                 |
| '/'   | establecer regexp para el filtrado                                                   |

** Enviando todo a Simplenote
Si estás en cualquier buffer, fuera de Simplenote, creando una nota o escribiendo cualquier texto, si ejecutamos el siguiente comando, este bufer será enviado en forma de nota a Simplenote.

=M-x simplenote2-create-note-from-buffer=

** Sincronizando las modificaciones
Tal como hacemos en git, podemos empujar la nota actual que estamos editando al servidor o descargarla:
- Empujar nota al servidor: =M-x simplenote2-push-buffer=
- Descargar la nota del servidor. Cuando la nota se modifique localmente, preguntará si la envía al servidor. Si la respuesta es afirmativa, este comando actúa como =M-x simplenote2-push-buffer=: =M-x simplenote2-pull-buffer=

Para salir, utilizaremos =C-u M-x=
** Etiquetas
Simplenote utiliza etiquetas para poder clasificar y posteriormente filtrarlas medieante =M-x simplenote2-filter-notes-by-tag=. Este comando, preguntará el nombre de la etiqueta.

** Creando atajo preestablecido
En Nuestro archivo de configuración *.emacs* o *init.el*, podemos añadir un filtro preestablecido con un atajo de teclado. Ejemplo:

=(setq simplenote2-filter-note-tag-list '("tag1" "tag2" "tag3"))=


** Añadir etiquetas o atributos
Puede establecer etiquetas o atributos para nuevas notas de forma predeterminada utilizando la variable de personalización =simplenote2-create-note-hook=

#+begin_src
(add-hook 'simplenote2-create-note-hook
	  (lambda ()
	    (simplenote2-set-markdown)
	    (simplenote2-add-tag "tag1")))
#+end_src

** Anclar Notas En la parte superior
Para anclar en la parte superior las notas que deseemos, estando dentro de esta nota ejecutaremos el comando: 

=M-x simplenote2-set-pinned=

** Conclusión
Una herramienta fantástica para aquellos que necesitan una aplicación de notas que podemos compartir, trabajar en equipo, tener un control de versiones... Y lo mejor de todo, en texto plano, markdown y en Emacs, habilitando el modo org, orgmode.

Mas Información en el repositorio de simplenote2: https://github.com/alpha22jp/simplenote2.el
* TODO Crea un Bot de Telegram con Bash y una sola línea de Terminal
:PROPERTIES:
:TITLE:   Crea un Bot de Telegram con Bash y una sola línea de Terminal
:EXPORT_FILE_NAME: Crea un Bot de Telegram con Bash y una sola linea de Terminal
:DESCRIPTION: Como ya sabéis, Telegram es de mis aplicaciones favoritas. Y no solo por todas las características a la hora de enviar mensajes, almacenar archivos, etc... si no que gracias a la sencilla api de Telegram, puedo crear mis bots para que notifiquen todo tipo de cosas que suceden en mi raspberry, servidor, pc
:EXPORT_DATE: 2019-03-14 21:30 
:CATEGORY: telegram
:TAG:      bot, telegram
:IMAGE: ./images-blog/telegram.jpg
:END:
#+HTML: <center>
[[./images-blog/telegram.jpg]]
#+HTML: </center>

Como ya sabéis, Telegram es de mis aplicaciones favoritas. Y no solo por todas las características a la hora de enviar mensajes, almacenar archivos, etc... si no que gracias a la sencilla api de Telegram, puedo crear mis bots para que notifiquen todo tipo de cosas que suceden en mi raspberry, servidor, pc... 

Si, pero... ¿Que nos puede notificar?.

Voy a mostraros algunos ejemplos que yo utilizo:
- Notificación al iniciar un servidor
- Notificación cuando alguien se conecta vía SSH, mostrándome la IP del dispositivo que se conecta
- Cuando ha finalizado la ejecución de un script. Por ejemplo una sicronización con rsync, copia de seguridad...

Gracias a cron, podemos programar mensajes a determinados momentos del día para que nos notifique:
- Consumo de Ram
- Temperatura de la Raspberry
- IP pública de mi red
- Mis tareas pendientes en mi OrgMode

Estos son tan solo unos ejemplos que yo utilizo, pero con un bot de Telegram, puedes hacer tanto como imagines.

Incluso mi Router con OpenWrt, va enviándome mensajes, jejeje   

Durante mucho tiempo he estado utilizando Bots desarrollados en Python, pero en este Post voy a explicaros como hacerlo desde de Bash que es muchísimos más sencillo. De momento vamos a enviar mensajes de Texto.

** Primer paso para crear un Bot
Voy a explicar en sencillos pasos como crear un Bot con [[https://t.me/BotFather][@BotFather]], que es el padre de todos los Bots, creado por Telegram con el fin de facilitar la creación de estos:

- Clicamos este enlace [[https://t.me/BotFather][@BotFather]] e iniciamos el Bot.

- Seleccionamos o escribimos */newbot*. Nos preguntará: ¿Que nombre quieres dar a tu bot?. Escribimos un nombre.

- El Bot nos respone ahora: ¿Que nick quieres usar para este bot?, recuerda que el nick debe de acabar en bot o _bot.
  ejem: @nick_bot, @nickbot,...

- @BotFather ya nos ha creado el bot!!!. Ahora ya tenemos nuestro numero de Token para poder utilizar nuestro bot.


Si escribimos en @BotFather: */setuserpic*, podremos elegir una foto para nuestro bot. Hay muchas mas opciones como añadir una descripción y demas, pero eso ya os lo dejo a vosotros...


Cada usuario en Telegram tenemos un identificador, *ID*. Podemos saber el nuestro iniciando este bot  [[https://t.me/userinfobot][@userinfobot]].

Si queremos añadir el Bot en un Grupo o Canal, para que envíe mensajes o haga cualquier función, tendremos que averiguar el *ID* de ese Grupo o Canal. Para ello reenvía un mensaje desde el Canal/Grupo al Bot  [[https://t.me/ChannelIdBot][@ChannelIdBot]].


** Vamos a crear nuestro Bot
Lo primero que haremos, es confirmar que realmente podemos enviar mensajes con nuestro bot desde la terminal.

Creamos el script:
=nano mi_bot_telegram.sh=

Una vez abierto nano, vamos a copiar el contenido añadiendo el *TOKEN* del bot y nuestro *ID*.
#+BEGIN_SRC 
#!/bin/bash

TOKEN="escribe tu token aquí"
ID="escribe tu id aquí"
MENSAJE="Esto es un Mensaje de Prueba"
URL="https://api.telegram.org/bot$TOKEN/sendMessage"

curl -s -X POST $URL -d chat_id=$ID -d text="$MENSAJE"
#+END_SRC
Ahora daremos permisos de ejecución:

=sudo chmod +x mi_bot_telegram.sh=

Vamos a ejecutarlo:

=sh mi_bot_telegram.sh=

FUNCIONA!!!!!!!!

Si hemos escrito correctamente tanto el *TOKEN* como el número de nuestro *ID*, habremos recibido un mensaje en el chat del bot que hayamos creado con el contenido: *Esto es un Mensaje de Prueba*

Si somos un poco mas atrevidos o conocemos mejor bash, te abras dado cuenta que no era necesario hacer un script y podemos enviar el mensaje desde una única línea de Terminal. Sustituye añade el valor de las variables en la última línea del script así:
#+BEGIN_SRC 
curl -s -X POST https://api.telegram.org/bot"30534591:AAH5d23KtktfTQSWJMT9CiuginbsFQiF_2nB4"/sendMessage -d chat_id="57384545" -d text="Esto es un Mensaje de Prueba"
#+END_SRC
Como puedes ver, he puesto unos valores inventados de muestra.

** Muestra la Ip de la máquina que se conecta por SSH
Si utilizas Bash, sabes que cada vez que te conectas por ssh o inicias una nueva sesión en tu terminal, Bash lee el archivo *.bashrc*. En él, al final de este archivo de configuración, añadiremos la línea de nuestro Bot y dentro del mensaje de texto, en lugar de un mensaje escribiremos:

#+BEGIN_SRC 
$(echo $SSH_CLIENT | awk '{ print $1}')
#+END_SRC

Quedaría de la siguiente manera:
#+BEGIN_SRC 
curl -s -X POST https://api.telegram.org/bot"30534591:AAH5d23KtktfTQSWJMT9CiuginbsFQiF_2nB4"/sendMessage -d chat_id="57384545" -d text="Se acaba de contecta por ssh con la IP $(echo $SSH_CLIENT | awk '{ print $1}')"
#+END_SRC
Si quieres probar que realmente funciona desde tu terminal, escribe en ella:

=echo $SSH_CLIENT | awk '{ print $1}'=

** Ip Pública
Vamos a conocer la IP pública y conectarnos directamente con nuestra Raspberry:

=curl ifconfig.co=

Como en el caso anterior, sustituiremos el texto plano por esto:
 
=$(curl ifconfig.co)=

** Temperatura de tu Raspberry
Con este comando, tendré controlada la temperatura de mi raspberry y además, quedará guardado el historial en el chat del Bot:

#+BEGIN_SRC 
/opt/vc/bin/vcgencmd measure_temp
#+END_SRC

Sustituye el texto del Bot por:

#+BEGIN_SRC 
$(/opt/vc/bin/vcgencmd measure_temp)
#+END_SRC

** Al Iniciar mi servidor
He creado una carpeta llamada "scripts" en el "Home" del usuario. Allí he creado el script del Bot llamado *inicio.sh*, con un mesaje de texto tipo:

*Se ha iniciado mi Raspberry*

Para que esto funciones, vamos a escribir en cron, que cada vez que inicie nuestro servidor, PC, raspberry,... Nos envíe el mensaje:

Escribe en la Terminal:

=crontab -e=

Y en la primera línea, escribiremos lo siguiente:

=@reboot ( sleep 100 ; sh $HOME/scripts/inicio.sh )=

Esto significa que tras 100 segundos después del  inicio de nuestro servidor, pc, raspberry,... ejecutará el script *inicio.sh*, de manera que nos enviará el texto que pusimos en el script "*Se ha iniciado mi Raspberry*".

** Conclusión
Espero que te haya gustado este Post y Podcast. Ahora te toca a ti experimentar y juguetear con tu Bot de Telegram. Comenta tu experiencia en el Grupo de uGeek en Telegram.


* TODO Cursos, Webs, Grupos, Tutoriales... Todo sobre Emacs y OrgMode
:PROPERTIES:
:TITLE:  Actualizado: Cursos, Webs, Grupos, Tutoriales... Todo sobre Emacs y OrgMode
:EXPORT_FILE_NAME: Cursos Webs Grupos Tutoriales Todo sobre Emacs y OrgMode
:DESCRIPTION: Muchos de vosotros me comentáis si os puedo recomendar un sitio donde iniciaros con Emacs y OrgMode
:EXPORT_DATE: 2019-03-15 23:00 2019-11-01
:CATEGORY: emacs
:TAG:      emacs,orgmode
:IMAGE: ./images-blog/emacs.png
:END:

#+HTML: <center>
[[./images-blog/emacs.png]]  
#+HTML: </center>


Muchos de vosotros me comentáis si os puedo recomendar un sitio donde iniciaros con Emacs y OrgMode. Como una imagen vale mas que mil palabras, la [[https://www.emacswiki.org/emacs?interface=es][EmacsWiki]] me ha llevado al repositorio en GitHub de [[https://github.com/farliz/emacs-academia/blob/master/contenido.md][farliz/emacs-academia]], donde están estos enlaces que te llevan a un magnífico Curso en Vídeo y en Castellano, donde ver un poco como funciona Emacs. 

La verdad es que ahora no tienes escusas para aprender Emacs!!!

En la parte final del curso, adjunta una serie de comandos para descargarlos en Local. Yo los he reagrupado en un script.

He añadido unas conferencias de Medialab-Prado, un vídeo que resume muy bien OrgMode y una lista de vídeos de [[https://www.youtube.com/user/koenighaunstetten][Rainer König]] sobre OrgMode en Inglés pero muy sencillos de seguir.

En la Parte final, añadido una serie de PDF's con comandos y documentación.

Es una información muy interesante, así que agradeciendo el magnífico trabajo de todas las fuentes, he añadido el contenido en la web para no perderlo de vista. 


** Webs, Canales y Grupos de Telegram, Reddit
_Webs_
- [[http://planet.emacs-es.org][Planet Emacses]]
- [[http://planet.emacslife.com/][Planet Emacs Life (Inglés)]]
- [[http://sachachua.com/blog/][Blog de Sachachua (Inglés)]]

_Telegram_
- [[https://t.me/emacs_es][Grupo Emacs]]
- [[https://t.me/Org_Mode][Canal Orgmode]]

_Reddit_
- [[https://www.reddit.com/r/emacs][Emacs]]
- [[https://www.reddit.com/r/planetemacs/][Planet Emacs]]
- [[https://www.reddit.com/r/orgmode/][OrgMode]]

** Vídeos
_Parte 1: Emacs Básico_

 1. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8787/emacs1.webm][Introducción]]
 2. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8807/emacs2.webm][Buffers 1]]
 3. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8808/emacs3.webm][Primeros comandos 1]]
 4. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8810/emacs4.webm][Primeros comandos 2]]
 5. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8812/emacs5.webm][Modos mayores / Buffers]]
 6. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8813/emacs6.webm][Mini buffer / configuración de emacs]]
 7. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8814/emacs7.webm][init.el / configuración de Emacs]]
 8. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8815/emacs8.webm][Mas configuración]]
 9. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8816/emacs9.webm][Linea de modo]]

  * [[https://www.dropbox.com/s/xmflteig5j77hf4/suelo.txt?dl=0][suelo.txt]]

10. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8817/emacs10.webm][Buscar palabras en un texto]]
11. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8818/emacs11.webm][Buscar y reemplazar]]
12. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8819/emacs12.webm][Importante]]
13. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8820/emacs13.webm][ido-mode]]
14. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8821/emacs14.webm][customize]]
15. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8822/emacs15.webm][instalar paquetes (plugins)]]
16. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8823/emacs16.webm][COPIAR / CORTAR / PEGAR / DESHACER]]
17. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8824/emacs17.webm][helm-mode]]
18. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8825/emacs18.webm][MOVIMIENTOS ESENCIALES]]
19. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8826/emacs19.webm][COPIAR y PEGAR II]]
20. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8827/emacs20.webm][Modos menores / auto-fill-mode]]
21. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8828/emacs21.webm][solarized-theme / Opcional]]

Al finalizar esta sección, estarán en capacidad de seguir y entender la siguiente guía. [[http://therandymon.com/papers/emacs-for-writers.pdf][Emacs for writers]]

_Parte 2_

 1. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8829/emacs22.webm][Corrección ortográfica 1]]
 2. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8830/emacs23.webm][Corrección ortográfica 2]]
 3. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8831/emacs24.webm][BibTeX]]
 4. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8833/emacs25.webm][AucTeX y RefTeX instalación]]
 5. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8834/zotero.webm][Zotero]]
 6. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8836/emacs26.webm][LaTeX demo]]
      + [[https://www.dropbox.com/s/0ibsirx4a65eq17/tutorial.zip?dl=0][Archivo]]
 7. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8841/emacs26.webm][Movimientos esenciales II]]
 8. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8842/emacs27.webm][Evaluar código LISP C-x C-e]]
 9. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8885/emacs28.webm][Configuración Final]]
10. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8911/emacs29.webm][Edición del texto]]
11. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8915/emacs30.webm][Edición de texto II]]
12. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8916/emacs31.webm][Formato I]]

  * Corrección: En este video cuando digo C-h, quiero decir M-h

13. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8917/emacs32.webm][Markdown]]
14. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/8919/emacs33.webm][ConTeX]]

  * [[https://cloud.openmailbox.org/index.php/s/iFRESi5QDkT6SXJ][PDF]]

15. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13066/helm-bibtex.medium.webm][Helm-bibtex]]
16. [[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/11660/emacs-pdf.medium.webm][export-to-pdf]]

_Curso Básico de ConTeXt_

1.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13173/context_1.webm][Instalación]]

2.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13174/context-presentacion.webm][Presentación]]

3.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13175/context-extra1.webm][simpleslides]]

4.[[https://b2aeaa58a57a200320db-8b65b95250e902c437b256b5abf3eac7.ssl.cf5.rackcdn.com/media_entries/13176/context-ayuda.webm][Manual de ConTeXt]]

_Descargar todos los Vídeos_

Para descargar todos los videos pueden ejecutar las siguientes lineas en una terminal.

 0. mkdir emacs-videos && cd emacs-videos
   
 1. wget [[https://github.com/farliz/emacs-academia/blob/master/contenido.md][https://github.com/farliz/emacs-academia/blob/master/contenido.md]]
   
 2. grep -Eo '(http|https)://.+webm' contenido.md > videos.txt
   
 3. wget -i videos.txt
   
 Canal en Goblinrefuge

[[https://goblinrefuge.com/mediagoblin/u/farliz/][https://goblinrefuge.com]]

_Script para descargar los Vídeos_

#+BEGIN_SRC 
#/bin/bash/
mkdir emacs-videos && cd emacs-videos
wget https://github.com/farliz/emacs-academia/blob/master/contenido.md
grep -Eo '(http|https)://.+webm' contenido.md > videos.txt
wget -i videos.txt   
#+END_SRC
** Vídeos, listas y conferencia sobre Orgmode


#+ATTR_HTML: :width 250px :height 250px
[[./images-blog/orgmode.png]]  


_Mi primera configuración Emacs con elisp y orgmode_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/bnu-ZGpRly4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

_"Organiza tu vida" Emacs y Org-mode Madrid 2017 Medialab-Prado_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/QBPTNz3Qqqo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

_"Organiza tu vida" Emacs y Org-mode Madrid 2017 Medialab-Prado_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/bzZ09dAbLEE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

_OrgMode tutorial_

#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/sQS06Qjnkcc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


** Manuales
- [[http://www.davidam.com/docu/orgguide.es.html][Guía sobre OrgMode]]
- [[https://orgmode.org/worg/orgguide/orgguide.es.pdf][Manual en PDF de OrgMode]]
- [[https://orgmode.org/orgguide.pdf][Manual en Inglés. Última versión OrgMode]]
- [[http://es.tldp.org/Tutoriales/doc-tutorial-emacs/intro_emacs.pdf][Manual sobre Emacs]]
- [[http://portal.uned.es/pls/portal/docs/PAGE/UNED_MAIN/LAUNIVERSIDAD/UBICACIONES/01/OFERTAESTUDIOS/GRADOS_CIENCIAS/SOFTWARE%20DESCARGAS%20LINUX/MANUALES/EMACS_MANUAL_MINIMO_17PAGS.PDF][Manual mínimo Emacs]]
- [[http://www.hectormora.info/emacs_man.pdf][Breve Introducción de Emacs]]
- [[http://di002.edv.uniovi.es/~labra/cursos/latex04/cursoLaTeX.pdf][Presentación Emacs y Latex]]
- [[https://blyx.com/public/docs/programacion/Emacs.pdf][Plantilla Emacs]]
- [[https://www.blackhats.es/wordpress/][Blog blackhats. Desactualizado pero muy interesante]]



* TODO Monta un servidor web Nginx, con una sola línea de Terminal (Docker)
:PROPERTIES: 
:TITLE:  Monta un servidor web Nginx, con una sola línea de Terminal (Docker)
:EXPORT_FILE_NAME: Monta un servidor web Nginx con una sola linea de Terminal Docker
:DESCRIPTION: Si quieres montar un servidor web en un pispás y no complicarte la vida, el Docker oficial de nginx es una buenísima solución
:EXPORT_DATE: 2019-03-25 21:10 
:CATEGORY: docker
:TAG:      servidor,web
:IMAGE: ./images-blog/nginx.png
:END:

Si quieres montar un servidor web en un pispás y no complicarte la vida, el [[https://hub.docker.com/_/nginx][Docker oficial de Nginx]] es una buenísima solución.
Hay tres motivos por los cuales instalar este Docker: 
- Versión oficial a la última
- Solo una línea de Terminal
- Funciona con todas las arquitecturas (amd64, arm32v6, arm32v7, arm64v8, i386, ppc64le, s390x)

#+HTML: <center>
[[./images-blog/nginx.png]]
#+HTML: </center>

También podemos instalar Nginx, partiendo de Alpine Linux, ocupando aproximadamente una décima parte.
En próximos Post y Podcast, os hablaré más de Alpine Linux que para Docker que es espectacular. Nos permite montar montones de servicios con un mínimo espacio.


Para utilizar otro puerto que no sea el 80, por ejemplo el puerto 90, ejecutaremos en la línea de terminal =-p 90:80=.

** Montando el Docker oficial de Nginx para arquitectura 64bits
Este Docker funciona con todas las arquitecturas especificando o no el TAG de la misma. El tamaño de la Imagen es de 109MB.
Vamos a instalarlo y probar: La carpeta *$HOME/docker/nginx*, será la raiz del servidor web.

=docker run --name nginx -d -p 80:80 -v $HOME/docker/nginx:/usr/share/nginx/html:ro nginx=


** Docker oficial de Nginx, arquitectura 64bits. Alpine Linux
Ahora vamos a Instalar el mismo Docker oficial, pero partiendo de un Alpine Linux. Tan solo 16.1MB de Imagen!!!
La carpeta *$HOME/docker/nginx*, será la raiz del servidor web.

=docker run --name nginx -d -p 80:80 -v $HOME/docker/nginx:/usr/share/nginx/html:ro amd64/nginx:alpine=


** Docker oficial de Nginx en Raspberry
Me he emocionado tanto instalando Nginx desde un Alpine Linux, que ahora quiero hacer lo propio en mi Raspberry. Tamaño de la Imagen de 13,4 Mb en mi Raspberry.

Como veis, he utilizado el mismo comando que el apartado anterior. La carpeta *$HOME/docker/nginx*, será la raiz del servidor web.

=docker run --name nginx -d -p 80:80 -v $HOME/docker/nginx:/usr/share/nginx/html:ro nginx:alpine=
** Conclusión
Estoy comenzando a tener Dockerdependencia y es que es inevitable. Poder montar tantos servidores web como quiera con un puerto diferente y con la última versión... Como dice el anuncio, no tiene precio, jejeje
* TODO Enviando Imágenes, audios, archivos... con mi bot de Telegram de una sola Línea de terminal
:PROPERTIES: 
:TITLE:  Enviando Imágenes, audios, archivos... con mi bot de Telegram de una sola Línea de Terminal
:EXPORT_FILE_NAME: Enviando Imagenes audios archivos con mi bot de Telegram de una sola Linea de terminal
:DESCRIPTION: En el Post anterior vimos como enviar archivos de texto plano a través del Bot, estoy seguro que estas totalmente emocionado y ahora te preguntas si también podemos enviar imágenes, archivos,... La respuesta es Sí!
:EXPORT_DATE: 2019-03-28 16:25
:CATEGORY: telegram
:TAG:      bot
:IMAGE: ./images-blog/botfather.png
:END:
El duelo está a un nivel muy alto y sabia que enfrentarme a Lorenzo, no iba a ser tarea fácil. La pasión que ambos tenemos por la creación de Bots en  Telegram, va ha hacer que este duelo nos haga asentar muchísimo mas nuestros conocimientos.

#+HTML: <center>
[[./images-blog/botfather.png]]
#+HTML: </center>

En el Post anterior vimos como enviar archivos de texto plano a través del Bot, estoy seguro que estas totalmente emocionado y ahora te preguntas si también podemos enviar imágenes, archivos,... La respuesta es Sí!!, así que vamos a ver como enviar estos desde una sola línea de terminal con bash, pero antes, vamos a hacer recuento de como van los Post del duelo: 

** Recuento de las últimas publicaciones sobre bots de Telegram (el duelo)
Estos son los Post de [[https://www.atareao.es/][atareao.es]] y míos sobre los bots de Telegram:
- [[https://www.atareao.es/tutorial/crea-tu-propio-bot-para-telegram/un-bot-de-telegram-con-php/][Un bot de Telegram con PHP]]
- [[https://www.atareao.es/tutorial/crea-tu-propio-bot-para-telegram/bot-en-python-para-telegram/][Un bot en Python para Telegram (y en una sola línea)]]
- [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]]

Ahora que ya estamos al día, vamos al tema:  
** Enviar Mensajes de Texto (Repaso)
Nos quedamos aquí, en enviar mensajes de texto plano. Si no sabes como crear tu bot o has llegado aquí y no sabes como empezar, te remito al anterior Post [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]], antes que nos adentramos mas a fondo.

Enviaremos nuestro mensaje de texto plano sustituyendo en esta línea, estos parámetros por nuestros valores:
- TOKEN
- ID
- TU MENSAJE DE TEXTO
#+BEGIN_SRC 
curl -s -X POST https://api.telegram.org/bot"<TOKEN>"/sendMessage -d chat_id="<ID>" -d text="<TU MENSAJE DE TEXTO>"
#+END_SRC
** Enviar una imagen
Para enviar imágenes con nuestro Bot, tendremos que especificar la ruta completa del archivo así como el Token e ID:
- TOKEN
- ID
- RUTA DE NUESTRA IMÁGEN ( Tipo: "~/Imágenes/mifoto.jpg")

#+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendPhoto" -F chat_id="<ID>" -F photo="@<RUTA DE NUESTRA IMAGEN>"
#+END_SRC
** Enviar una imagen que esté en Internet

También podemos enviar imágenes que esten en internet. Del mismo modo, tenemos que especificar la ruta donde esté esta. Atención que cambia un poco la línea, ya no tiene el *@* ante la ruta:
- TOKEN
- ID
- RUTA DE NUESTRA IMÁGEN ( Tipo: "=https://ugeek.github.io/blog/icon/ugeek.png=")
#+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendPhoto" -F chat_id="<ID>" -F photo="<RUTA DE LA IMAGEN EN INTERNET>"
#+END_SRC
** Adjuntar texto junto a la Imágen
Habrás visto que hay imágenes que llevan adjunto un texto en la parte inferior. Para hacer esto, tendremos que adjuntar un nuevo tag a nuestra línea:
- TOKEN
- ID
- RUTA DE NUESTRA IMÁGEN
- TEXTO JUNTO IMAGEN

#+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendPhoto" -F chat_id="<ID>" -F caption="<TEXTO JUNTO IMAGEN>" -F photo="@<RUTA DE NUESTRA IMAGEN>"
#+END_SRC
** Enviar archivos
Para enviar archivos, la línea es muy similar a la de enviar imágenes, solo que en este caso utilizaremos */sendDocument*. También como con las imágenes, especificaremos la ruta completa:
- TOKEN
- ID
- RUTA DEL ARCHIVO
#+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendDocument" -F chat_id="<ID>" -F document="@<RUTA DEL ARCHIVO>"
#+END_SRC

** Adjuntar texto junto al archivo
Para adjunta texto junto a la archivo:

- TOKEN
- ID
- RUTA DEL ARCHIVO
- TEXTO JUNTO IMAGEN
#+BEGIN_SRC 
curl -X  POST "https://api.telegram.org/bot"<TOKEN>"/sendDocument" -F chat_id="<ID>" -F caption="<TEXTO JUNTO IMAGEN> -F document="@<RUTA DEL ARCHIVO>"
#+END_SRC
** Conclusión
Con todo esto y un poco de imaginación, ahora podemos ampliar mucho más las posibilidades de automatización. Espero que os haya gustado el Post y a disfrutar con los Bots
 




* TODO Veracrypt en Ubuntu y tu Raspberry por Terminal
:PROPERTIES: 
:TITLE:  Veracrypt en Ubuntu y tu Raspberry por Terminal
:EXPORT_FILE_NAME: Veracrypt en Ubuntu y tu Raspberry por Terminal
:DESCRIPTION: Es muy probable que desees tener parte de tus datos cifrados para poder almacenarlo en una nube pública o simplemente quieras cifrar parte del contenido almacenado en tu Raspberry
:EXPORT_DATE: 2019-03-29 21:00
:CATEGORY: cifrado
:TAG:      servidor,raspberry
:IMAGE: ./images-blog/veracrypt.png
:END:


#+HTML: <center>
[[./images-blog/veracrypt.png]]
#+HTML: </center>

Es muy probable que desees tener parte de tus datos cifrados para poder almacenarlo en una nube pública o simplemente quieras cifrar el contenido almacenado en tu Raspberry.
 
Quizás quieras cifrar un número de archivos que hay en un PC compartido con otras personas y este contenido lo tengas sincronizado con Syncthing hacia tu Raspberry. 

En tu Raspberry, montarás el Volumen descifrado en otra carpeta, que estará sincronizada también con Syncthing a tu movil, pudiendo ver o editar los archivos en todo momento.

Hay varios métodos como hacerlo que os explicaré en siguientes artículos y Podcast, pero hoy voy a explicaros como hacerlo mediante Veracrypt, una derivación de Truecrypt, que supuestamente Veracrypt a solucionado los problemas encontrados en la auditoria de seguridad.

Veracrypt es una herramienta que permitirá crear un único archivo cifrado de un tamaño que determinaremos en el momento de la creación, y dentro de él estarán todos los archivos que deseemos guardar. Para poder editar, leer,... estos archivos, montaremos el archivo cifrado con Veracrypt en una carpeta vacía, como si se tratase de un usb o disco duro.

Es totalmente multiplataforma y podemos utilizar interfaz gráfica desde el escritorio. 

En este Post os voy a explicar como hacerlo desde la terminal, pero si os resulta muy complicado crear el contenedor cifrado desde la terminal, hacerlo desde un PC y sincronizarlo con vuestra Raspberry.

** Instalación en Ubuntu
En Ubuntu lo instalaríamos mediante PPA:
#+BEGIN_SRC 
sudo add-apt-repository ppa:unit193/encryption
sudo apt-get update
sudo apt install veracrypt
#+END_SRC
- [[https://launchpad.net/~unit193/+archive/ubuntu/encryption][Fuente]]
** Instalación en Raspberry

Instalamos las siguientes dependencias:

#+BEGIN_SRC 
sudo apt-get update
sudo apt-get install libfuse-dev makeself libwxbase3.0-0v5
#+END_SRC

Instalamos la última versión de Veracrypt que podemos [[https://archive.codeplex.com/?p=veracrypt][encontrar en este enlace:]]

#+BEGIN_SRC 
cd 
mkdir veracryptfiles
cd veracryptfiles
wget -L -O veracrypt-1.21-raspbian-setup.tar.bz2 https://launchpad.net/veracrypt/trunk/1.21/+download/veracrypt-1.21-raspbian-setup.tar.bz2
#+END_SRC

Extraemos el archivo descargados:

#+BEGIN_SRC 
tar -vxjf ./veracrypt-1.21-raspbian-setup.tar.bz2
chmod +x veracrypt-1.21-setup-*
#+END_SRC

Instalamos ejecutando el script:

#+BEGIN_SRC 
./veracrypt-1.21-setup-console-armv7
#+END_SRC

Ahora seguiremos los pasos que nos pedirá el programa:
- =1= (instalar)
- =Enter= (aceptar la licencia)
- =yes=

** Desinstalar
Para desinstalar:
#+BEGIN_SRC 
rm -r veracryptfiles
#+END_SRC
** Crear un Volumen

Primero crearemos una carpeta donde queremos montar el volumen. Por ejemplo:

#+BEGIN_SRC 
mkdir -p /media/veracrypt
#+END_SRC

Vamos a crear nuestro volumen, para ello teclearemos este comando y Veracrypt nos hará una serie de preguntas que os explico a continuación. Recuerda, como te he comentado, que si te resulta complejo este paso, crealo desde tu PC y sincronízalo con tu Raspberry.
#+BEGIN_SRC 
veracrypt -t -c
#+END_SRC
Ahora veracrypt nos preguntará:
- Si queremos que el volumen sea oculto. En caso de no serlo, pulsa =1=
- Introduce la ruta completa del archivo cifrado: =$HOME/archivo_cifrado=
- Ahora nos preguntará el tamaño del archivo: =(sizeK/size[M]/sizeG)= por ejemplo 50M (50Mb)
- Nos pedirá con que algoritmo queremos cifrar nuestro archivo, el mas popular es AES, si quieres complicar un poco mas la cosa, selecciona uno de los otros. Introduce el número deseado
- Selecciona el algoritmo de hash deseado =1=
- Ahora seleccionaremos el sistema de archivos. =5=
- Introduce la contraseña. Se recomienda mas de 20 caracteres
- PIM significa Multiplicador de Iteraciones Personales. Presiona =ENTER=
- Si desea utilizar el archivo de claves en lugar de la contraseña, aquí puede definir el archivo de claves. Yo no lo utilizaré, así que presiono =ENTER=
- Como en la versión de terminal, no podemos utilizar el ratón como en la versión gráfica, vamos a teclear 320 caracteres aleatorios para crear la base para tu clave de cifrado.
- Ahora paciencia, la Raspberry será un poco lenta si el volumen que deseamos crear es muy grande

** Montar Volumen

Para montar un volumen ya creado, como la mayoría de cifrados en GNU/Linux, el comando sería:


=veracrypt <carpeta_origen> <carpeta_montaje>=

Ahora vamos a seguir el ejemplo práctico:
#+BEGIN_SRC 
veracrypt $HOME/archivo_cifrado /media/veracrypt
#+END_SRC

Ahora te preguntará que ingreses el PIM, el archivo de claves y si has creado un volumen normal, no oculto. 
Ni no has ingresado nada de esto, pulsa a todo *ENTER*, *ENTER*, *ENTER*. 


Ya tendrás el volumen montado en la ruta que has especificado. Si quieres que la próxima vez no te pregunte nada al montar:

#+BEGIN_SRC 
veracrypt $HOME/archivo_cifrado /media/veracrypt --pim=0 --keyfiles= --protect-hidden=no
#+END_SRC

** Desmontar la unidad

Para desmontar todas las unidades montadas con veracrypt:

=veracrypt -d=

=veracrypt -d <carpeta_origen>=
** Alias puede ser una Buena Idea
Alias puede ser una buena idea si no queremos recordar la ruta de las carpetas:

Enviar mediante printf a .bashrc nuestro comando con las carpetas que vamos a utilizar y el alias, en mi caso, *veracrypt_m*.
#+BEGIN_SRC 
printf "\nalias veracrypt_m=\"veracrypt $HOME/veracrypt /media/veracrypt --pim=0 --keyfiles= --protect-hidden=no\"" >> .bashrc 
#+END_SRC



Para desmontar, utilizaremos el alias *veracrypt_d*.
#+BEGIN_SRC 
printf "\nalias veracrypt_d=\"veracrypt -d $HOME/veracrypt"" >> .bashrc 
#+END_SRC


** Conclusión 
El punto positivo de Veracrypt, es que al ser un único archivo no hay graves problemas de sincronización, el punto negativo, es que si el archivo es muy grande, no es muy aconsejable hacer sincronizaciones cifradas con nuestro movil, ya que podriamos consumir nuestra tarifa de datos.
** Fuentes
- https://www.veracrypt.fr/en/Downloads.html
- https://www.veracrypt.fr/en/Command%20Line%20Usage.html
- https://jacekstyrylski.github.io/2017/04/02/Vera-Crypt-OSMC/
* TODO Crear página de error 404 en GitHub Pages
:PROPERTIES: 
:TITLE:  Crear página de error 404 en GitHub Pages
:EXPORT_FILE_NAME: Crear pagina de error 404 en GitHub Pages
:DESCRIPTION: Después de cambiar la página de uGeek de Jekyll a Org-Bash-Blog, muchos de los artículos antiguos han cambiado ruta de la dirección web en el servidor y si llegas a ellas, quedas en una página de error de GitHub que no tiene relación con la web. Decidí crear una página personalizada de error 404
:EXPORT_DATE: 2019-03-29 22:30
:CATEGORY: web
:TAG:      git,github
:IMAGE:  ./images-blog/404.png
:END:
#+HTML: <center>
[[./images-blog/404.png]]
#+HTML: </center>

Después de cambiar la página de uGeek de Jekyll a Org-Bash-Blog, muchos de los artículos antiguos han cambiado la ruta de dirección web en el servidor y si llegas a ellas, quedas en una página de error de GitHub que no tiene relación con la web. Decidí crear una página personalizada de error 404 y que tras 3 segundos,tal como expliqué [[https://ugeek.github.io/blog/post/2018-12-29-redirigir-el-trafico-de-pagina-web-a-otra.html][en este Post]], redireccionará con el Index del blog. Pero... 

¿Como se hace una página de error 404 en GitHub Pages?

Súper Fácil!!!!

Tan simple como crear una página *.html* en la raiz del repositorio y nombrarla como *404.html*. Cada vez que alguien acceda a una página que esa no exista, GitHub Pages redirigirá el tráfico hacia esta página *404.html*.

 
* TODO Notificaciones Org Mode en Telegram con mi Bot 
:PROPERTIES:
:TITLE: Notificaciones Org Mode en Telegram con mi Bot
:EXPORT_FILE_NAME: Notificaciones Org Mode en Telegram con mi Bot
:DESCRIPTION: En artículos anteriores, así como en el Podcast, os he explicado como enviar notificaciones de texto, imágenes y archivos, a través de un Bot en Telegram que podemos crear
:EXPORT_DATE: 2019-03-31 10:30
:CATEGORY: emacs
:TAG: orgmode,telegram,raspberry
:IMAGE: ./images-blog/telegram2org.png
:END:
#+HTML: <center>
[[./images-blog/telegram2org.png]]
#+HTML: </center>


En artículos anteriores, así como en el Podcast, os he explicado [[https://ugeek.github.io/blog/post/2019-03-28-enviando-imagenes-audios-archivos-con-mi-bot-de-telegram-de-una-sola-linea-de-terminal.html][como enviar notificaciones de texto, imágenes y archivos]], a través de un Bot en Telegram que podemos crear.

Si utilizas orgmode, todo.txt o cualquier otro archivo de texto plano para gestionar tus tareas, imagino que el poder enviar mensajes de texto para recibirlos en tu movil o PC y tener un sistema basado en Unix como Linux, te habrá abierto un mundo de posibilidades.

En el artículo, de hoy voy a explicaros un ejemplo de como recibir todas las tareas pendientes que tengo en mi archivo orgmode, que están en estado TODO. Recordar que yo he utilizado este ejemplo, pero vosotros podéis hacer lo propio con los estados *WAIT*, *DONE*,... así como las prioridades *#A*, *#B*, etc... Simplemente tenéis que adaptar la línea de terminal a vuestra necesidad.

Voy a explicarlo y veréis que es súper sencillo.

** Filtrar los estados *TODO*

Para mostrar todas las líneas que tengan estado TODO, vamos a utilizar el comando *grep*. Yo en mi caso, una vez se visualice las líneas en Telegram, no quiero que aparezca ni el asterisco, ni la palabra *TODO*, así que utilizaré el comando *sed* para sustituir el texto: =* TODO=, por =-=
#+BEGIN_SRC 
grep TODO agenda.org | sed -e 's/* TODO/-/g'
#+END_SRC
Como es posible que no me fije en la fecha del chat, para comprobar a que día pertenece la notificación, voy a añadir la fecha del día de hoy en la notificación:
 
=date +'%A %d de %B del %Y' -> será del tipo: domingo 31 de marzo del 2019=

** Enviando la notificación
Ya lo tenemos todo. Así que vamos con la línea de terminal. Recordar que tenemos que añadir a esta línea el <TOKEN> y nuestro <ID>:

#+BEGIN_SRC 
curl -X "POST" "https://api.telegram.org/bot<TOKEN>/sendMessage" -d chat_id=<ID> -d text="$(echo -e "Tareas Pendientes: $(date +'%A %d de %B del %Y')\n" ; grep TODO agenda.org | sed -e 's/* TODO/-/g') "
#+END_SRC

Esta línea podemos programarla mediante *cron* a un día y hora determinada.

** Conclusión

Este es un pequeño ejemplo de todas las posibilidades que tenemos combinando la terminal, con servicios como Telegram que nos permite utilizar su api para recibir notificaciones. 

También demostrar que el utilizar orgmode, no solo no es una limitación, sino que nos permite personalizar y ampliar muchísimo mas las posibilidades de gestión de nuestras tareas y notas.

* TODO Tomb. Mis secretos son una Tumba. Crifrar Archivos 
:PROPERTIES:
:TITLE: Tomb. Mis secretos son una Tumba. Crifrar Archivos
:EXPORT_FILE_NAME: Tomb Mis secretos son una Tumba Crifrar Archivos
:DESCRIPTION: Hoy toca el turno de Tomb. Un script para cifrar archivos muy pero que muy interesante
:EXPORT_DATE: 2019-03-31 23:00 2019-11-01
:CATEGORY: cifrado
:TAG: raspberry,servidor,cifrado
:IMAGE: ./images-blog/tomb.png
:END:

Seguimos con la serie de aplicaciones para cifrar nuestros archivos. Hoy toca el turno de Tomb. Un script para cifrar archivos muy pero que muy interesante.
#+HTML: <center>

[[./images-blog/tomb.png]]
#+HTML: </center>

Tomb es aplicación basada en un script de software libre que nos permite crear un archivo cifrado en forma de contenedor, que llamaremos tomb "tumba" y que posteriormente podremos montar como si fuera un USB o HDD. Es una aplicación muy parecida a [[https://ugeek.github.io/blog/post/2019-03-29-veracrypt-en-ubuntu-y-tu-raspberry-por-terminal.html][Veracrypt, que hablé en el Post anterior]]. Su código está disponible en [[https://github.com/dyne/Tomb][este repositorio de GitHub]], así que si tenemos conocimientos, podemos ver como está hecho y eso da una muy buena confiabilidad.

Después de crear la tumba (contenedor), crearemos la llave para abrir esta. Deberemos guardar muy bien esta llave, ya que si la perdemos, perderemos nuestros archivos para siempre. En la parte final del Post, explico como convertir la llave en una imagen, por ejemplo, para despistar a posibles intrusos. 

*Recordar que no es nada aconsejable dejar la llave junto a la tumba.*

** Instalación en Ubuntu 18.04
En Ubuntu lo tenemos muy facil, tan simple como instalar desde los repositorios:

=sudo apt install tomb=

** Instalando la última versión desde GitHub

Comenzamos instalando:

#+BEGIN_SRC 
sudo apt-get install gettext zsh cryptsetup pinentry-curses
#+END_SRC

Descargamos la última versión desde [[https://files.dyne.org/tomb/][aquí]]:

#+BEGIN_SRC 
wget https://github.com/dyne/Tomb/archive/v2.7.tar.gz 
#+END_SRC

Descomprimimos:

#+BEGIN_SRC 
tar xzvf v2.7.tar.gz
#+END_SRC

Accedemos a la carpeta y compilamos:

#+BEGIN_SRC 
cd Tomb-2.7/
sudo make install
#+END_SRC

Después instalamos:

#+BEGIN_SRC 
sudo install -Dm755 tomb /usr/local/bin/tomb
sudo install -Dm644 doc/tomb.1 /usr/local/share/man/man1/tomb.1
#+END_SRC

Ya está instalado!!! Parecía mas complicado...

** Creando la Tumba
Vamos a crear nuestra primera tumba, dentro de esta, añadiremos los archivos que queremos que queden cifrados. Si nuestra máquina tiene activa la swap, deberemos utilizar el tag *-f* al final del comando, para que no deje rastro alguno de los archivos que contiene nuestra tumba.

Creamos la Tumba con 100Mb de Tamaño:

=tomb dig -s 100 documentos.tomb -f= 


Ahora crearemos la llave e introduciremos la contraseña. Paciencia porque este proceso, puede tardar en función del tamaño, unos minutos. También nos pedirá la contraseña del usuario con permisos sudo.

=tomb forge -k documentos.tomb.key -f=  


Ya se habrá creado tanto la tumba como la llave. La llave llevará el nombre de la tumba, pero si queremos podemos renombrarla.

Cerraremos el contenedor con la llave creada.

=tomb lock -k documentos.tomb.key documentos.tomb=

** Abrir la tumba
Para abrir la tumba y comenzar a guardar archivos dentro de ella, necesitaremos la llave. Yo estoy utilizando el mismo directorio, pero si está en otro, especificar la ruta completa de donde esté:

=tomb open -k documentos.tomb.key documentos.tomb -f=

Normalmente, el volumen se montará en =/media/documentos/=.

** Cerrar tumba
Para cerrar la tumba, súper sencillo. Utilizaremos *close*:

=tomb close=

Cerrar todas las tumbas y aplicaciones que se están haciendo uso de los archivos que están en las tumbas:

=tomb slam all=

** Ocultando tu llave en una foto 

Primero tenemos que instalar steghide

=sudo apt install steghide=

Eligimos una imagen para guardar dentro la llave, en mi caso se llamará *imagen.jpg*. Nos pedirá una contraseña

=tomb bury -k documentos.tomb.key imagen.jpg=

Ya podemos eliminar nuestra llave, porque esta, está en el interior de la imagen oculta.

Para poder volver a extraer la llave de la imagen:

=tomb exhume -k nombredellave imagen.jpg= 


Para abrir nuestra tumba con la imágen:

=tomb open -k imagen.jpg documentos.tomb=

** Listar tumbas abiertas
Vamos a listar todas las tumbas abiertas e información sobre el tamaño, espacio libre,...

=tomb list=

** Ampliar mas tamaño
Una de las cosas que más me ha gustado, es que una vez creada la tumba, no estamos limitados para siempre a ese tamaño, sino que podemos modificarlo pero solo para ampliarlo. Voy a ampliar de 100Mb iniciales a 350Mb:

=tomb resize -s 310 -k imagen.jpg documentos.tomb -f=

En el momento de la ampliación, nos pedirá la llave y contraseña.

** Mas Ayuda

Sintaxis:

 =tomb [opciones]  [argumentos]=

Podemos ver todas las opciones con el comando de ayuda o accediendo al manual:

=tomb -h=


=man tomb=

** Conclusión 
Voy a darle la oportunidad a este método de cifrar los archivos durante un tiempo, porque me parece muy sencillo, ligero y sobretodo confiable, ya que el código del script está hecho de un modo lo mas legible posible y utilizando herramientas de software libre muy bien auditadas.

Disponemos también de varias versiones con interfaz gráfica para escritorio, como por ejemplo *gtomb*. No puedo hablar de ella porque no la he probado, pero para aquellos que no les guste la terminal, es una buena solución. Recordaros que igual que en el [[https://ugeek.github.io/blog/post/2019-03-29-veracrypt-en-ubuntu-y-tu-raspberry-por-terminal.html][Post anterior de Veracrypt]], recomiendo el utilizar *alias* para abrir y cerrar las tumbas, solo por no tener que recordar los comando.


** Fuentes
- [[http://www.dyne.org/software/tomb/][Web de Tomb]]
- [[https://github.com/dyne/Tomb/wiki][Wiki de Tomb]]
* TODO Calculando con mi terminal
:PROPERTIES:
:TITLE: Calculando con mi terminal
:EXPORT_FILE_NAME: Calculando con mi terminal
:DESCRIPTION: Cuando comienzas a crear tus propios scripts, a veces te ves en la necesidad de hacer cálculos. Hoy os voy a explicar un par de comandos que podemos utilizar para hacer nuestros cálculos
:EXPORT_DATE: 2019-04-01 20:40
:CATEGORY: terminal
:TAG: bash,unix
:IMAGE:  ./images-blog/expr.jpg
:END:

Cuando comienzas a crear tus propios scripts, a veces te ves en la necesidad de hacer cálculos. Hoy os voy a explicar un par de comandos que podemos utilizar para hacer nuestros cálculos, *expr* (evalúa los argumentos como una expresión) y *calc* (Calculadora de precisión arbitraria).
#+HTML: <center>
[[./images-blog/expr.jpg]]
#+HTML: </center>

*Expr* viene preinstalado en Ubuntu por defecto, cosa que no sucede con *calc*. Y os preguntareis: ¿Porque utilizar dos comandos? *expr* no utiliza decimales y para determinados casos nos puede ir bien, pero si queremos utilizar decimales, tendremos que echar mano de *calc*.


Otro método de hacer cálculos sería con *bc*, pero lo dejo para otro Post porque *expr* y *calc* diría que es la versión de comandos para hacer cálculos seres humanos, escribiremos en la terminal igual que haríamos en una calculadora.


Con *expr* vamos a ejecutar operaciones aritméticas o de comparación. Vamos a ver como funciona:

=expr <número> <operador matemático> <número>=

** Suma
Hay que dejar un espacio en blanco entre los números y símbolo de *+*.

=expr 8 + 4=

Suma con números negativos:

=expr -30 + 47=

**  Resta

=expr 8 - 4=

** Multiplicación
Lleva la contrabarra *\* para escapar del asterísco. Es la única excepción respecto como lo haríamos con la calculadora:

=expr 8 \* 4=

** División

=expr 8 / 4=

** Porcentaje

=expr 10 % 100=

** Comparaciones
Otra cosa que nos permite *expr* es ejecutar comparaciones. Si la comparación es verdadera, nos devolverá *1*, si es falsa *0*.
Aquí también hay símbolos que llevan la contrabarra *\* para escapar.
#+BEGIN_SRC 
expr 10 =   7   # Igual
expr 10 !=  7   # No es igual
expr 10 \>  7   # Mayor que
expr 10 \<  7   # Menor que
expr 10 \<= 7   # Menor o igual
expr 10 \>= 7   # Mayor o igual
#+END_SRC

** Contando el número de letras
También podemos contar el número de letras que hay en una frase:

=expr length "hola mundo"=

O en un archivo de texto plano:

=expr length "$(cat mis_notas.txt)"=

** Manual
Hay muchas mas opciones. Lee en manual para conocerlas:

=man expr=

** Instalación de Calc
Calc no viene instalado por defecto en Ubuntu. Lo instalaremos así:

=sudo apt install apcalc=
** Suma
Suma con decimales:
#+BEGIN_SRC 
calc 12.5 + 21.4
	33.9
#+END_SRC
Aquí ya podemos sumar números negativos. Al poner el signo negativo, tiene que ir entre paréntesis.
#+BEGIN_SRC 
calc '(-30 + 47)'
	17
#+END_SRC
** Dos números negativos
#+BEGIN_SRC 
calc '(-30 - 47)'
	-77
#+END_SRC

** Multiplicación
En el caso de la multiplicación, *calc* no necesita *\* de escape:
#+BEGIN_SRC 
calc 30*2
	60
#+END_SRC
#+BEGIN_SRC 
calc '(-2 * 10)'
	-20
#+END_SRC
#+BEGIN_SRC 
calc 30\*2
	60
#+END_SRC

** División
#+BEGIN_SRC 
calc 200/10
	20
#+END_SRC

** Porcentaje
#+BEGIN_SRC 
calc 10%100
	10
#+END_SRC

** Manual 
Hay muchas mas en manual:

=man calc=

** Conclusión
Esto es tan solo unos ejemplos de estos comandos, pero podemos utilizarlo para contar letras entre líneas de archivos,... y muchas más cosas
Ahora ya solo queda llenar tus variables de números y comenzar ha hacer montones de cálculos.
* TODO Exportando bonito a html mi OrgMode y creando web estática
:PROPERTIES:
:TITLE: Exportando bonito a html mi OrgMode y creando web estática
:EXPORT_FILE_NAME: Exportando bonito a html mi OrgMode y creando web estatica
:DESCRIPTION: Hoy os traigo un paquete que exporta tus archivos orgmode a formato html de un modo más bonito y con más calidad 
:EXPORT_DATE: 2019-04-02 19:00
:CATEGORY: emacs
:TAG: html,github,gitlab
:IMAGE:  ./images-blog/ox-twbs.png
:END:

Emacs es espectacular, pero los usuarios que lo utilizan y crean paquetes, están al mismo nivel. Hoy os traigo un paquete que está disponible en los repositorios de [[https://melpa.org/][Melpa]] desarrollado por Brandon van Beekum, que exporta tus archivos orgmode a formato html de un modo más bonito y con más calidad. 

Por defecto emacs, exporta a html pero de un modo plano, osea código html puro y duro, necesitamos una plantilla css para que tenga formato y se vea mas bonito. Este paquete es como si llevara una plantilla css y javascript adjunta, creando la tabla de contenido del documento en la parte superior derecha, si utilizamos la versión de escritorio y en la parte inferior, si utilizamos un móvil. Esta tabla de contenido se va expandiendo conforme navegamos por nuestro orgmode en versión web.

[[./images-blog/ox-twbs.png]]


En la configuración, adjunto un ejemplo de como tener tus archivos orgmode en una carpeta y exportar los html a otra. Esto es interesante porque podríamos apuntar a esa carpeta como raíz de un servidor web, por ejemplo siguiendo el post del [[https://ugeek.github.io/blog/post/2019-03-25-monta-un-servidor-web-nginx-con-una-sola-linea-de-terminal-docker.html][Docker de Nginx]], haciendo accesible estas notas en formato web en nuestra red Local o via Internet.

Otra posibilidad sería publicarlo en las GitHub o GitLab Pages.

** Instalación
=M-x package-install [RET] ox-twbs [RET]=

Para exportar el archivo que estamos editando de orgmode a html con este paquete, ejecutaremos el siguiente comando en emacs:

=M-x org-twbs-export-to-html=

El archivo html resultante, estará en la misma carpeta donde está el archivo orgmode.
** Configuración 
Vamos a ver como exportar los html a otra carpeta que no sea la misma donde está el archivo orgmode. Copiaremos en nuestro archivo de configuración de emacs *init.el* o *.emacs*:

#+BEGIN_SRC 
(setq org-publish-project-alist
      '(("org-notes"
         :base-directory "~/org/"
         :publishing-directory "~/public_html/"
         :publishing-function org-twbs-publish-to-html
         :with-sub-superscript nil
         )))
#+END_SRC


En este archivo de configuración, utilizaremos las carpetas *~/org/* y *~/public_html/*. Los archivos orgmode los guardaremos en la carpeta  *~/org/* y cuando ejecutemos el comando dentro de emacs: =M-x org-publish-all= , será exportado en formato .html a la carpeta *~/public_html/*.

Previamente, crearemos las carpetas desde nuestra terminal:

=mkdir -p carpeta ~/org ~/public_html=

Podemos personalizar la carpeta que deseemos, modificando la ruta de las carpetas en el archivo de configuración.

** Sin tabla de contenido o índice, autor...
Si no queremos que aparezca tabla de contenido o índice, ni a pie de página el autor, fecha...  añadiremos al inicio de nuestro OrgMode:

[[./images-blog/ox-twbs2.png]]

#+BEGIN_SRC 
#+OPTIONS: html-postamble:nil toc:nil
#+END_SRC
** Cajetilla de código de color
Si queremos que salga la cajetilla de código de color negro, en el archivo orgmode añadiremos la siguiente línea. Como todo, es personalizable cambiando el color al que tu desees.
#+BEGIN_SRC 
#+HTML_HEAD_EXTRA: <style>pre { font-size: 13px; background-color: #000; color: #bbb; }</style>
#+END_SRC
** Conclusión
En el repositorio de GitHub de [[https://github.com/marsmining/ox-twbs][ox-twbs]] encontraras más información de este paquete. Encuentro que es un modo muy sencillo de tomar tus notas y acceder a ellas para consultar.

** Fuentes
- Fuente del paquete: https://github.com/marsmining/ox-twbs
- http://clubctrl.com/org/prog/howto.html
- http://clubctrl.com/org/prog/source.html
* TODO Montando carpetas del servidor, Raspberry,... en tu escritorio. SSHFS
:PROPERTIES:
:TITLE:  Montando carpetas del servidor, Raspberry,... en tu escritorio. SSHFS
:EXPORT_FILE_NAME: Montando carpetas del servidor Raspberry en tu escritorio
:DESCRIPTION: SSHFS nos va a permitir montar una carpeta de un servidor, PC o Raspberry, en nuestro PC o portatíl y acceder a esta carpeta como si fuera una carpeta de nuestra PC o portátil 
:EXPORT_DATE: 2019-04-04 18:40
:CATEGORY: ssh
:TAG: servidor
:IMAGE: ./images-blog/sshfs.png
:END:
Hay momentos que estás conectado remotamente vía SSH a tu servidor, Raspberry... y aunque cada vez conoces mejor la terminal y te mueves con total soltura por los directorios 😜,  te gustaría acceder a esas carpetas de un modo gráfico para hacer un copia-pega, arrastrar un archivo,...  tener tu carpeta remota montada en local, como si fuera una carpeta de tu propio PC o Portátil.
#+HTML: <center>
[[./images-blog/sshfs.png]]
#+HTML: </center>

Esto nos lo va a permitir SSHFS, teniendo en la máquina remota un servidor SSH montado.

SSHFS nos va a permitir montar una carpeta de un servidor, PC o Raspberry, en nuestro PC o portatíl y acceder a esta carpeta como si fuera una carpeta de nuestra PC o portátil. Para ello tenemos que seguir los siguientes pásos:
- Instalaremos sshfs
- Crear una *carpeta vacía*, donde montaremos la carpeta remota
- Mediante una línea de terminal montaremos y desmontaremos la carpeta cuando lo deseemos
** Instalación en la máquina local
SSHFS, lo encontraremos en los repositorios de cualquier distro. En Ubuntu lo instalaremos así:

=sudo apt install sshfs=

** Creando la carpeta de montaje
En nuestro PC o portátil, crearemos una carpeta para el montaje, por ejemplo: ~/carpeta_montaje

=mkdir -p ~/carpeta_montaje=

** Montar carpeta
Vamos a montar la *carpeta del servidor* que deseemos montar el local, en mi caso la carpeta llamada *carpeta_del_servidor*, en la carpeta de mi portátil que he creado llamada *carpeta_montaje*. 

Sustituye *usuario@192.168.1.100*, por el usuario e IP del servidor que te vas a conectar.

Ahora vamos a conectarnos con:

=sshfs usuario@192.168.1.100:/carpeta_del_servidor ~/carpeta_montaje=

En caso de haber cambiado el puerto del servidor SSH, por ejemplo al 5555, nos conectaríamos así:

=sshfs -p 5555 usuario@192.168.1.100:/carpeta_del_servidor ~/carpeta_montaje=

** Desmontar
Para desmontar la carpeta, introduciremos en la terminal *fusermount -u* seguido de la carpeta de montaje:

=fusermount -u ~/carpeta_montaje=
** Conclusión
Esta es la base de algunos de los siguientes Post donde vamos a utilizar SSHFS. Hacia tiempo que no lo utilizaba, pero la verdad es que aunque a veces puede ir un poco lento, es muy cómodo para gestionar tus archivos de un modo gráfico desde tu escritorio.
* TODO Montando una carpeta con todos mis servidores dlna
:PROPERTIES:
:TITLE:  Montando una carpeta con todos mis servidores dlna
:EXPORT_FILE_NAME: Montando una carpeta con todos mis servidores dlna
:DESCRIPTION: Vamos a montar en una carpeta de nuestro PC, todos los servidores dlna que haya en nuestra red local y acceder a todo el contenido a través de nuestro explorador de archivos o terminal igual que lo haríamos con cualquier otra carpeta de nuestro PC 
:EXPORT_DATE: 2019-04-05 18:00
:CATEGORY: dlna
:TAG: servidor
:IMAGE: ./images-blog/dlna.png
:END:
#+HTML: <center>
[[./images-blog/dlna.png]]
#+HTML: </center>

Este es el cuarto Post de dlna, despues de:  [[https://ugeek.github.io/blog/post/2018-12-27-minidlna.html][monta tu servidor dlna]], [[https://ugeek.github.io/blog/post/2019-01-02-crear-listas-m3u-para-minidlna-o-vlc.html][Crear listas m3u para minidlna o vlc]] y [[https://ugeek.github.io/blog/post/2019-02-16-cliente-dlna-para-tu-escritorio.html][Cliente dlna para tu escritorio]]. En el último Post, donde os hablé de los clientes de escritorio, estoy seguro que llevaste decepción porque no podías utilizar con tu servidor *dlna* tu reproductor de música favorito. También la *no* posibilidad de poder descargar todas tus canciones o contenido multimedia, a través de tu servidor dlna para tenerlo en local. En el Post de hoy, vamos a solucionar todo esto montando en una carpeta de nuestro PC, *todos los servidores dlna* que haya en nuestra red local y acceder a todo el contenido a través de nuestro explorador de archivos o terminal, igual que lo haríamos con cualquier otra carpeta de nuestro PC.

Lo mejor de todo, es que es súper sencillo de instalar. Vamos a utilizar *djmount*

** Instalación de djmount
Podemos instalarlo desde los repositorios oficiales de cualquier distro con solo una línea de terminal:

=sudo apt install djmount=

Creamos la carpeta donde queramos montar todos los servidores *dlna* que hayan en nuestra red local. En mi caso voy a crear la carpeta *~/dlna*:

=mkdir ~/dlna=

** Montando y desmontando mi carpeta dlna
Para montar la carpeta donde estarán todos los servidores *dlna*, tan simple como:

=djmount ~/dlna=

Para desmontar:

=fusermount -u ~/dlna=
** Conclusión
Como ves, cada Post que voy publicando sobre *dlna*, te vas dando cuenta que montar el servidor multimedia *minidlna*, súper ligero y muy sencillo de configurar, no es ninguna tontería y vale muy mucho la pena. Es una forma de tener todo tu contenido multimedia centralizado y con aplicaciones como *djmount*, podemos acceder a todo el contenido, sin correr riesgo de borrar ningún archivo.
* TODO Atajos de Terminal 
:PROPERTIES:
:TITLE: Atajos de Terminal
:EXPORT_FILE_NAME: Atajos de Terminal
:DESCRIPTION: Aunque no lo parezca de salida y de muchísima pereza el aprenderse los atajos de teclado de la terminal, es algo verdaderamente muy útil
:EXPORT_DATE: 2019-04-06 0:40
:CATEGORY: terminal
:TAG: servidor
:IMAGE:  ./images-blog/atajos.jpg
:END:

Aunque no lo parezca de salida y de muchísima pereza el aprenderse los atajos de teclado de la terminal, es algo verdaderamente muy útil. 
#+HTML: <center>
[[./images-blog/atajos.jpg]]
#+HTML: </center>


El truco para aprenderlos es leer todo lo que podemos hacer con atajos y cuando lo necesites, lee aquí el atajo y ejecutalo. En muy poco espacio de tiempo, estoy seguro que lo tendrás integrado y totalmente aprendido. 

Aprenderse los atajos de teclado para no utilizar el ratón, es de las cosas mas productivas que puedes hacer y no solo por el tiempo perdido en utilizar el ratón, sino que también influye en la fluidez a la hora de desarrollar aquello con lo que estás trabajando. 

No hay nada que te pare!!!

Comentaros que parte de estos comandos, son también compatibles con Emacs. Así que aprendemos por partida doble.

Los he agrupado según mi uso. Quizás lo que para mi es importante, para ti no lo es, pero aquí los tienes: 

** Importantes
- *Ctrl+a*: lleva el cursor al inicio de la línea
- *Ctrl+e*: lleva el cursor al final de la línea
- *Ctrl+k*: borra desde el cursor hasta el final de la línea
- *Ctrl+u*: borra desde el cursor hasta el inicio de la línea

** Importantes en el uso
- *Ctrl+l*: limpia la terminal
- *Ctrl+c*: termina el proceso que se esté ejecutando
- *Ctrl+z*: deja en segundo plano el proceso, para volver al proceso, introduce *fg*
- *Ctrl+r*: búsqueda de comandos usados anteriormente, escribiendo el inicio del comando 
- *Tab*: autocompleta comandos, rutas, directorios, archivos...

** Menos importantes en el uso
- *Ctrl+p*: último comando introducido
- *Ctrl+d*: sale de la terminal
- *Alt+.*:  escribe los últimos comandos a continuación de donde estemos
- *Ctrl+g*: Anular lo que estemos haciendo
** Intercambiar posiciones 
- *Ctrl+t*: intercambia la posición de los dos caracteres anteriores al cursor
- *Alt+t*: intercambia la posición de las dos palabras anteriores al cursor

** Mover cursor
- *Alt+f*:  salta a la siguiente palabra
- *Alt+b*:  salta a la anterior palabra
- *Ctrl+xx*: salta entre la posición actual y el inicio de la línea y viceversa
** Mas atajos de borrar
- *Ctrl+w*: borra la palabra anterior al cursor
- *Alt+d*: borra la palabra siguiente al cursor

** Copiar y Pegar
- *Ctrl+Shift+v*: pegar el texto del portapapeles en la terminal
- *Ctrl+Shift+c*: seleccionando el texto de la terminal, copiamos al portapapeles


** Abrir terminal
- *Ctrl+Alt+t*: La mayor parte de las terminales
- *F12*: Si utilizas Guake

* TODO Controla tu Raspberry, Servidor o PC desde Telegram 
:PROPERTIES:
:TITLE:  Controla tu Raspberry, Servidor o PC desde Telegram
:EXPORT_FILE_NAME: Controla tu Raspberry Servidor o PC desde Telegram
:DESCRIPTION: Voy a explicarte como ejecutar un Bot de Telegram que te va a permitir el controlar la totalidad de tu Raspberry, Servidor o PC, remotamente desde Telegram
:EXPORT_DATE: 2019-04-11 17:45
:CATEGORY: telegram
:TAG: domotica
:IMAGE:     ./images-blog/tocar_movil.jpg
:END:

Voy a explicarte como configurar un Bot de Telegram, que te va a permitir el controlar la totalidad de tu Raspberry, Servidor o PC, remotamente.
#+HTML: <center>
[[./images-blog/tocar_movil.jpg]]
#+HTML: </center>


Con este Bot no solo podrás conocer la temperatura, IP pública, ... Tal como te expliqué en el Post [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]], sino que también podrás interactuar con él, iniciando o deteniendo servicios, mediante el GPIO podrás conectar luces, motores de persianas, puertas... ejecutar comandos que ejecutarías en la terminal, actualizar tu servidor... En definitiva, para todo aquello que dé tu imaginación. 

Lo mejor de todo, es que nos conectaremos a través de la API de Telegram, de modo que no necesitaremos utilizar ningún servicio tipo VPN. Nuestro Bot de Telegram, puede convertirse en un mando a distancia, teniendo el control total de todo lo que suceda en tu casa y lo mejor de todo, sin tener conocimientos de programación. Vamos a utilizar nuevamente Bash, como lenguaje de programación y añadiendo cuatro parámetros, vas a comenzar a controlarlo todo.  

He hecho un Fork de BaTBot en su última versión modificada por eliafino y lo he traducido al Castellano para el fácil comprensión.
BaTBot en la versión 1.4.3.4 lo encontrarás en mi [[https://github.com/uGeek/BaTbot][Repositorio en GitHub]].

** Instalación
Lo primero que vamos ha hacer es descargar BaTbot y clonar el repositorio, por ejemplo, en la carpeta de usuario de nuestra distro:
#+begin_src 
cd                                             # Esto nos llevará a la carpeta de usuario
git clone https://github.com/uGeek/BaTbot.git  # Clonamos el repositorio
cd ~/BaTbot/bin/                               # Accedemos a la carpeta ~/BaTbot/bin
#+end_src
Dentro de la carpeta *bin*, encontraremos el script del bot llamado *batbot*.

** Configurando BaTbot

Vamos a editar el archivo *batbot* y añadir las variables necesarias:

#+BEGIN_SRC 
nano ~/BaTbot/bin/batbot
#+END_SRC

La configuración va a ser muy simple. Necesitamos añadir las siguientes variables en el script:
- TELEGRAMTOKEN= <TOKEN>
- PERSONALID= <ID DEL USUARIO MAESTRO O MÁXIMO ADMINISTRADOR>
- BATBOTUSR= < RUTA DE LA CARPETA .batbot >

El TOKEN si recordáis, lo obteníamos a través de  [[https://t.me/BotFather][@BotFather]] y el ID, mediante el Bot [[https://t.me/ChannelIdBot][@ChannelIdBot]].

Si no recuerdas bien los pasos, te invito a leer el Post  [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][Crea un Bot de Telegram con Bash y una sola línea de Terminal]], donde explico los pasos con mas detalle.

La ruta de la carpeta *.batbot*, hay que ponerla completa. Dentro de esta carpeta está la lista de usuarios que tendrán permisos para utilizar nuestro Bot.

Aquí tienes un ejemplo, con parámetros inventados, como quedaría:
#+begin_src 
# Ingrese el token BOT devuelto por BotFather                                                                                               
TELEGRAMTOKEN="780756347993:AAEhwrthws_Y9SOdPMl2NI2jM0oyQX0DMg"

# Ingrese el ID del usuario maestro, para notificaciones de uso                                                                               
PERSONALID="68690969"

# Ruta donde está nuestra carpeta .batbot en nuestro servidor, Raspberry,...                                       
BATBOTUSR="$HOME/BaTbot/.batbot"
#+end_src
Por defecto, BaTbot revisará cada 5 segundos si hay un nuevo mensaje. Esta opción la podemos personalizar poniendo el tiempo en segundos que deseemos:
#+begin_src 
# revisar nuevos mensajes cada X segundos:                                                                                                  
CHECKNEWMSG=5
#+end_src
** Añadiendo Nuestro ID al listado usuarios habilitados al uso del Bot
Ahora vamos a añadir nuestro ID de usuario, al listado de usuarios que tienen permisos para utilizar el Bot. Para ello, accederemos al archivo *allowed_users* :
#+begin_src 
nano ~/BaTbot/.batbot/allowed_users
#+end_src
Borraremos los números de ID que vienen de ejemplo y añadiremos nuestro ID o todos aquellos ID que tendrán permiso para poder utilizar el Bot.

Recuerda que si no ponemos nuestro ID en esta lista, no podremos interactuar con nuestro Bot.
** Ejecutar el Bot
Ahora volveremos a la carpeta *bin* y ejecutaremos *./batbot*
#+begin_src 
cd ~/BaTbot/bin/
./batbot
#+end_src
Ya puedes enviar mensajes al Bot. Escribe el comando */menu*, para que te muestre el menú.

En la terminal podremos ver todos los mensajes que recibe el Bot en tiempo real y que usuarios lo envían.

** Configurar un menú y añadir comandos
Esta parte del script, es donde podremos añadir comandos para que los ejecute nuestro Bot. 

Aquí hay algunos de ejemplo, pero si no los vas a utilizar, elimínalos de la lista. Deja solo aquellos comandos que utilizaras. 

Para recordar los comandos, crea el comando llamado por ejemplo */menu* y añade todos los comandos disponibles.

El Bot solo reconocerá como comando las palabras que empiezan por */*.

#+begin_src 
declare -A botcommands=(
        ["/start"]='exec userlist @USERID:@FIRSTNAME@LASTNAME'
        ["/myid"]='echo Tu ID es: @USERID'
        ["/myuser"]='echo Tu nombre de usuario es: @USERNAME'
        ["/ping ([a-zA-Z0-9]+)"]='echo Pong: @R1'
        ["/uptime"]="uptime"
        ["/add ([0-9]+)"]='exec admadduser @USERID @R1'
        ["/del ([0-9]+)"]='exec admdeluser @USERID @R1'
        ["/lista"]='exec admlistuser @USERID'
        ["/run (.*)"]="exec @R1"
        ["/docker_nginx_start"]="docker stop nginx"
        ["/docker_nginx_stop"]="docker start nginx"
        ["/menu"]="echo -e Bienvenido a Mi Bot\n/myid \n/myuser \n/uptime \n/run \n/ping \n\nDockers:\n/docker_nginx_start \n/docker_nginx_stop \n\n\n/menu")
#+end_src

En el chat del Bot, si ejecutamos el comando */menu*, nos contestará:

#+begin_src 
Bienvenido a Mi Bot
/myid 
/myuser 
/uptime 
/run 
/ping 

Dockers:
/docker_nginx_start 
/docker_nginx_stop 


/menu
#+end_src

Si envías el comando */run*, sería lo mismo que si estuvieras escribiendo en tu terminal

** Comandos simples 
Podemos ejecutar comandos simples como por ejemplo:

- Ejecutas */hello* y responde *Hola*
#+begin_src 
["/hello"]="echo Hola"    
#+end_src
- ¿Quieres saber el tiempo de actividad de tu servidor? No hay problema:
#+begin_src 
["/uptime"]="/usr/bin/uptime"
#+end_src
- ¿Queres conocer el espacio en disco libre a través de Telegram?
#+begin_src 
["/disks"]="/bin/df -h"
#+end_src

- Ejecutar script un externo:
#+begin_src 
["/auth ([a-zA-Z0-9]+)"]="/usr/local/bin/auth.sh @R1"
#+end_src
** Variables:

Puedes usar variables! por ejemplo:
#+begin_src 
["/hello"]="echo Hola @FIRSTNAME, encantado de conocerte :)"
#+end_src

** Lista de Varibales
- @USERID 	  (int) ID del usuario que envió el comando activado
- @USERNAME 	(string) Nombre de usuario de usuario en Telegram
- @FIRSTNAME	(string) El primer nombre del usuario
- @LASTNAME	  (string) El apellido del usuario
- @CHATID 	  (int)  El ID de chat donde el usuario envió un comando
- @MSGID 		  (int) ID del mensaje que activó un comando
- @TEXT		    (string) El texto completo de un mensaje recibido
- @FROMID		  (int) ID del usuario que envió un mensaje

Regex group extract
- @R1 		Contenido del primer grupo (.*)
- @R2 		Contenido del segundo grupo (.*)
- @R3 		Contenido del tercero grupo (.*)

** Comando con expresiones regulares
También puedes configurar un comando con argumentos, por ejemplo: "/ping 1234". Todos los argumentos pueden ser expresiones regulares, por ejemplo:
#+begin_src 
["/ping ([0-9]+)"]="echo Pong: @R1"

["/blacklist ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)"]="/sbin/iptables -A INPUT -s @R1 -j DROP"

["/whois ([a-zA-Z0-9\.\-]+)"]="/usr/bin/whois @R1"

["/host ([a-zA-Z0-9\.\-]+)"]="/usr/bin/host @R1"
#+end_src

** Enviar mensaje
Cuando BaTbot se está ejecutando, puedes enviar un mensaje utilizando el ID del usuario, usando el comando *.msg* directamente en la consola. 
#+begin_src 
.msg <ID> <MENSAJE>
#+end_src
Por ejemplo:
#+begin_src 
[chat 110440209, from  110440209] <theMiddle - Andrea Menin> hi bot :)
.msg 110440209 No utilices más mi Bot!!!
#+end_src

** Conclusiones
Hay muchas mas opciones que podemos configurar desde el propio Bot, como añadir usuarios al listado desde el propio chat del Bot, etc... La verdad es que no he tenido suficiente tiempo de hacer todas las pruebas. El Objetivo de Gestionar nuestro servidor remotamente, cumple perfectamente. 

Si quieres hacer pruebas, la carpeta que hay en el repositorio *.batbot*, donde esta el archivo *allowed_users*, tendría que estar en al carpeta =$HOME/.batbot=. Yo en el Post lo he dejado en la misma carpeta igual que el repositorio, para tener todos las carpetas en el mismo lugar.
 
 



 
 
 
 
 
 
* TODO Crear archivos .gitkeep de forma recursiva mediante un script                   
:PROPERTIES:                                                                   
:TITLE: Crear archivos .gitkeep de forma recursiva mediante un script                
:EXPORT_FILE_NAME: Crear archivos gitkeep de forma recursiva mediante un script
:DESCRIPTION: Los archivos *.gitkeep*, son archivos vacíos que es probable hayas visto en algún proyecto de git y se crean para que en caso que este proyecto tenga carpetas vacías, sean gestionadas por git.
:EXPORT_DATE: 2019-04-17 08:00
:CATEGORY: git
:TAG:    github, gitlab
:IMAGE:  ./images-blog/git.png
:END:                      


Es muy probable que si has llegado has aquí, sea porque no sabes que es un archivo *.gitkeep*, o has comenzado tu proyecto en git, lleno de carpetas vacías y ahora no sabes como subirlas a git. 

#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>

Los archivos *.gitkeep*, son archivos vacíos que es probable hayas visto en algún proyecto de git y se crean para que en caso que este proyecto tenga carpetas vacías, sean gestionadas por git.

Git no es capaz de gestionar carpetas vacías, así que una solución es crear un archivo vacío dentro de estas, sin contenido para que no ocupe espacio. 

Aunque no consta en la documentación de git, muchos desarrolladores han adoptado este nombre como norma.

Pero...  ¿Si has comenzado tu proyecto y no has creado ningún archivo dentro?, ¿Como recordar todas las carpetas vacías?. 

No te preocupes. 

Con esta línea de terminal, *situándonos en la raíz de nuestro repositorio* y gracias al comando *find*, todas aquellas carpetas que estén vacías, incluirá un archivo llamado .gitkeep

#+begin_src 
find . -type d -empty -not -path "./.git/*" -exec touch {}/.gitkeep \;
#+end_src
* TODO Cambiando estados de forma masiva en mis Org Mode
:PROPERTIES:
:TITLE: Cambiando estados de forma masiva en mis Org Mode
:EXPORT_FILE_NAME: Cambiando estados de forma masiva en mis Org-Mode
:DESCRIPTION: Si tu blog comienza a ser muy grande y tienes centenares de tareas en tu Org Mode en estado *TODO*, es muy probable que quieras desmarcar este estado
:EXPORT_DATE: 2019-04-17 09:33
:CATEGORY: emacs
:TAG: orgmode,bash,sed
:IMAGE: [[./images-blog/todo.jpg]]
:END:

#+HTML: <center>
[[./images-blog/todo.jpg]]
#+HTML: </center>


En breve publicaré un Post con la nueva actualización de [[https://github.com/ugeek/org-bash-blog][Org-Bash-Blog]] y [[https://github.com/ugeek/org-bash-podcast][Org-Bash-Podcast]]. Si tu blog comienza a ser muy grande y tienes centenares de tareas en tu Org Mode en estado *TODO*, es muy probable que quieras desmarcar este estado para publicar solo aquello que quieres publicar. O simplemente, quieras desmarcar casi la totalidad de estados *TODO*.

Solo de pensar que tengo que desmarcar de forma manual, uno por uno todos los estados, ¡¡¡Me da algo!!!, jajaja. 

Tiene que haber una modo más simple de hacerlo. 

Aquí entra en juego nuestro amigo *sed*.

** Desmarcando estados *TODO*

=sed -i 's/^* TODO/*/g' archivo.org=

** Marcando todas las Cabeceras de primer nivel, a estado *TODO*

=sed -i 's/^* /* TODO /g' archivo.org=

** Marcando Cabeceras de tercer nivel a estado *DONE*
Para cambiar un poco el ejemplo, ahora vamos a cambiar las cabeceras de tercer nivel a estado *DONE*.

=sed -i 's/^*\*\* /*\*\* DONE  /g' archivo.org=

Aunque a primera vista veamos muchas barras, es muy sencillo de entender. Estamos poniendo *\* entre los asterisco, para que el comando sed, no nos de como inválida expresión regular. 

** Conclusión
Estos son tan solo unos ejemplos del poder que nos proporciona un comando como *sed*. Si entendemos bien el uso de este comando, a la larga, puede hacernos ganar mucho tiempo y deshacernos de tareas repetitivas y tediosas.

 
 
 
 
* TODO Estando a la Última en tu Raspberry con Debian Testing
:PROPERTIES:
:TITLE: Estando a la Última en tu Raspberry con Debian Testing
:EXPORT_FILE_NAME: Estando a la ultima en tu Raspberry con Debian Testing
:DESCRIPTION: muestro un pequeño ejemplo de como montar un Docker con Debian Testing, una versión de Debian donde encontraremos paquetes más actualizados que la versión actual de Raspbian, que es una versión muchisímo más estable
:EXPORT_DATE: 2019-04-21 13:22
:CATEGORY: docker
:TAG: docker,debian
:IMAGE: ./images-blog/debian.jpg
:END:

#+HTML: <center>
[[./images-blog/debian.jpg]]
#+HTML: </center>

  
Ya os hablé de como instalar aplicaciones o servicios a la última en vuestra Raspberry, servidor... utilizando Docker.
  
Hoy os muestro un pequeño ejemplo de como montar un Docker con Debian Testing, una versión de Debian donde encontraremos paquetes más actualizados que la versión actual de Raspbian, que es una versión muchisímo más estable.
  
También puede servirnos para hacer pruebas, tal como expliqué en el Podcast, sin peligro a romper nada de nuestra Raspberry.

#+BEGIN_SRC 
docker run -it --name debian_testing \
               --restart=unless-stopped \
               --network host  \
               -e LANGUAGE=en_ES.UTF-8 \
               -e TZ=Europe/Madrid \
               -v $HOME/:/root debian:testing-slim  \
               bash
#+END_SRC

Significado de los tags:
- El nombre del contenedor, será =debian_testing=
- Cada vez que reiniciemos el servidor, se iniciará nuestro Docker
- Todos los puertos del Docker estarán expuestos
- El idioma por defecto, es Castellano de España
- La zona horaria, la de Madrid
- *Lo mas interesante*, el volumen, el directorio *root/* del contenedor, está compartido con nuestra carpeta *Home de usuario*

* TODO youtube2org. Añadir la Imagen de un Vídeo de YouTube, en un OrgMode o Markdown
:PROPERTIES:
:TITLE: youtube2org. Añadir la Imagen de un Vídeo de YouTube, en un OrgMode o Markdown
:EXPORT_FILE_NAME: youtube2org Añadir la Imagen de un Vídeo de YouTube en un OrgMode o Markdown
:DESCRIPTION: Estaba escribiendo en un repositorio de GitHub en el archivo README.org, el resumen de un vídeo de un curso en Python buenísimo que he visto en YouTube. La intención era el poner la imagen del vídeo y debajo escribir un poco el resumen de este, para cuando quisiera acceder a un determinado tema, asociarlo al vídeo y clicar sobre esta imagen para que me lleve a YouTube
:EXPORT_DATE: 2019-05-01 18:55
:CATEGORY: emacs
:TAG: orgmode,github,gitlab,markdown
:IMAGE: ./images-blog/bash.jpg
:END:

#+HTML: <center>
[[https://www.youtube.com/watch?v=NxYITudzHlc][http://img.youtube.com/vi/NxYITudzHlc/0.jpg]]
#+HTML: </center>

Estaba escribiendo en un repositorio de GitHub en el archivo README.org, el resumen de un vídeo de un curso en Python buenísimo que he visto en YouTube. La intención era el poner la imagen del vídeo y debajo escribir un poco el resumen de este, para cuando quisiera acceder a un determinado tema, asociarlo al vídeo y clicar sobre esta imagen para que me lleve a YouTube.

La verdad es que no he encontrado ninguna herramienta que pudiera hacer esto, así que he decidido hacerla yo para simplificarme las cosas.

Vamos a utilizar bash para hacer este script y con tan solo dos líneas, lo tendremos resuelto. 

Una vez hecho, he decidido el hacer que también pudiera generar la imagen + url para markdown. Os explico un poco como funciona.

El script es totalmente compatible con Linux y Mac. 

** Instalación
A mi personalmente, me gusta instalarlo en el propio sistema operativo, así cuando lo necesite, este donde este en mi disco duro, con tan solo escribir youtube2org podré extraer la imagen.

Copiamos el script del repositorio de GitHub a nuestro PC:
#+BEGIN_SRC bash
sudo wget -O /usr/bin/youtube2org https://raw.githubusercontent.com/uGeek/youtube2org/master/youtube2org
#+END_SRC
Damos permisos de ejecución
#+BEGIN_SRC 
sudo chmod +x /usr/bin/youtube2org
#+END_SRC
** YouTube a orgmode:
Para generar la imagen con el link, tan solo tenemos es escribir en nuestra terminal *youtube2org + url del video de YouTube*.

Ejemplo:
#+BEGIN_SRC bash
youtube2org https://www.youtube.com/watch?v=NxYITudzHlc 
#+END_SRC
El resultado que nos devolverá es este:
#+BEGIN_SRC orgmode
[[https://www.youtube.com/watch?v=NxYITudzHlc][http://img.youtube.com/vi/NxYITudzHlc/0.jpg]]
#+END_SRC

Ya lo tenemos!!!, ahora tan solo lo copiaremos en nuestro orgmode.


** YouTube a Markdown:

Como os decía, ya puestos, ¿Porqué no hacerlo también para Markdown?. El comando es el mismo que el anterior, solo que en este caso, añadiremos el tag *-m* para decile que queremos el link para Markdown:
#+BEGIN_SRC bash
youtube2org -m https://www.youtube.com/watch?v=NxYITudzHlc 
#+END_SRC
La terminal nos devolverá el enlace:
#+BEGIN_SRC bash
[![](http://img.youtube.com/vi/NxYITudzHlc/0.jpg)](https://www.youtube.com/watch?v=NxYITudzHlc "")
#+END_SRC
** Conclusión
Como podéis ver, con tan solo dos líneas de bash, hemos resuelto el problema. Espero que os haya gustado mucho y disfrutar dando un mejor acabado a vuestros documentos.

Repositorio en GitHub: - https://github.com/uGeek/youtube2org
* TODO El Adiós a Plex y Emby. Llega Jellyfin
:PROPERTIES:
:TITLE: El Adiós a Plex y Emby. Llega Jellyfin
:EXPORT_FILE_NAME: El Adios a Plex y Emby. Llega Jellyfin
:DESCRIPTION: Jellyfin es un servidor Multimedia donde podremos tener todas nuestras películas, series, música, Libros... Organizados y centralizados en un único lugar
:EXPORT_DATE: 2019-05-07 20:00 2019-11-30
:CATEGORY: servidor
:TAG: ubuntu, raspberry
:IMAGE: ./images-blog/jellifin.png
:END:

Emby llega a la versión 3.6 y decide cerrar el código, pasando a ser privativo. Un equipo de desarrolladores, decide hacer un Fork de la versión 3.5.2 de Emby para crear una alternativa 100% Software Libre y totalmente gratuita a Plex y Emby. Nace Jellyfin.

#+HTML: <center>
[[./images-blog/jellifin.png]]
#+HTML: </center>

Jellyfin es un servidor Multimedia donde podremos tener todas nuestras películas, series, música, Libros... Organizados y centralizados en un único lugar.

El punto fuerte de Jellyfin, no solo es que sea 100% Software Libre y gratuito, sino que tenemos la total garantía que todo nuestro contenido Multimedia, así como nuestras fotos o vídeos domésticos, mantienen la total privacidad, ya que nuestro servidor de Jellyfin, en ningún caso se conectará a servidores de terceros del mismo modo que lo hace Plex o Emby.

El servidor podemos instalarlo en todo tipo de Sistemas Operativos, ya que es totalmente multiplataforma. Windows, Linux, Mac. Yo en este Post os explicaré como instalarlo mediante Docker.

[[https://repo.jellyfin.org/releases/client/][Actualmente hay clientes disponibles para Jellyfin en Android, Android TV, Amazón Fire TV o Kodi]]. También podemos utilizar la versión web, mediante un navegador web,  DLNA, Chromecast, Roku, ... El equipo de Jellyfin, está abierto como todo proyecto de Software Libre, a la colaboración para el resto de dispositivos y Sistemas Operativos, como IOS, etc... Solo tiene 5 meses Jellyfin, así que irán apareciendo en breve.


Las versiones de Android, siguen estando en Beta y esta previsto que en muy breve espacio de tiempo, ya estén disponibles en Google Play o F-Droid, pero en una versión ya estable.

El servidor actualmente se mueve muchísimo más rápido y ligero que Emby en su versión 3.5.2. Esto es debido a que están optimizando tanto la interfaz web, mejora en el rendimiento con arquitectura para procesadores ARM de 64 Bits, registro de contraseñas mucho mas seguro, etc.... También está previsto que dividan partes del servidor para que sea el propio usuario, en función del uso que quiera darle al servidor, instale mediante Plugins aquello que desee.

Esta previsto que se añada compatibilidad con clientes de Subsonic y muchísimas más sugerencias que están apareciendo en el canal en Reddit de Jellyfin.

** Instalación por Docker

Las líneas para la instalación del servicio mediante  Dockers, he puesto que cada vez que encendamos el servidor, PC, Raspberry... Inicie Jellyfin. También he puesto que queden expuestos todos los puertos del contenedor, así podremos hacer uso si lo deseamos, de DLNA y futuras implementaciones al servicio por otros puertos. 

Para ser mas correctos, deberíamos especificar el tipo de arquitectura del procesador que vamos a utilizar. Aún así, en la práctica, yo he montado estos Dockers con exactamente estas líneas en mi Raspberry y Ubuntu Server sin ningún tipo de Problema.

Para tener la última versión del servidor Jellyfin, utilizaremos la siguiente líneas:
#+BEGIN_SRC 
docker run -d \
 --name jellyfin \
 --restart=unless-stopped \
 --network=host \
 -v $HOME/docker/jellyfin/config:/config \
 -v /media:/media \
 -e UID=1000 -e GID=100 \
 jellyfin/jellyfin:latest
#+END_SRC

Si queremos exponer el Jellyfin a la red mediante un Proxy Inverso, para acceder sin VPN, sería conveniente abrir solamente el puerto *8096*. Lo haríamos del siguiente modo:

#+BEGIN_SRC 
docker run -d \
 --name jellyfin \
 --restart=unless-stopped \
 -p 8096:8096 \
 -v $HOME/docker/jellyfin/config:/config \
 -v /media:/media \
 -e UID=1000 -e GID=100 \
 jellyfin/jellyfin:latest
#+END_SRC

** Accediendo al servicio
Para acceder al servicio, escribiremos en nuestro navegador: http://miservidor:8096/jellyfin/

** Enlaces
- [[https://jellyfin.github.io/][Web de Jellyfin]]
- [[https://repo.jellyfin.org/releases/client/][Repositorio de Clientes de Jellyfin]]
- [[https://github.com/jellyfin/jellyfin][Repositorio en GitHub]]
- [[https://jellyfin.readthedocs.io/en/latest/][Documentación]]
- [[https://www.reddit.com/r/jellyfin/][Canal en Reddit]]


** Conclusión
Hace dos meses y medio que tengo Jellyfin corriendo en mi Raspberry y dos versiones más de Jellyfin en mi Ubuntu Server. La verdad es que estoy encantado con el servicio y cada dos semanas, aparecen mejoras importantes. 

Jellyfin está destinado a ser uno de los grandes servicios de Software Libre como Nextcloud o Syncthing.

Os recomiendo darle una probada porque os sorprenderá.
* TODO Docker: Letsencript. Accediendo a todos mis servicios, desde cualquier lugar, sin VPN
:PROPERTIES:
:TITLE: Docker: Letsencript. Accediendo a todos mis servicios desde cualquier lugar sin VPN
:EXPORT_FILE_NAME: Accediendo a todos mis servicios desde cualquier lugar sin VPN
:DESCRIPTION: Esto nos permitirá poder acceder a muchos de los servicios que os he hablado durante más de dos años de Podcast, desde cualquier lugar, dispositivo, sin necesidad de utilizar una VPN y disfrutando de la totalidad de características disponibles en estos servicios
:EXPORT_DATE: 2019-05-15 20:30 2019-09-13
:CATEGORY: servidor
:TAG: nginx,raspberry,raspbian,docker
:IMAGE: ./images-blog/mountain-man.jpg
:END:

#+HTML: <center>
[[./images-blog/mountain-man.jpg]]
#+HTML: </center>


Este fin de semana, con la ayuda de [[https://elblogdelazaro.gitlab.io/][Carlos del Blog de Lazaro]], a quien agradezco todo el tiempo dedicado a responder todas mis preguntas, he montado por fin el [[https://hub.docker.com/r/lsioarmhf/letsencrypt][Docker de Let's Encrypt de la comunidad Linux Server]], que no solo te permite generar un certificado automáticamente y totalmente gratuito, para acceder a un servicio fuera de tu red local, si no que ademas permite crear un servidor de Proxy Inverso, permitiendo gracias a los [[https://www.duckdns.org][subdominios de Duck DNS]], poder acceder a mas de un servicio, teniendo solo un puerto abierto. 

Esto nos permitirá poder acceder a muchos de los servicios que os he hablado durante más de dos años de Podcast, desde cualquier lugar, dispositivo, sin necesidad de utilizar una VPN y disfrutando de la totalidad de características disponibles en estos servicios.

También podremos dar acceso a otros usuarios, amigos, familiares, etc... Ya que nosotros como administradores del servicio, tenemos el control total del mismo.

Servicios como Nextcloud, Jellyfin, tt-rss, Dokuwiki, Wordpress, etc... Los podremos utilizar en cualquier lugar, teniéndolos en nuestra Raspberry o Servidor y manteniendo el control total de todos nuestros datos.


Recuerda que gracias al certificado de Let's Encrypt, todos los datos entre servidor y cliente, irán totalmente cifrados.

Yo os voy a explicar como montarlo en Raspbian o cualquier servidor Linux, pero si eres de los que utilizan [[https://www.openmediavault.org/][Open Media Vault,]]
en breve [[https://elblogdelazaro.gitlab.io/][Carlos]] publicará un Post paso a paso de como hacerlo.

** Subdominio de Duck DNS
Accediendo a https://www.duckdns.org/, podremos dar de alta hasta cinco subdominios totalmente gratuitos. Dalos de alta y apunta el *TOKEN* que será necesario para el montaje del contenedor.

** Montar el Docker
Este es un ejemplo de lo que tenemos que introducir en la terminal para la montaje del Docker de Proxy inverso, donde debes de sustituir los siguiente valores:

- SUBDOMAINS
- DUCKDNSTOKEN
- EMAIL
#+BEGIN_SRC 
docker create \
  --name=letsencrypt \
  --cap-add=NET_ADMIN \
  --restart unless-stopped \
  -e ONLY_SUBDOMAINS=true \
  -e PUID=1000 \
  -e PGID=100 \
  -e TZ=Europe/Madrid \
  -e URL=duckdns.org \
  -e SUBDOMAINS=subdominio-uno,subdominio-dos,subdominio-tres \
  -e VALIDATION=http \
  -e DUCKDNSTOKEN=41fc1578-7fev7-4fb9-b20d-6d8vgemj6a9359 \
  -e EMAIL=ugeekpodcast@gmail.com \
  -e DHLEVEL=2048 \
  -p 443:443 \
  -p 80:80 \
  -v $HOME/docker/letsencript:/config \
  linuxserver/letsencrypt
#+END_SRC
En el caso de la Raspberry, yo he utilizado estas misma líneas de terminal y me ha funcionado perfectamente sin problemas

** Archivos de Configuración

Ya tenemos creado nuestro Docker. Ahora accederemos a la carpeta donde están los archivos de configuración de muestra (Hay muchos servicios de ejemplo) y vamos a modificar el archivo, añadiendo nuestra *IP* y *puerto* del servicio que queramos añadir en el Proxy Inverso.

#+BEGIN_SRC 
~/docker/letsencript/nginx/proxy-confs
#+END_SRC

Recuerda renombrar el archivo, dejando que acabe en *.conf*, para que el servidor interprete que es un archivo de configuración válido.

*** Ejemplo de archivo 

Vamos a crear un archivo para Nextcloud, pero en realidad puedes hacer lo mismo para cualquier servicio.

Creamos el nuevo archivo de configuración para Nexcloud.

#+BEGIN_SRC 
nano ~/docker/letsencript/nginx/proxy-confs/nextcloud.subdomain.conf
#+END_SRC


Sustituye las siguientes líneas y pon tus datos. Dominio, ip, puerto. 

Nextcloud lo tengo montado con letsencript, por eso la ruta del servidor es https. Si tu servicio utiliza http, ponlo así.
- =server_name mi_dominio.duckdns.org;=
- =proxy_pass https://192.168.1.100:81;=

#+BEGIN_SRC 
server {
    listen 443 ssl;
    listen [::]:443 ssl;

    server_name mi_dominio.duckdns.org;
    include /config/nginx/ssl.conf;
    client_max_body_size 0;

    # enable for ldap auth, fill in ldap details in ldap.conf                                                                                                                                                                                                
    #include /config/nginx/ldap.conf;                                                                                                                                                                                                                        

    location / {
        # enable the next two lines for http auth                                                                                                                                                                                                            
        #auth_basic "Restricted";                                                                                                                                                                                                                            
        #auth_basic_user_file /config/nginx/.htpasswd;                                                                                                                                                                                                       

        # enable the next two lines for ldap auth                                                                                                                                                                                                            
        #auth_request /auth;                                                                                                                                                                                                                                 
        #error_page 401 =200 /login;                                                                                                                                                                                                                         

        include /config/nginx/proxy.conf;
        resolver 127.0.0.11 valid=30s;
        set $upstream_nextcloud nextcloud;
        proxy_pass https://192.168.1.100:81;
    }    
}
#+END_SRC


*** Indexado de buscadores
Para que los buscadores como Google *no* indexen el servicio que tienes expuesto en el docker de Letsencrypt, añade al archivo de configuración las siguientes lineas:
#+BEGIN_SRC 
add_header X-Robots-Tag "noindex, nofollow, nosnippet, noarchive";
add_header X-Robots-Tag "none";
#+END_SRC 


** Iniciar, detener, reiniciar el Docker
Iniciar, reiniciar o detener el contenedor, no va a ser diferente a cualquier Docker que tengamos corriendo en nuestro servidor:
*** Iniciar 

#+BEGIN_SRC 
docker start letsencrypt
#+END_SRC

*** Detener 

#+BEGIN_SRC 
docker stop letsencrypt
#+END_SRC

*** Reiniciar

#+BEGIN_SRC 
docker restart letsencrypt
#+END_SRC


** Comprobar que todo vaya bien
Es recomendable la primera vez que iniciamos el  Docker, comprobar que todo funciona correctamente y no hay ningún error en algún archivo de configuración.

Si lo hubiera, el *log* nos mostrará donde está este error.

#+BEGIN_SRC 
docker logs -f letsencrypt
#+END_SRC

** Conclusión
Os puedo garantizar que el poder acceder desde el exterior de tu red local, a todos estos servicios de un modo seguro y teniendo el control de tus datos tu, es una sensación muy agradable. Montar el Docker no lleva mas de 5 minutos, así que te recomiendo el probarlo y que me cuentes tu experiencia.
* TODO Descargando videos de Internet con youtube-dl
:PROPERTIES:
:TITLE: Descargando videos de Internet con youtube-dl
:EXPORT_FILE_NAME: Descargando videos de Internet
:DESCRIPTION: En el Post de hoy, te voy a explicar cómo descargar no solo vídeos de YouTube, sino que también de muchos de los sitios web actuales con el comando youtube-dl
:EXPORT_DATE: 2019-06-02 18:25
:CATEGORY: aplicación
:TAG: terminal,youtube
:IMAGE: ./images-blog/youtube.png
:END:

En el Post de hoy, te voy a explicar cómo descargar no solo vídeos de YouTube, sino que también de muchos de los sitios web actuales con el comando youtube-dl.

#+HTML: <center>
[[./images-blog/youtube.png]]
#+HTML: </center>

Uno de los problemas que tiene esta aplicación, es que aunque está disponible en los repositorios oficiales de Ubuntu, el hecho de que YouTube cada dos por tres actualice su API, hace que no funcione correctamente si no tienes la última versión.

Voy a explicarte como instalarlo desde el propio repositorio del proyecto, evitándote  así muchos problemas.

- [[https://youtube-dl.org/][Web del Proyecto]]
- [[http://rg3.github.io/youtube-dl/supportedsites.html][Listado de webs que podemos descargar videos con youtube-dl]]

** Instalar la última versión de Youtube-dl
Como he comentado antes, vamos a instalarlo directamente descargando la aplicación desde el propio repositorio  del proyecto.
Para ello necesitamos tener instalado en nuestro Linux wget o curl.

*** Utilizando curl

=sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/bin/youtube-dl=
*** Utilizando wget

=sudo wget https://yt-dl.org/downloads/latest/youtube-dl -O /usr/bin/youtube-dl=

*** Damos permisos de ejecución
Ahora vamos a darle permisos de ejecución y ya tendremos nuestro youtube-dl totalmente disponible para comenzar a descargar vídeos.

=sudo chmod a+rx /usr/bin/youtube-dl=

** Utilizando youtube-dl
Youtube-dl tiene muchísimas opciones, todas ellas las encontrarás en la ayuda ejecutando el comando:

=youtube-dl -h=

*** Descargar un vídeo

Vamos a descargar un vídeo para probar si todo funciona correctamente. Para ello simplemente introduciremos el comando youtube-dl, seguido de la dirección web donde está el vídeo que queremos descargar.

=youtube-dl <URL>=
** Formatos disponible
Es posible que queramos descargar videos a diferentes resoluciones o formatos. Para descargar un vídeo o audio teniendo en cuenta esto, lo primero que haremos es listar todos los formatos y resoluciones disponibles. Para ello, utilizaremos *-F*:

=youtube-dl -F <URL>=

youtube-dl nos devolverá el listado precedidos de un número. Para descargarlos, especificaremos el número que aparece en el comando.

Ejemplo, en el caso que fuera el 218:
=youtube-dl -f 218 <URL>=


** Listas de Youtube
YouTube-dl también nos permite descargar listas de youtube. Lo primero que tenemos que hacer es localizar la URL de esta lista.

En la página web de Youtube, pulsamos justo encima de la lista y pasaremos a otra pantalla donde solo aparece la lista con el link que contiene la palabra list. Tipo: =https://www.youtube.com/playlist?list=

*** Descargar Lista
Para descargar la lista, haremos lo mismo que para descargar un vídeo,  youtube-dl seguido de la url de la lista. 

=youtube-dl <URL_LISTA>=

Si la descarga de la lista da problemas, podemos añadir -ci para que continúen las descargas antiguas, en caso de existir e ignore los errores continuando la descarga.

=youtube-dl -ci <URL_LISTA>=

*** Descargando no todos los videos de la lista
También es posible que no quedamos descargar la lista completa. Especificaremos el número del vídeo según el orden de la lista y solo estos se descargarán. 

Por ejemplo:
#+BEGIN_SRC 
youtube-dl --playlist-items=1,8,12 <URL_LISTA>
#+END_SRC
Solo se descargaran los videos 1,8 y 12.


*** Lista de audio
Youtube-dl también permite descargar el audio de los vídeos. Vamos a ver cómo descargar los audios de una lista de vídeo.

=youtube-dl -citx --audio-format mp3 --audio-quality 9 <URL_LISTA>=


** Descargar lista de videos creadas por nosotros
Una de las cosas que más me ha gustado de youtube-dl, es la posibilidad de crear nuestras propias listas de vídeos a descargar. Esto quiere decir que podemos ir creando en un archivo de texto plano, un listado de vídeos que queramos descargar posteriormente y llegado el momento, con una única línea de terminal, descargarlos todos de una vez.


Vamos a crear el archivo de texto plano, con la lista de todos vídeos que queremos descargar, en mi caso la llamaré *list.txt*.
Para descargar la lista emplearemos *-a*:

=youtube-dl -a list.txt=

Si hay problemas, forzaremos la descarga:

=youtube-dl -cit -a list.txt=

** Bajar audio
Cómo he comentado antes, youtube-dl también incluye la posibilidad de descargar los audios de los vídeos. Para descargar solo el audio, utilizaremos *-x*.

=youtube-dl -x <URL>=

Si queremos descargar, por ejemplo en mp3:

=youtube-dl -x --audio-format mp3 <URL>=

** Conclusiones
Youtube-dl es una de esas herramientas super alucinantes.  Como he comentado antes, aquí solo muestro algunas opciones básicas, pero  si buscas algo más específico, como algún formato de audio vídeo en concreto, te recomiendo qué consultes la documentación o acceda a la ayuda mediante youtube-dl --help.
* TODO Dale Almacenamiento ilimitado a tu Raspberry, Servidor o PC,... con Rclone
:PROPERTIES:
:TITLE: Dale Almacenamiento ilimitado a tu Raspberry, Servidor o PC,... con Rclone
:EXPORT_FILE_NAME: Dale Almacenamiento ilimitado a tu Raspberry Servidor o PC con Rclone
:DESCRIPTION: Rclone es una aplicación de Software Libre, que nos permite conectar nuestra Raspberry, Servidor con Linux o PC,  a las más conocidas nubes públicas (Dropbox, Google Drive, OneDrive, Mega, Hubic, PCloud, Box, Nextcloud, Owncloud, Amazon
:EXPORT_DATE: 2019-07-03 20:25 2019-07-24
:CATEGORY: aplicacion
:TAG: terminal
:IMAGE: ./images-blog/rclone.png
:END:


Rclone es una aplicación de Software Libre, que nos permite conectar nuestra Raspberry, Servidor o PC,  a las más conocidas nubes públicas (Dropbox, Google Drive, OneDrive, Mega, Hubic, PCloud, Box, Nextcloud, Owncloud, Amazon,...). 

#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>


Gracias a esta conectividad, podremos hacer copias o sincronizaciones de nuestras carpetas o archivos. Además, combinando Rclone con cron, podremos programar estas copias o sincronizaciones.

Rclone también permite copiar y sincronizar carpetas en local, por SSH, SFTP, WebDav, etc...  

Otros dos puntos fuertes de Rclone, es la posibilidad de montar la nube pública en una carpeta en Local, permitiendonos acceder a todo el contenido de esta nube, como si estuviera en local. El otro punto fuerte, es la posibilidad de cifrar todo el contenido que guardemos en la nube pública.

** Instalación
*** Instalación repositorios
Rclone está en los repositorios oficiales, así que su instalación es muy simple:

=sudo apt install rclone=

*** Instalación a la última (Recomendable)
Como sabeis, las api de muchas nubes públicas van cambiando periodicamente, así que quizas sería muy insteresante instalar la última versión. Para ello descargaremos el paquete de la arquiectura de nuestro procesador y los instalaremos así:

- [[https://rclone.org/downloads/][Descargalo desde aquí]]

#+BEGIN_SRC 
sudo dpkg -i <PAQUETE_DESCARGADOR>
#+END_SRC

*** rclone snap
Mucho mas desactualizado. También podemos instalar rclone desde snap

=sudo snap install rclone=

*** RcloneBrowser
Aunque el uso de rclone es muy sencillo, es probable que quieras utilizar interfaz gráfica para gestionar tus nubes:

En *Ubuntu 19.04*, podemos instalarlo desde los repositorios de oficiales:

=sudo apt install rclone-browser=


Instalación por PPA:
#+begin_src 
sudo add-apt-repository ppa:mmozeiko/rclone-browser
sudo apt-get update
sudo apt install rclone-browser
#+end_src
*** Fork de RcloneBrowser 
Como el proyecto rclone-browser está desactualizado hace más de 2 años, podemos encontrar también un [[https://github.com/noabody/RcloneBrowser][Fork en GitHub de noabody]].

** Acceder a una Nube
Rclone dispone de un listado amplio de nubes públicas.

Para utilizar una cuenta en rclone, teclearemos en nuestra terminal:

=rclone config=

Ahora, entre las opciones, introduciremos *n*, para crear una nueva cuenta en Rclone:
#+begin_src 
e) Edit existing remote
n) New remote
d) Delete remote
r) Rename remote
c) Copy remote
s) Set configuration password
q) Quit config
e/n/d/r/c/s/q> n
#+end_src

Nos pedirá que le *pongamos un nombre*

=name> drive=

Y ahora nos saldrá el gran listado de nubes públicas:

#+begin_src 
Type of storage to configure.
Enter a string value. Press Enter for the default ("").
Choose a number from below, or type in your own value
 1 / A stackable unification remote, which can appear to merge the contents of several remotes
   \ "union"
 2 / Alias for a existing remote
   \ "alias"
 3 / Amazon Drive
   \ "amazon cloud drive"
 4 / Amazon S3 Compliant Storage Providers (AWS, Ceph, Dreamhost, IBM COS, Minio)
   \ "s3"
 5 / Backblaze B2
   \ "b2"
 6 / Box
   \ "box"
 7 / Cache a remote
   \ "cache"
 8 / Dropbox
   \ "dropbox"
 9 / Encrypt/Decrypt a remote
   \ "crypt"
10 / FTP Connection
   \ "ftp"
11 / Google Cloud Storage (this is not Google Drive)
   \ "google cloud storage"
12 / Google Drive
   \ "drive"
13 / Hubic
   \ "hubic"
14 / JottaCloud
   \ "jottacloud"
15 / Local Disk
   \ "local"
16 / Mega
   \ "mega"
17 / Microsoft Azure Blob Storage
   \ "azureblob"
18 / Microsoft OneDrive
   \ "onedrive"
19 / OpenDrive
   \ "opendrive"
20 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH)
   \ "swift"
21 / Pcloud
   \ "pcloud"
22 / QingCloud Object Storage
   \ "qingstor"
23 / SSH/SFTP Connection
   \ "sftp"
24 / Webdav
   \ "webdav"
25 / Yandex Disk
   \ "yandex"
26 / http Connection
   \ "http"
#+end_src

Introducimos el número de la nube o cifrado y seguimos con el proceso...

El resto de pasos, está en un Ingles simple e intuitivo. Si no entiendes Ingles, te recomiendo Google Translate.

** Autorizar la cuenta sin tener interfaz gráfica
Uno de los problemas que podemos encontrar, es que para autorizar la cuenta de una nube pública, rclone nos pedirá el conectarnos a una url desde nuestro navegador, en el dispositivo en local y autorizar a rclone acceder a esta cuenta.

La verdad es que si no tienes interfaz gráfica, esto puede ser un serio problema, ya que no puedes utilizar un navegador como Firefox, Chrome, etc...

Los navegadores de texto para terminal, no todos son compatibles, así que solucioné el problema instalando un navegador como *uzbl* y accediendo a él remotamente desde un PC de un modo virtualizado:

*** Instalamos uzbl

=sudo apt install uzbl=

*** Acceder al navegador remotamene
Desde otro dispositivo, como puede ser un PC, nos conectaremos por SSH y abriremos el navegador:
 
=ssh -X -p 22 angel@192.168.1.100 uzbl=

/sustituye el usuario e IP/

Ahora introducimos la url que nos de rclone en la terminal, pulsando la tecla *o*

Ya podemos autorizar a rclone!!!

*** Método sencillo desde tu PC o Portátil

El método más sencillo, sería instalar rclone en tu PC o Portátil, conectarte a tus nubes desde él y copiar el archivo completo o la parte perteneciente a la nube que te interesa, en el configuración de rclone de tu raspberry o servidor sin interfaz gráfica.

El archivo de configuración, te recuerdo que está en: $HOME/.config/rclone/rclone.conf


** Iniciando Rclone y comandos básicos
Si has llegado hasta aquí, ya has vinculado con una de tus nubes a Rclone. Vamos a comprobar que todo funciona correctamente haciendo un *ls*.

Para utilizar una de las nubes, escribiremos el nombre que hemos otorgado a la unidad, seguido de dos puntos. 

Ejem:

A mi cuenta de Google Drive, le he puesto el nombre *drive*.

=drive:=

Si quiero acceder a una carpeta dentro de la nube. Por ejemplo, mi carpeta /Podcast/ugeek, lo representariamos así:

=drive:podcast/ugeek=

=drive:podcast=


*** Listar todas la nubes disponibles
Para listar todas las nubes que hemos añadido a rclone, utilizaremos el siguiente comando:
#+BEGIN_SRC 
rclone listremotes
#+END_SRC

*** Ver el tamaño de las carpetas 
#+BEGIN_SRC 
rclone size drive:Carpeta
#+END_SRC
*** Hacer un ls

Ver un listado de todos los archivos en la unidad:

=rclone ls unidad_creada:carpeta= 

Ver un listado, únicamente de las carpetas de la unidad con su fecha de creación:

=rclone lsd unidad_creada:carpeta=  -> ls de carpetas

Ver un listado, únicamente de las carpetas de la unidad:

=rclone lsf unidad_creada:carpeta= 

*** Hacer un tree, para ver toda la estructura de directorios y archivos

Hacer un tree de todas las carpetas y archivos
#+BEGIN_SRC 
rclone tree unidad_creada: 
#+END_SRC
Hacer un tree, para conocer la estructura *únicamente de las carpetas*.

#+BEGIN_SRC 
rclone tree unidad_creada: -d
#+END_SRC
#+BEGIN_SRC 
rclone tree --dirs-only unidad_creada:
#+END_SRC

*** Conocer el tamaño de los directorios con ncdu
ncdu es una herramienta que muestra todas las carpetas que tienes en tu disco duro y las ordena por tamaño. Haz lo propio con rclone mediante este comando:
#+BEGIN_SRC 
rclone ncdu unidad_creada:
#+END_SRC
*** Leer archivos en remoto
Leer remotamente un archivo de la nube:

=rclone cat unidad_creada:archivo.txt=
*** Crear un nuevo directorio
Para crear un directorio nuevo, igual que lo hacemos habitualmente en la terminal, utilizaremos *mkdir*. 

Ejemplo:

=rclone mkdir drive:fotos/viaje=
*** Mover archivos o Directorios 
#+BEGIN_SRC 
rclone moveto <origen> <destino>
#+END_SRC
Ejemplo:

Podemos utilizar -P para ver el proceso:
#+BEGIN_SRC 
rclone moveto drive:Mis_Fotos drive:Mis_Archivos/Mis_Fotos -P
#+END_SRC

Si en una carpeta cifrada, tenemos varias carpetas de gran tamaño y queremos mover una de estas a la raíz de la nube, tenemos que copiar el nombre de la carpeta cifrado, del tipo (vgaq89yqhg34gbhvai7g9q479) y moverlo a una nueva carpeta que crearemos en la raíz. Dentro podremos el archivo original cifrado.

En el archivo *rclone.conf*, copiaremos todos los datos de esa carpeta cifrada, modificando el nombre de esta nueva carpeta y la nueva ruta en la nube. Como puedes observar, ahora tendremos 2 carpetas cifradas, con la misma contraseña de cifrado.

*** Vaciar la papelera si es posible
#+BEGIN_SRC 
rclone cleanup drive:
#+END_SRC
*** Resto de Comandos 
Para conocer los comandos disponibles, lanza la ayuda:

=rclone -h=

#+BEGIN_SRC 
  about           Get quota information from the remote.
  authorize       Remote authorization.
  cachestats      Print cache stats for a remote
  cat             Concatenates any files and sends them to stdout.
  check           Checks the files in the source and destination match.
  cleanup         Clean up the remote if possible
  config          Enter an interactive configuration session.
  copy            Copy files from source to dest, skipping already copied
  copyto          Copy files from source to dest, skipping already copied
  copyurl         Copy url content to dest.
  cryptcheck      Cryptcheck checks the integrity of a crypted remote.
  cryptdecode     Cryptdecode returns unencrypted file names.
  dbhashsum       Produces a Dropbox hash file for all the objects in the path.
  dedupe          Interactively find duplicate files and delete/rename them.
  delete          Remove the contents of path.
  deletefile      Remove a single file from remote.
  genautocomplete Output completion script for a given shell.
  gendocs         Output markdown docs for rclone to the directory supplied.
  hashsum         Produces an hashsum file for all the objects in the path.
  help            Show help for rclone commands, flags and backends.
  link            Generate public link to file/folder.
  listremotes     List all the remotes in the config file.
  ls              List the objects in the path with size and path.
  lsd             List all directories/containers/buckets in the path.
  lsf             List directories and objects in remote:path formatted for parsing
  lsjson          List directories and objects in the path in JSON format.
  lsl             List the objects in path with modification time, size and path.
  md5sum          Produces an md5sum file for all the objects in the path.
  mkdir           Make the path if it doesn't already exist.
  mount           Mount the remote as file system on a mountpoint.
  move            Move files from source to dest.
  moveto          Move file or directory from source to dest.
  ncdu            Explore a remote with a text based user interface.
  obscure         Obscure password for use in the rclone.conf
  purge           Remove the path and all of its contents.
  rc              Run a command against a running rclone.
  rcat            Copies standard input to file on remote.
  rcd             Run rclone listening to remote control commands only.
  rmdir           Remove the path if empty.
  rmdirs          Remove empty directories under the path.
  serve           Serve a remote over a protocol.
  settier         Changes storage class/tier of objects in remote.
  sha1sum         Produces an sha1sum file for all the objects in the path.
  size            Prints the total size and number of objects in remote:path.
  sync            Make source and dest identical, modifying destination only.
  touch           Create new file or change file modification time.
  tree            List the contents of the remote in a tree like fashion.
  version         Show the version number.
#+END_SRC

** Copiar de un nube a otra
Es probable que queramos hacer una copia de nuestra fotos guardadas en Google Drive, en Dropbox. Para ello utilizariamos:

=rclone copy drive:fotos/verano/ dropbox:fotos/verano=

** Ver el proceso de copiado o sincronización
Una de las cosas que me ponen nervioso, es que cuando ejecutas un comando, la terminal se queda con ese comando introducido y no sucede nada. No sabes si se está copiando o sincronizando bien.

Si al final de la línea añadimos *-v*, veremos en nuestra terminal todo el proceso de copia o sincronización. Irá apareciendo toda la información del proceso archivo a archivo.

=rclone copy drive:fotos/verano/ dropbox:fotos/verano -v=


** Archivo de configuración
El archivo de configuración de rclone, está en la ruta: =$HOME/.config/rclone/rclone.conf=

Este archivo si lo llevamos a otro servidor o PC, podremos copiar todas las nubes con sus contraseñas en el otro dispositivo.

*Esto es genial, porque es muy cómodo y a la vez peligroso. Cuidado donde dejas este archivo*

*** Especificando donde está el archivo de configuración
Con *--config*, podemos especificar otra ruta del archivo de configuración de rclone.

Imagina que tengo mi archivo de configuración dentro de la carpeta *rclone* en el home del usuario, lo haríamos así:
#+begin_src 
rclone sync --config "/home/angel/rclone/rclone.conf" drive:fotos/verano/ dropbox:fotos/verano -v
#+end_src

** Copiar o Sincronizar
Con Rclone podemos hacer tanto copias como sincronizaciones. La sincronización, es algo parecido a *rsync*, ideal backups.

La sincronización solo copiará o borrará aquellos archivos modificados entre el origen y destino. 

Recuerda que el origen puede ser tanto la carpeta local, como la carpeta en la nube y viceversa.

*** Copiar
Ejemplo de copia en rclone:

*rclone copy origen destino*

Copiamos los archivos de *Google Drive*, a mi carpeta *fotos* en local:

=rclone copy drive:fotos/verano/ /home/angel/fotos/=

*** Sincronizar
Ejemplo de sincronización en rclone:

*rclone sync origen destino*

Syncronizamos mis nuevas *fotos* del verano, a la carpeta de *Google Drive* =/fotos/verano=

=rclone sync /home/angel/fotos drive:fotos/verano/=


** Cifrar una Carpeta
Para crear una carpeta cifrada, utilizaremos el mismo proceso que para vincular rclone a una nube pública:
- =rclone config=
- Nombre que utilizaremos en rclone, para sincronizar o copiar esa carpeta cifrada
- Seleccionamos:
#+begin_src 
 9 / Encrypt/Decrypt a remote
   \ "crypt"
#+end_src
En la versión de rclone *1.47*, aparece en el número nueve. Esto puede variar según la versión.

Mi carpeta cifrada, será una carpeta que crearé en la raíz de Google Drive, que llamaré "Mis Fotos".

Se da por hecho que has seguido la primera parte del tutorial, donde me he conectado a mi cuenta de Google Drive, creando una unidad con rclone llamada *drive*, y dentro de esta unidad, ahora voy a crear una carpeta llamada *Mis Fotos*.

De este modo, dentro de Google Drive tendré mis fotos cifradas.
#+begin_src 
remote> drive:Mis_Fotos
#+end_src
No voy a detallar todos los pasos, pero los siguientes son:
- Te preguntará si quieres que los archivos permanezcan ocultos para Google Drive, utilicen el nombre original del archivo (aun estando cifrados) o utilice un nombre complejo compuesto de números y letras.
- Añadir una o dos contraseñas para cifrar los archivos:
Es opcional el añadir la contraseña, yo prefiero ponerla.

*Recuerda que conservando el archivo de configuración, esta carpeta cifrada podrás montarla en otro dispositivo con rclone*

** Acceso a rclone mediante contraseña
Si tu Pc lo compartes con otras personas, quizás te interese el cifrar el archivo *rclone.conf*, para que nadie copie este archivo de configuración y pueda acceder a tus nubes.

Para ello haremos lo siguiente:

=rclone config=

Y seleccionaremos la opción:

=s) Set configuration password=

Nos informará que nuestro archivo de configuración no está cifrado y si deseamos cifrarlo. Cuando digamos que si, nos pedirá que introduzcamos la contraseña 2 veces, para confirmar que no nos hemos equivocado.

*Ahora cada vez que utilicemos rclone, nos pedirá la contraseña!!!*
** Sincronizaciones automatizadas si rclone tiene contraseña
*** Utilizar rclone, poniendo la contraseña en la misma línea
Con RCLONE_CONFIG_PASS="contraseña", delante de comando, no nos pedirá la contraseña:

#+BEGIN_SRC 
RCLONE_CONFIG_PASS="contraseña" rclone copy drive:fotos/verano/ /home/angel/fotos/
#+END_SRC
Esto en realidad, en entornos confiables puede ser una solución, a mi personalmente me gusta hacerlo así:




*** Desbloqueo de la contraseña en scripts programados 
Vamos a crear un script, que al iniciarlo, nos pedirá la contraseña:

=nano script.sh=
#+BEGIN_SRC 
#!/bin/echo Source this file don't run it
read -s RCLONE_CONFIG_PASS
export RCLONE_CONFIG_PASS
#+END_SRC

Damos permisos de ejecución:

=sudo chmod +x script.sh=

Iniciamos el script:

=./script.sh=

Ahora, el script nos pedirá que introduzcamos la contraseña.

Si creamos un script *automatizado* y no queremos que nos pida esta la contraseña, ya que este script probablemente se ejecute en segundo plano mediante cron, utilizaremos al final de la línea del comando *rclone* : 

#+BEGIN_SRC 
--ask-password=false
#+END_SRC

Ejemplo:

#+BEGIN_SRC 
rclone lsd drive: --ask-password=false
#+END_SRC 


** Montar/Desmontar unidad como si fuera un disco duro
Vamos a montar la nube pública en nuestro servidor, como si fuera una unidad de disco duro. Para ello, necesitamos instalar Fuse si no lo tenemos instalado.
*** Instalar Fuser

=sudo apt-get install fuse= 

*** Descomenta --allow-others

Descomentar la línea *--allow-others*

=sudo nano /etc/fuse.conf=

Para permitir a usuarios no root, montar unidades
#+BEGIN_SRC 
# Allow non-root users to specify the allow_other or allow_root mount options.
--allow-others
#+END_SRC
*Reinicia*

*** Montar  

=rclone mount <nube> <carpeta_local>=


=sudo rclone mount drive:Mis_Fotos /home/<tu_usuario>/Mis_Fotos=

Podemos utilizar los siguiente flags:

=--allow-other=             -> Permitir otros usuarios se conecten
=--read-only=               -> Acceso solo de lectura
=--vfs-cache-mode full -v=  -> Con esto activas el caché de lectura y escritura y ves los logs. Se comporta muchísimo más estable. Cuando escribes un fichero primero lo sube a la caché y después a la nube, pero durante el proceso el archivo estará bloqueado. Hay que tener paciencia. No sirve para usarlo como almacenamiento normal pero es muy cómodo para enviar archivos en bloque.

Ejemplo:

=sudo rclone mount drive:Mis_Fotos /home/<tu_usuario>/Mis_Fotos =--allow-other =--read-only=


** Automontar al iniciar el sistema operativo
Para automontar nuestra nube en una carpeta local, podemos hacerlo de diferentes formas. Vamos a utilizar cron ya que me parece el método más sencillo.

=sudo crontab -e=

Escribimos en cron, por ejemplo en mi caso:
#+BEGIN_SRC 
@reboot ( rclone mount --config "/home/<tu_usuario>/.config/rclone/rclone.conf" drive:Mis_Fotos /home/<tu_usuario>/Mis_Fotos --allow-other & )
#+END_SRC

Reiniciamos.

*Es muy importante especificar la ruta del archivo de configuración, ya que si no lo hacemos, como estamos ejecutando el comando como root, el archivo no lo buscará en el $HOME del usuario, sino que en el $HOME de root*

** Montar varias nubes con Rclone y SystemD

Germán Martín me mostró como gestiona rclone como si fuera un servicio gracias a SystemD.

Esto es muy bueno!!!. 

Mediante una llamada de terminal, el mismo servicio vale para todas las nubes.

Ejemplo:

=sudo service rclone-mount@Dropbox_gmag11 start=

El directorio =/cloud/Dropbox_gmag11/= debe existir así como el remoto =Dropbox_gmag11= en la configuración de RClone en el usuario rclone.


*** Script para montar y desmontar todas las nubes
Ha hecho un pequeño script llamado rclone-mount.sh

#+BEGIN_SRC 
echo $1
sudo systemctl $1 rclone-mount@Dropbox_gmag11
sudo systemctl $1 rclone-mount@Dropbox_gmag11hm
sudo systemctl $1 rclone-mount@GDrive_gmag11
#+END_SRC

**** Para montar hace  todas las nubes

=rclone-mount start= 

**** Para desmontar todas las nubes

=rclone-mount stop=

*Super Ingenioso!!!*

*** Servicio
#+BEGIN_SRC 
# Rclone mount on boot
# Copy file to: /lib/systemd/system
# You need to create a remote on RClone and a folder on your disk, both with same name <rclone-remote>
# This example uses /cloud/ folder as origin to mount all remotes, change it to your needs
# This example use a linux user named rclone. Create it or adapt it to your needs. Rclone will get config from that user's home folder
# Register new service by typing:
# sudo systemctl daemon-reload
# Do the next one for every remote you want to load on boot
# sudo systemctl enable rclone-mount@<rclone-remote>.service
# systemctl start rclone-mount@<rclone-remote>.service
# Usage:
# To unmount drive use
# systemctl stop rclone-mount@<rclone-remote>.service
# To mount use:
# systemctl start rclone-mount@<rclone-remote>.service
# To disable mount on boot use:
# systemctl disable rclone-mount@<rclone-remote>.service


[Unit]
Description=rclone FUSE mount for %i
Documentation=http://rclone.org/docs/
After=network-online.target externo.mount
# Mount point in my system is on a USB drive, don't ask why :))), that's why I have to wait for it to get mounted
Requires=externo.mount

[Service]
#Type=forking
# This example use a linux user named rclone. Create it or adapt it to your needs. Rclone will get config from that user's home folder
User=rclone
Group=rclone
# This example uses /cloud/ folder as origin to mount all remotes, change it to your needs
ExecStart=/usr/bin/rclone mount %i: /cloud/%i --vfs-cache-mode full -v --allow-other
ExecStop=/bin/fusermount -uz /cloud/%i

[Install]
#Wants=network-online.target
#Alias=rclone-rs
#RequiredBy=
WantedBy=multi-user.target
#+END_SRC



Con el parámetro --vfs-cache-mode full que va en la llamada a rclone se comporta muchísimo más estable. Cuando escribes un fichero primero lo sube a la caché y después a la nube, pero durante el proceso el archivo estará bloqueado.

Hay que tener paciencia. No sirve para usarlo como almacenamiento normal pero es muy cómodo para enviar archivos en bloque
--allow-other permite acceder al almacenamiento al resto de usuarios, incluido www-data

- [[https://gist.github.com/gmag11/dc139ffd6a8ca8b622e98ca6422f8d79][Fuente]]

** Rclone en Android

Acceder a una carpeta cifrada con rclone desde tu dispositovo Android, no es un problema. Disponemos de dos aplicaciones en el Google Play. Aquí te dejo la primera desde Google Play y la segunda, un repositorio en GitHub donde puedes descargar el apk:

- [[https://play.google.com/store/apps/details?id=pl.sviete.dom.rcloneexplorer][AIS synchro]]
- [[https://github.com/kaczmarkiewiczp/rcloneExplorer/releases][rcloneExplorer]]

Solo puedes instar una de estas dos aplicaciones. Las dos a la vez, no es posible, la segunda que instales te dará error.

*** Uso de Rclone en Android
Tan sencillo como importar el archivo de configuración *rclone.conf*, o crear una carpeta llamada *rclone* en la raíz de la memoria interna de tu teléfono y dejar dentro de esta, el archivo de configuración *rclone.conf*.

Cuando abras la aplicación, saldrán todas tus nubes. Podrás subir y bajar archivos, así como ver contenido multimedia en streaming.

** Rclone-Browser por Docker
También podemos montar el docker de Rclone-Browser, en una versión totalmente actualizada gracias al proyecto de Romancin. El docker podemos [[https://hub.docker.com/r/romancin/rclonebrowser][descargarlo desde DockerHub]] para arquitectura amd64 y acceder a Rclone-Browser mediante un navegador web por el puerto 5800 o VNC en el puerto 5900:

#+BEGIN_SRC 
docker run -d --name=rclonebrowser \
    -v $HOME/docker/rclonebrowser/config:/config \
    -v $HOME/docker/rclonebrowser/media:/media \
    -e GROUP_ID=0 -e USER_ID=0 \
    -e TZ=Europe/Madrid \
    -p 5800:5800 \
    -p 5900:5900 \
     romancin/rclonebrowser:latest
#+END_SRC
El archivo de configuración de rclone lo dejaremos en la carpeta *config* y los archivos, carpetas... que copiaremos o sincronizaremos, estarán en la carpeta *media*.

** Conclusión
Rclone es una herramienta alucinante. Nos permite utilizar un gran número de nubes públicas, privadas, hacer sincronizaciones o copias entre nubes, local-nube o nube-local, montar nubes en una carpeta local,... y gracias a rclone Browser o la versión de Android, utilizar una interfaz gráfica sencilla y consumir contenido multimedia en straming. ¿Que más se puede pedir?


** Fuentes
- [[https://rclone.org][Rclone]]
- [[https://martins.ninja/RcloneBrowser/][Rclone Browser]]

Gracias a todos los usuarios del Grupo de uGeek por recopilar más información, como Rapejim, Germán Martín,...
* TODO Instalando Syncthing por reposistorios y PPA
:PROPERTIES:
:TITLE: Instalando Syncthing por reposistorios
:EXPORT_FILE_NAME: Instalando Syncthing por reposistorios
:DESCRIPTION: Vamos a ver como instalar Syncthing desde los repositorios oficiales de debian, ubuntu, raspbian
:EXPORT_DATE: 2019-07-06 22:25
:CATEGORY: aplicacion
:TAG: terminal,syncthing
:IMAGE: ./images-blog/syncthing.png
:END:


Vamos a ver como instalar Syncthing desde los repositorios oficiales de debian, ubuntu, raspbian...
#+HTML: <center>
[[./images-blog/syncthing.png]]
#+HTML: </center>

** Instalación por repositorios

Ubuntu, Raspbian o derivadas de debian

=sudo apt install syncthing=

** Syncthing a la ultima por PPA
*** Instalando la última versión estable
El canal estable se actualiza generalmente cada primer martes del mes.

Instalamos el paquete apt-transport-https y las claves PGP:
 #+begin_src 
sudo apt install apt-transport-https
curl -s https://syncthing.net/release-key.txt | sudo apt-key add -
 #+end_src

Ahora vamos a añadir el repositorio estable:

=echo "deb https://apt.syncthing.net/ syncthing stable" | sudo tee /etc/apt/sources.list.d/syncthing.list=

Ahora actualizamos repositorios e instalamos:

=sudo apt update=
 
=sudo apt install syncthing=


*** Instalar versión candidate
El canal candidate, generalmente se actualiza cada segundo martes del mes. Estos salen tres semanas antes a la versión estable.

Es igual al proceso anterior, pero en lugar de añadir el repositorio estable, añadiremos el repositorio candidate:
#+begin_src 
echo "deb https://apt.syncthing.net/ syncthing candidate" | sudo tee /etc/apt/sources.list.d/syncthing.list
#+end_src

** Iniciando Syncthing
Ahora ya podemos lanzar la aplicación

=syncthing=

Se abrirá nuestro navegador automáticamente o lo abriremos nosotros, y para acceder a la interfaz web escribiremos localhost:8384

Para que Syncthing se inicie cada vez que arranquemos el sistema operativo, escribimos en la terminal:
#+BEGIN_SRC 
sudo systemctl enable syncthing@pi.service
sudo systemctl start syncthing@pi.service
systemctl status syncthing@pi.service
#+END_SRC
En el caso de la Raspberry, si tu usuario es *pi*, pondremos pi. Si has cambiado el usuario, pon tu usuario.

** Raspbian Lite

Lo primero que debemos hacer, si queremos acceder desde otro dispositivo a la interfaz web de Syncthing, dentro de nuestra red local, es
editar un archivo de configuración mediante SSH. Introduciremos esta línea en la Terminal y añadiremos la ip de nuestra Raspberry Pi, en
lugar de 127.0.0.1.

sudo nano ~/.config/syncthing/config.xml

Cambiamos aquí la ip por *0.0.0.0:8384*
#+begin_src 
<gui enabled="true" tls="false">
    <address>127.0.0.1:8384</address>
</gui>
#+end_src

 


* TODO Renombrando archivos masivamente
:PROPERTIES:
:TITLE: Renombrando archivos masivamente
:EXPORT_FILE_NAME: Renombrando archivos masivamente
:DESCRIPTION: Quería eliminar masivamente el título de unos archivos .mp3, donde había añadido el nombre del grupo. UNIX es ideal para estas tareas
:EXPORT_DATE: 2019-07-06 23:30
:CATEGORY: unix
:TAG: terminal,sed,bash
:IMAGE: ./images-blog/unix.png
:END:


Quería eliminar masivamente el nombre de unos archivos .mp3, donde había añadido el nombre del grupo. UNIX es ideal para estas tareas. Pensé primero en *sed*, o *tr*, aunque tr no es tan recomendable ya que toda coincidencia la renombraría. Mi tercer pensamiento fue buscar en Internet, y ahí encontré un magnífico Post del Blog [[https://www.ochobitshacenunbyte.com/2015/09/14/renombrar-multiples-nombres-ficheros-linux/][ochobitshacenunbyte.com]] donde explica, en este caso, sustituir los espacios en blanco por "_".

#+HTML: <center>
[[./images-blog/unix.png]]
#+HTML: </center>

Yo siguiendo con mi ejemplo, vamos a renombrar unos archivos mp3 que todos contienen la palabra "Supertramp":
#+begin_src 
for FILE in *.mp3 ; do NUEVOFICHERO=`echo $FILE | sed 's/Supertramp//g'`; mv "$FILE" $NUEVOFICHERO; done
#+end_src

con *for* listamos todos los archivos *.mp3*, añadimos el nombre del archivo a la variable *NUEVOFICHERO*, con *sed* lo renombramos y finalmente con *mv* movemos el nombre antiguo al nombre renombrado.

Resumiendo y si no te interesa el funcionamiento, sustituye la extensión *.mp3* y la palabra *Supertramp*, por la extensión o palabra que quieras renombrar.
* TODO Habilitando la accesibilidad como usuario root via ssh en debian
:PROPERTIES:
:TITLE: Habilitando la accesibilidad como usuario root via ssh en debian
:EXPORT_FILE_NAME: Habilitando la accesibilidad como usuario root via ssh en debian
:DESCRIPTION: Debian es un poco diferente a Ubuntu. Para habilitar el poder acceder como usuario root, tienes que configurar un archivo.
:EXPORT_DATE: 2019-07-08 21:00
:CATEGORY: debian
:TAG: terminal,ssh
:IMAGE: ./images-blog/debian.jpg
:END:


Debian es un poco diferente a Ubuntu. Para habilitar el poder acceder como usuario root, tienes que configurar un archivo.

#+HTML: <center>
[[./images-blog/debian.jpg]]
#+HTML: </center>

  
** Configurando el archivo de configuración de ssh, para habilitar root
Editamos el archivo sshd_config, por ejemplo con nano:
#+BEGIN_SRC 
nano /etc/ssh/sshd_config
#+END_SRC

Cambiamos el valor de *PermitRootLogin* a *yes*:
#+BEGIN_SRC 
#PermitRootLogin without-password
PermitRootLogin yes
#+END_SRC
** Reiniciamos el servidor
Ahora solo queda reiniciar el servidor, para que podamos acceder vía ssh desde cualquier terminal:
#+BEGIN_SRC 
/etc/init.d/ssh restart
#+END_SRC
Ya podemos acceder como root via ssh, por ejemplo:

=ssh root@192.168.1.100=

Recuerda sustituir la ip por la ip de tu servidor

* TODO Docker en debian Buster
:PROPERTIES:
:TITLE: Docker en debian Buster
:EXPORT_FILE_NAME: Docker en debian Buster
:DESCRIPTION: Vamos a instalar docker en debian Buster
:EXPORT_DATE: 2019-07-08 21:05
:CATEGORY: debian
:TAG: terminal,ssh,docker
:IMAGE: ./images-blog/docker.png
:END:

Vamos a instalar docker en debian Buster:

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>


** Instalando algunas dependencias
Accedemos como *root* y comenzamos la instalación:
#+BEGIN_SRC 
apt update
apt -y install apt-transport-https ca-certificates curl gnupg2 software-properties-common
#+END_SRC
** Importando  el GPG key oficial
#+BEGIN_SRC 
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
#+END_SRC
** Añadimos el repositorio que contiene docker para debian 10
#+BEGIN_SRC 
sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/debian \
   $(lsb_release -cs) \
   stable"
#+END_SRC

Este comando nos añade el repositorio en =/etc/apt/sources.list= 

** Ahora si vamos con la instalación. Actualizamos repositorios
Actualizamos repositorios:
#+BEGIN_SRC 
apt update
#+END_SRC
** Instalamos Docker CE y Docker Compose
#+BEGIN_SRC 
apt -y install docker-ce docker-compose
#+END_SRC

** Iniciamos Docker y lo habilitamos para que se inicie al reiniciar
#+BEGIN_SRC 
systemctl enable docker
systemctl start docker
#+END_SRC
** Comprobamos la versión de docker y si está instalado

=docker -v=

** Añadimos a nuestro usuario para controlar Docker

Creamos el grupo docker:
#+BEGIN_SRC 
groupadd docker
#+END_SRC

Añadimos al usuario, <NOMBRE DE TU USUARIO> sustituyendo por tu usuario:
#+BEGIN_SRC 
usermod -aG docker <NOMBRE DE TU USUARIO>
#+END_SRC
** Instalando Portainer
Sabéis que me gusta instalar Portainer, para gestionar los contenedores de un modo gráfico:

#+BEGIN_SRC 
docker run -d --name=portainer --restart=always -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer
#+END_SRC

* TODO Instalar VNC en tu servidor con debian u otra derivada
:PROPERTIES:
:TITLE: Instalar VNC en tu servidor con debian u otra derivada
:EXPORT_FILE_NAME: Instalar VNC en tu servidor con debian u otra derivada
:DESCRIPTION: Hay sistemas operativos que instalo una interfaz gráfica en el servidor y accedo remotamente vía VNC
:EXPORT_DATE: 2019-07-08 21:10
:CATEGORY: debian
:TAG: terminal,ssh,vnc
:IMAGE: ./images-blog/docker.png
:END:

Hay sistemas operativos que instalo una interfaz gráfica en el servidor y accedo remotamente vía VNC. Pero..., ¿Como lo instalamos y hacemos que sea accesible siempre el servidor desde el inicio del sistema?. 

Este es el método mas fácil y el que siempre empleo yo.

#+HTML: <center>
[[./images-blog/vnc.png]]
#+HTML: </center>

Recuerda que tal como explico en este tutorial, *el tráfico no está cifrado*. 

** Instalamos VNC
Accedemos como root:
#+BEGIN_SRC 
apt install x11vnc
#+END_SRC
** Creamos contraseña
*Entramos en la sesión de nuestro usuario* y escribimos en la terminal:

=x11vnc -storepasswd=

Escribimos la contraseña 2 veces y escribimos *Yes*

** Iniciamos el servidor desde el usuario
Vamos a ver si podemos acceder desde nuestro móvil, tablet o PC. Vamos a iniciar nuestro servidor VNC:

*Sustituye <USUARIO> por tu usuario:*
#+BEGIN_SRC 
x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/<USUARIO>/.vnc/passwd -rfbport 5900 -shared
#+END_SRC
** Que inicie siempre al iniciar al sistema
*Entramos nuevamente como root* y escribimos en la terminal:

=crontab -e=

Ahora añadiremos en el archivo de cron:


*Sustituye <USUARIO> por tu usuario:*
#+BEGIN_SRC 
@reboot ( sleep 100 ; x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/<USUARIO>/.vnc/passwd -rfbport 5900 -shared )
#+END_SRC
Recuerda que como iniciamos el servidor desde cron, tenemos que especificar la ruta del archivo de configuración de VNC, en la sesión de usuario, que era donde habíamos añadido la contraseña.

* TODO Cifrando archivos en git con GIT-CRYPT
:PROPERTIES:
:TITLE: Cifrando archivos en git con GIT-CRYPT
:EXPORT_FILE_NAME: Cifrando archivos en git con GIT-CRYPT
:DESCRIPTION: Hace un tiempo os hablé de .gitignore, un archivo oculto para que no suban determinados archivos a nuestro repositorio de git
:EXPORT_DATE: 2019-07-10 21:15
:CATEGORY: git
:TAG: terminal,ssh
:IMAGE: ./images-blog/git.png
:END:

#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>

Hace un tiempo os hablé de .gitignore, un archivo oculto para que no suban determinados archivos a nuestro repositorio de git. Quizás, desearías que suban determinados archivos, para poder gestionarlos desde otra máquina, pero que no fueran accesibles si el repositorio es público, osea que estos archivos estuvieran cifrados. He leído en el blog del [[https://www.atareao.es/como/cifrado-de-repositorios-git/][atareao.es]], esta joya. Voy a explicar con mis palabras como utilizarlo.
** Instalación
Súper fácil porque lo vamos a encontrar en los repositorios de nuestras distros.

=sudo apt install git-crypt=

** Creamos repositorio cifrado

El primer paso es tener ya un repositorio. Nos situamos dentro de la carpeta del repositorio tecleamos en la terminal:

=git-crypt init=

** Creamos un archivo .gitattributes

Ahora vamos a crear un archivo oculto donde especificaremos que archivos vamos a cifrar. Vamos a utilizar nano para crearlo:

=nano .gitattributes=

Indicamos que se cifren, por ejemplo, los archivos .html, .org, directorio:secretdir/**_secreto y archivo, con cualquier extensión o palabra que le preceda.

#+begin_src 
*.html filter=git-crypt diff=git-crypt`
*.org filter=git-crypt diff=git-crypt
directorio_secreto/** filter=git-crypt diff=git-crypt
*archivo* filter=git-crypt diff=git-crypt
#+end_src

Ahora cada vez que hagamos un commit, los archivos .html y .org, subirán cifrados.

** Contraseña con clave simétrica
Vamos utilizar de contraseña un archivo llave, que será este la contraseña para desbloquear el cifrado en otra máquina.
*** Generando Llave
Para generar el cifrado, voy a utilizar de archivo a modo de contraseña. Le pondré *key*, pero podría ponerle cualquier nombre, como el nombre del repositorio

=git-crypt export-key ~/carpeta/key=


*** Desbloquear el cifrado mediante el archivo llave:
Ahora en mi PC de sobremesa, he clonado mi repositorio pero todos los archivos .html y .org están cifrados. Para descifrarlos necesito el *key* y por supuesto, *instalar git-crypt* en este PC:

=git-crypt unlock ~/carpeta/key=

Ya puedo ver el contenido!!!!

** Conclusión 
Simplemente alucinante!!!. Súper útil para cifrar aquellos archivos que queremos utilizarlos con git, pero que en un repositorio público no queremos que sean visibles.
* TODO Añadir cajetilla de código en orgmode como antes
:PROPERTIES:
:TITLE: Añadir cajetilla de código en orgmode como antes
:EXPORT_FILE_NAME: Añadir cajetilla de código en orgmode como antes
:DESCRIPTION: A partir de la versión Org 9.2, ya no es posible utilizar el atajo que utilizábamos en versiones anteriores
:EXPORT_DATE: 2019-07-13 16:30
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/orgmode.png
:END:

A partir de la versión Org 9.2, ya no es posible utilizar el atajo que utilizábamos en versiones anteriores, *<s*, para añadir la cajetilla de código.

#+HTML: <center height="250" width="250"> 
[[./images-blog/orgmode.png]]
#+HTML: </center

Ahora tenemos que pulsar C-c C-, y aparecerá un listado de que sintaxis queremos utilizar. 

Si eres como yo y quieres recuperar ese atajo, tan sencillo como añadir al archivo de configuración *init.el*:

=(require 'org-tempo)=
* TODO Emacs 26.2 en Ubuntu
:PROPERTIES:
:TITLE: Emacs 26.2 en Ubuntu
:EXPORT_FILE_NAME: Emacs 26-2 en Ubuntu
:DESCRIPTION: A partir de la versión Org 9.2, ya no es posible utilizar el atajo que utilizábamos en versiones anteriores
:EXPORT_DATE: 2019-07-22 20:00
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/emacs.png
:END:

Vamos a instalar Emacs por PPA en Ubuntu 18.04


#+HTML:  <center height="250" width="250">
[[./images-blog/emacs.png]]  
#+HTML: </center>


** Instalación por PPA
Añadimos el repositorio:

=sudo add-apt-repository ppa:kelleyk/emacs=

Actualizamos repositorios:

=sudo apt update=

Instalamos emacs:

=sudo apt install emacs26=
 
* TODO Cambiando el Idioma en Debian, Ubuntu, Raspbian...
:PROPERTIES:
:TITLE: Cambiando el Idioma en Debian, Ubuntu, Raspbian...
:EXPORT_FILE_NAME: Cambiando el Idioma en Debian Ubuntu Raspbian
:DESCRIPTION: Si tu sistema está configurado un idioma y deseas cambiarlo, sigue leyendo y verás que no es complicado
:EXPORT_DATE: 2019-08-15 11:43
:CATEGORY: bash
:TAG:      ubuntu,debian,raspbian
:IMAGE: ./images-blog/ugeek.png
:END:

Si tu sistema está configurado un idioma y deseas cambiarlo, sigue leyendo y verás que no es complicado

** Instalación

Si no está instalada, instalaremos los paquetes locales:
#+BEGIN_SRC 
sudo apt install locales
#+END_SRC
** Configuración
Utilizamos el asistente de configuración de locales:

=dpkg-reconfigure locales=

Nos lanzará un asistente con todos los idiomas disponibles, para que seleccionemos cual queremos instalar y utilizar.

** Localizaciones disponibles
Para saber las localizaciones instaladas y disponibles, utilizaremos:

=locale=

También podemos utilizar:

=localectl=

Para saber el formato de fecha y hora instaladas así:   

=locale -k LC_TIME=

Todas las localizaciones disponibles *-a*:

=locale -a=

** Localización local actual
Podemos conocer la configuración locale mediante:

=sudo nano /etc/default/locale=

También podemos establecer la hora local mediante:

=sudo update-locale=

** Usuario con otra localización

Editamos o creamos el archivo .bash_profile:

=nano ~/.bash_profile=

y añadiremos:
#+BEGIN_SRC 
LANG="es_ES.utf8"
export LANG
#+END_SRC 
** Raspbian
En Raspbian también puedes hacerlo desde:

=sudo raspi-config=

La terminal te devolverá un menú donde podrás acceder a todas estas configuraciones que hemos visto.
* TODO CryFS. Cifrando el contenido de tu carpeta
:PROPERTIES:
:TITLE: CryFS. Cifrando el contenido de tu carpeta
:EXPORT_FILE_NAME: CryFS. Cifrando el contenido de tu carpeta
:DESCRIPTION: CryFS es un sistema de cifrado parecido a EncFS, pero mas robusto. Utiliza dos carpetas, una donde están los archivos cifrados y otra que tenemos que crear, para montar los archivos si cifrar
:EXPORT_DATE: 2019-08-15 13:10
:CATEGORY: cifrado
:TAG:      bash
:IMAGE: ./images-blog/ugeek.png
:END:

CryFS es un sistema de cifrado parecido a EncFS, pero mas robusto. Utiliza dos carpetas, una donde están los archivos cifrados y otra que tenemos que crear, para montar los archivos si cifrar. 

*** Instalación

=sudo apt install cryfs=

*** Creando las carpetas

Creámos las carpetas donde pondremos nuestro datos tanto cifrados y la unidad de montaje.

=mkdir ~/directorio_cifrado=
=mkdir ~/directorio_montaje=

*** Cifrado

Vamos a montar la carpeta cifrada:
 
=cryfs ~/directorio_cifrado ~/directorio_montaje=


*** Desmontando

=fursermount -u ~/directorio_montaje=

*** Documentación

https://www.cryfs.org/tutorial

*** Fuentes

- https://www.atareao.es/software/seguridad/como-cifrar-la-nube/
- https://code.castanedo.es/guzman/cryfs-automount
 
* TODO Recupera archivos borrados con Test Disk
:PROPERTIES:
:TITLE: Recupera archivos borrados con Test Disk
:EXPORT_FILE_NAME: Recupera archivos borrados con Test Disk
:DESCRIPTION:
:EXPORT_DATE: 2019-08-15 22:00
:CATEGORY: bash
:TAG: bash
:IMAGE: ./images-blog/testdisk.png
:END:

Si has borrado por error un archivo en tu terminal, no temas, quizás estas a tiempo de recuperarlo. Voy a explicarte un método muy sencillo de hacerlo con TestDisk

#+HTML: <center height="250" width="250"> 
[[./images-blog/testdisk.png]]
#+HTML: </center>

** Instalación

=sudo apt install testdisk=

** Funcionamiento
Le daremos a: =>[ Create ] Create a new log file=

Ahora nos mostrará todas las unidades que tenemos en nuestro sistema. Seleccionaremos la unidad desde la que queremos recuperar los datos.

Pulsaremos esta opción: =>[None   ] Non partitioned media=

Ahora le daremos a la opción avanzada: =>[ Advanced ] Filesystem Utils=

*En la parte inferior*, seleccionaremos =[  List  ]= 

Ahora navegaremos por nuestro disco. En color rojo saldrán los archivos borrados.

** Recuperar archivo
Para recuperar un archivo, nos situaremos encima del archivo rojo y seleccionaremos la letra *C*.

Ahora TestDisk nos preguntará donde queremos guardar el archivo, volvemos a pulsar la tecla *C* y... 

YA ESTÁ RECUPERADO!!! 

** Salir o ir hacia atras
Tan sencillo como pulsar la tecla *q*.
 
* TODO Corrector Ortográfico para Emacs en Raspbian
:PROPERTIES:
:TITLE: Corrector Ortográfico para Emacs en Raspbian
:EXPORT_FILE_NAME: Corrector Ortagráfico para Emacs en Raspbian
:DESCRIPTION: Tras adquirir mi nueva Raspberry 4 y la aparición de la nueva debian Buster, estoy utilizando Emacs remotamente
:EXPORT_DATE: 2019-08-16 11:00
:CATEGORY: emacs
:TAG: orgmode,raspbian,org-bash-blog
:IMAGE: ./images-blog/emacs.png
:END:

Tras adquirir mi nueva Raspberry 4 y la aparición de la nueva debian Buster, estoy utilizando Emacs remotamente. La versión de Emacs disponible en Raspbian Buster, es la Emacs 26.1. Los que conocemos Emacs, sabemos que exportando tu archivo de configuración init.el, Emacs en el primer arranque, instalará todos los paquetes necesarios y dejará este, igual que en el anterior dispositivo que lo estabas utilizando.

#+HTML:  <center height="250" width="250">
[[./images-blog/emacs.png]]  
#+HTML: </center>

No a sido del todo así. El corrector de castellano, al utilizar una arquitectura diferente, me ha fallado. Así que he tenido que buscar una solución. Gracias al de emacs.stackexchange.com, la he encontrado. Adjunto el código adaptado para Castellano.

** Añade a tu init.el
En el caso de querer utilizar el Castellano como corrector, añadiremos ~es_ES~. Sustituye por el idioma que desees.

#+BEGIN_SRC 
(setq ispell-program-name "hunspell")
(setq ispell-local-dictionary "es_ES")
(setq ispell-local-dictionary-alist
      '(("es_ES" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil nil nil utf-8)))
#+END_SRC

* TODO Actualiza el Firmware de tu Raspberry
:PROPERTIES:
:TITLE: Actualiza el Firmware de tu Raspberry
:EXPORT_FILE_NAME: Actualiza el Firmware de tu Raspberry
:DESCRIPTION: Actualizar el firmware de tu Raspberry a la última, es muy sencillo
:EXPORT_DATE: 2019-08-17 15:50
:CATEGORY: raspberry
:TAG: raspberry,bash
:IMAGE: ./images-blog/raspberrypi.jpg
:END:

Actualizar el firmware de tu Raspberry a la última, es muy sencillo.

#+HTML: <center>
[[./images-blog/raspberrypi.jpg]]
#+HTML: </center>

** Actualización
Para actualizar el firmware:

#+BEGIN_SRC 
sudo rpi-update
#+END_SRC

A mi personalmente, me gusta poner todos estos comandos dentro de un script, así de un modo sencillo, lo pongo todo al día:

#+BEGIN_SRC 
sudo apt-get update
sudo apt-get -y upgrade
sudo apt autoremove
sudo apt clean
sudo rpi-update
#+END_SRC
* TODO Configuración y diferencias entre bashrc, bash profile, bashrc, profile o sus versiones zsh
:PROPERTIES:
:TITLE: Configuración y diferencias entre bashrc, bash profile, bashrc, profile o sus versiones zsh
:EXPORT_FILE_NAME: Configuracion y diferencias entre bashrc bash profile
:DESCRIPTION: Navegando por las web encontré este interesante Post donde se explica la diferencia entre los archivos de configuración
:EXPORT_DATE: 2019-08-19 18:10
:CATEGORY: bash
:TAG: ssh, terminal, zsh
:IMAGE: ./images-blog/bash.jpg
:END:



Navegando por las web encontré [[https://elpuig.xeill.net/Members/rborrell/articles/los-archivos-bashrc-bash_profile-etc-bashrc-etc-profile-los-archivos-bashrc-bash_profile-etc-bashrc-etc-profile-cual-utilizar][este interesante Post]] donde se explica la diferencia entre los archivos de configuración  ~~/.bashrc, ~/bash_profile, /etc/bashrc, /etc/profile~.

La diferencia más importante, es que unos archivos afectan solamente al usuario que está ejecutando la sesión y los otros, afectan a la totalidad de usuarios.

#+HTML: <center>
[[./images-blog/bash.jpg]]
#+HTML: </center>

En estos archivos, podemos añadir scripts para que se ejecuten al iniciar el usuario o sesión.

Vamos a ver como configurarlo y como afecta cada archivo. Lo dividiremos en los dos grandes grupos.

** Todos los usuarios
*** Cuando inicia la sesión 
Archivo =/etc/profile=

#+BEGIN_SRC 
sudo nano /etc/profile
#+END_SRC
*** Cuando se ejecuta Bash o Zsh 
Archivo =/etc/bashrc=

En *Bash*

#+BEGIN_SRC 
sudo nano /etc/zsh/zshrc
#+END_SRC

En *Zsh*

#+BEGIN_SRC 
sudo nano /etc/zsh/zshrc
#+END_SRC

** Para tu usuario
*** Cuando inicias sesión

En *Bash* 

Archivo =~/.bash_profile=

#+BEGIN_SRC 
nano ~/.bash_profile
#+END_SRC
En *Zsh*

Archivo =~/.zsh_profile=

#+BEGIN_SRC 
nano ~/.zsh_profile
#+END_SRC


*** Cuando inicias Bash o Zsh  
En *Bash*

Archivo =~/.bashrc=

#+BEGIN_SRC 
nano  ~/.bashrc
#+END_SRC

En *Zsh*

Archivo =~/.zshrc=

#+BEGIN_SRC 
nano  ~/.zshrc
#+END_SRC


* TODO Cada vez mas clientes de Jellyfin. Aplicaciones para Escritorio Linux, Windows, Mac, Android, Kodi
:PROPERTIES:
:TITLE: Cada vez mas clientes de Jellyfin. Aplicaciones para Escritorio Linux, Windows, Mac, Android, Kodi
:EXPORT_FILE_NAME: Cada vez mas clientes de Jellyfin
:DESCRIPTION: Solo llevamos unos 9 meses desde el nacimiento de Jellyfin y los clientes ya están llegando al nivel de madurez deseado
:EXPORT_DATE: 2019-08-21 01:30
:CATEGORY: jellyfin
:TAG: ssh, terminal
:IMAGE: ./images-blog/jellifin.png
:END:

Solo llevamos unos 9 meses desde el nacimiento de Jellyfin y los clientes ya están llegando al nivel de madurez deseado, saliendo de sus estados alpha, beta, para estar disponibles de un modo estable en los respectivos Stores.

#+HTML: <center>
[[./images-blog/jellifin.png]]
#+HTML: </center>

La Aplicación de Android Tv, ahora funciona perfectamente en el dispositivo móvil también. A mi personalmente, me gusta mucho mas que la versión clásica de Android, que no deja de ser una webapp adaptada.

En el Post de hoy te indico los enlaces hasta esas aplicaciones y una aplicación de Escritorio, que aunque esta desarrollada en Electron, funciona perfectamente bien y es una buena solución si no deseas acceder desde el navegador web.

** Cliente de escritorio Linux, Mac Windows
Esta desarrollada en Electron. El proyecto está disponible en [[https://github.com/jellyfin/jellyfin-theater-electron][este repositorio de GitHub]]. En este Post solo te explico como instalarla en Linux. Si quieres instalarla en otro sistema operativo, accede al  [[https://github.com/jellyfin/jellyfin-theater-electron][al repositorio de GitHub]].

*** Instalación 
Nos situaremos en la raíz del HOME:

=cd=

Clonamos el repositorio y accedemos al interior de la carpeta:

=git clone https://github.com/jellyfin/jellyfin-theater-electron.git ; cd jellyfin-theater-electron=

Instalamos:

=npm install=

Ahora ejecutamos por primera vez la aplicación:

=npm start=

Vamos a crear un enlace con alias. Cada vez que escribamos en la terminal *jellyfin*, nos abra la aplicación.
Añadamos a nuestro archivo *.bashrc* o *.zshrc* en la raíz de nuestro HOME.

Si utilizamos Bash:
#+BEGIN_SRC 
nano .bashrc
#+END_SRC
Si utilizamos Zsh:
#+BEGIN_SRC 
nano .zshrc
#+END_SRC
Ahora añadimos:
#+BEGIN_SRC 
# Alias de Jellyfin
alias jellyfin='npm start --prefix ~/jellyfin-theater-electron'
#+END_SRC

** Android
Ya están disponibles las apps para Android, Android TV y Amazon Fire Tv Stick, en sus respectivos *Stores*.
- [[https://play.google.com/store/apps/details?id=org.jellyfin.mobile&hl=es_419][Android]]
- [[https://play.google.com/store/apps/details?id=org.jellyfin.androidtv&hl=es_419][Android Tv]]
- [[https://www.amazon.com/Jellyfin-for-Fire-TV/dp/B07TX7Z725/ref=redir_mobile_desktop?_encoding=UTF8&%2AVersion%2A=1&%2Aentries%2A=0][Amazon Fire Tv Stick]]

** Kodi
También podemos encontrar el Plugin para Kodi [[https://github.com/jellyfin/jellyfin-kodi][en el repositorio de GitHub]].

** Documentación
Os dejo con el resto de Clientes disponibles en la documentación de Jellyfin. Podemos encontrar para un montón de plataformas y otras que esta por llegar.
 
- [[https://jellyfin.readthedocs.io/en/latest/clients/][Documentación Cliente Jellyfin]]
* TODO QTodoTxt. todo.txt en tu escritorio
:PROPERTIES:
:TITLE: QTodoTxt. todo.txt en tu escritorio
:EXPORT_FILE_NAME: QTodoTxt
:DESCRIPTION: Después de mucho probar distintas aplicaciones de todo.txt para Escritorio, mi favorita es QTodoTxt
:EXPORT_DATE: 2019-08-21 02:50
:CATEGORY: notas
:TAG: ssh, terminal
:IMAGE: ./images-blog/qtodotxt.png
:END:

Después de mucho probar distintas aplicaciones de todo.txt para Escritorio, mi favorita es QTodoTxt. 

#+HTML: <center>
[[./images-blog/qtodotxt.png]]
#+HTML: </center>

El pequeño problema que tienes esta aplicación, es que su instalación puede resultar un poco complicada. En este Post, lo explico de un modo sencillo, para que la pruebes y puedas disfrutar de ella. 

** Instalación

#+BEGIN_SRC 
sudo apt-get install python3-pyqt5 qtdeclarative5-models-plugin python3-pyqt5.qtquick qml-module-qtquick-controls qml-module-qtquick-dialogs qml-module-qt-labs-settings qml-module-qt-labs-folderlistmodel
#+END_SRC

Clonamos el [[https://github.com/QTodoTxt/QTodoTxt2][repositorio]] en la ruta que decidamos. Voy por ejemplo a utilizar la carpeta $HOME:

#+BEGIN_SRC 
cd ; git clone https://github.com/QTodoTxt/QTodoTxt2
#+END_SRC

** Ejecutando el programa

Para ejecutar QTodotxt, entramos dentro de la carpeta *bin* y ejecutamos =python3 qtodotxt=

En el caso anterior, si has clonado la carpeta como yo en el $HOME del usuario, puedes ejecutar: 

#+BEGIN_SRC 
python3 ~/QTodoTxt2/bin/qtodotxt
#+END_SRC

- [[https://github.com/QTodoTxt/QTodoTxt2][Repositorio en GitHub]]

** Atajos

- Ctrl+n -> Crear Nueva Tarea
- Editar tarea, Situarse sobre la tarea y pulsar *Enter*
- añadir fecha al calendario -> due: o t:
- ocultar tarea -> h:1

[[https://github.com/QTodoTxt/QTodoTxt/wiki][Documentación]]

** Conclusión

Gracias a Simpletask en tu movil android y QTodoTxt en tu escritorio, puedes tener tus listas de tareas totalmente accesibles.
  
* TODO Borrar Contenedores, imágenes, Volúmenes y Redes de tus Dockers con Prune
:PROPERTIES:
:TITLE: Borrar Contenedores, imágenes, Volúmenes y Redes de tus Dockers con Prune
:EXPORT_FILE_NAME: Dockers con Prune
:DESCRIPTION: Si trasteas mucho con docker, siempre llega un momento en el que te das cuenta que tu disco está lleno de contenedores
:EXPORT_DATE: 2019-08-29 10:30
:CATEGORY: docker
:TAG: ssh, terminal
:IMAGE: ./images-blog/docker.png
:END:

Si trasteas mucho con docker, siempre llega un momento en el que te das cuenta que tu disco está lleno de contenedores, imágenes y volúmenes colgados, que ya no están en uso y han quedado obsoletos en tu disco ocupando espacio. Si tienes muchos, es una labor muy tediosa tener que borrar uno a uno todos los contenedores e imágenes. Hay un modo sencillo de borrarlo, vamos a utilizar *prune*.

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

** Detener todos los contenedores
Lo primero que haremos con un comando en bash, detener todos los contenedores para iniciar solo aquellos que queremos conservar
#+BEGIN_SRC 
docker stop $(docker ps -q)
#+END_SRC
** Contenedores
Ya tenemos todos los contenedores detenidos. *Inicia aquellos que quieres conservar*, ya que *prune eliminará todos los contenedores detenidos*.
*** Borrar Contenedores detenidos
#+begin_src 
docker container prune
#+end_src
Aparecerá un mensaje para que confirmes si realmente deseas borrarlos. Si no deseas que te pregunte, añade el flag *-f*.
#+begin_src 
docker container prune - f
#+end_src
** Imágenes
Ya has eliminado los contenedores que no deseabas y ahora habrán quedado imágenes *colgadas*, que no pertenecen a ningún contenedor.

Las imágenes colgadas son aquellas que en su día utilizaste con un contenedor y ahora no pertenece a ninguno, quedando en tu servidor.

También cada vez que actualizamos un contenedor, descarga una nueva imagen. La versión anterior queda en nuestro servidor *colgada*.

Docker no elimina las imágenes antiguas, ya que el objetivo de docker es que nosotros tengamos el control total de nuestros datos, así seremos nosotros los encargados de hacerlo.

*** Ver imágenes colgadas
#+BEGIN_SRC 
docker image ls -f "dangling=true"
#+END_SRC
*** Borrar *únicamente las imagenes colgadas*
#+BEGIN_SRC 
docker image prune
#+END_SRC

*** Borrar imágenes que no están siendo utilizadas por ningún contenedor, en el momento de ejecutar el comando
#+BEGIN_SRC 
docker image prune -a
#+END_SRC

** Volúmenes

Docker crea unos volúmenes para compartir información con el contenedor. Muchos de estos volúmenes, también quedan colgados como sucede con las imágenes. Nuevamente somos nosotros quien tenemos que borrar estos volúmenes en desuso.

*** Listar volúmenes
#+BEGIN_SRC 
docker volume ls
#+END_SRC
*** Eliminar todos los volúmenes que no sean utilizados  contenedor.
#+BEGIN_SRC 
docker volume prune
#+END_SRC

** Redes

Docker crea tres redes predeterminadas, bridge,host y none. Es posible que nosotros hayamos creado mas redes y ahora queramos eliminarlas

*** Listar redes
#+begin_src 
docker network ls
#+end_src
*** Eliminar Redes no utilizadas
#+begin_src 
docker network prune
#+end_src

** Todo de una vez 
Hay un método que te permitirá hacer todos los pasos anteriores de una vez. 

*** Borrar Contenedores, imágenes, redes colgados
#+begin_src 
docker system prune
#+end_src
La terminal te pedirá que confirmes si deseas eliminarlos
*** Contenedores, imágenes, redes colgados detenidos
Borrar todos los contenedores *detenidos*, todas *las redes no utilizadas* por al menos un contenedor, *todas las imágenes sin al menos un 
contenedor* asociado a ellas y *todo el caché* de construcción.
#+begin_src 
docker system prune -a
#+end_src
*** Añadir también los volumenes
Por defecto, no elimina los volúmenes.  Si quieres incluir también estos
#+BEGIN_SRC 
docker system prune --volumes
#+END_SRC
** Borrar Contenedores por tiempo
Si nos ponemos ha hacer pruebas montando contenedores, también podemos borrar estos por tiempo de creación. Por ejemplo, con este comando borraremos todos los contenedores creado hasta hace 2 horas
#+begin_src 
docker container prune --force --filter "until=2h"
#+end_src
** Ayudas
Puedes acceder a las ayudas desde tu terminal. Por ejemplo, la ayuda de *system prune*:
#+begin_src 
docker system prune --help.
#+end_src

** Fuente

- https://takacsmark.com/docker-prune/
- https://www.vidaxp.com/tecnologia/como-borrar-imagenes-contenedores-y-volumenes-docker/

* TODO Fim. Un vilsualizador de imágenes liviano para terminal
:PROPERTIES:
:TITLE: Fim. Un vilsualizador de imágenes liviano para terminal
:EXPORT_FILE_NAME: Fim. Un vilsualizador de imagenes liviano para terminal
:DESCRIPTION: Tras mucho darle vueltas, he pensado que la previsualización de los post
:EXPORT_DATE: 2019-08-29 18:15
:CATEGORY: bash
:TAG: ssh, terminal
:IMAGE: ./images-blog/ugeek.png
:END:

Estoy mejorando mi script de Org-Bash-Blog, con el que está montado este blog. 

Tras mucho darle vueltas, he pensado que la previsualización de los post, en lugar de hacerlo mediante archivos *.html*, abriendo el navegador remotamente instalado en mi Raspberry, que lo haga previsualizando en una imagen en formato jpg o png. 

Tenía que buscar un visualizador de imágenes muy liviano y buscando entre todas las opciones, me quedo con *fim*.

Fim es un visualizador que he usado hace un tiempo, pero ahora, a diferencia de antes, tenemos la ventaja que ya está en los repositorios oficiales. Voy a explicaros su instalación y un poco algunas de las opciones que tiene.

** Instalación
#+BEGIN_SRC 
sudo apt-get install fim
#+END_SRC
** Abrir Imagen

Abrir una imágen:

#+BEGIN_SRC 
fim imagen.jpg
#+END_SRC

Abrir la imagen con zoom automático:

#+BEGIN_SRC 
fim -a imagen.jpg
#+END_SRC

** Carpeta

Ver todas las imágenes de una carpeta:

#+BEGIN_SRC 
fim carpeta/
#+END_SRC

** Carpeta recursiva

Para abrir las imagenes de la carpeta y subcarpetaras recursivamente y despues ordenarlas:

#+BEGIN_SRC 
fim -R carpeta/ --sort
#+END_SRC

** En la Terminal
Ver una imágen renderizada en formato ASCII, desde la propia terminal:

#+BEGIN_SRC 
fim -t imagen.png
#+END_SRC

** Atajos
Algunos de los atajos disponibles:
#+BEGIN_SRC 
PageUp/Down : Prev/Next image
+/- : Zoom in/out
a : Autoscale
w : Fit to width
h : Fit to height
j/k : Pan down/up
f/m : flip/mirror
r/R : Rotate (Clock wise and ant-clock wise)
ESC/q : Quit
#+END_SRC
** Fuentes
- [[https://www.nongnu.org/fbi-improved/][nongnu]]
- [[https://www.ostechnix.com/how-to-display-images-in-the-terminal/][ostecgnix]]
- [[https://ubunlog.com/fim-ver-imagenes-terminal/][ubunlog]]
* TODO Backup de mis Notas de Paper Dropbox
:PROPERTIES:
:TITLE: Backup de mis Notas de Paper Dropbox
:EXPORT_FILE_NAME: Backup de mis Notas de Paper Dropbox
:DESCRIPTION: Sabéis que unos de los lugares donde habitualmente tomo notas en la nube de tutoriales interesantes que encuentro en la red
:EXPORT_DATE: 2019-09-01 21:25
:CATEGORY: notas
:TAG: raspberry
:IMAGE: ./images-blog/paper.png
:END:

Sabéis que unos de los lugares donde habitualmente tomo notas en la nube, de tutoriales interesantes que encuentro en la red, es [[https://paper.dropbox.com/][Paper Dropbox]]. Soy un amante del Software Libre, pero no hago ascos a soluciones geniales como esta, sean privativas o no.


#+HTML: <center>
[[./images-blog/paper.png]]
#+HTML: </center>


Lo que suelo hacer es copiar el contenido de un Post y después lo pego en Paper. Además, Paper es una solución genial para tener todas esas notas sincronizadas en todos mis dispositivos.

Pero los que me seguís frecuentemente, sabéis que no me gusta depender de servicios de terceros, donde pasado un tiempo puede dar el cierre y perder todo ese contenido que tengo almacenado en ese servicio. Así que hoy os traigo un complemento genial para descargar todas las notas que tengas en Paper Dropbox y exportarlas a markdown o html. 

[[https://github.com/efenka][Efenka]] publica en uno de sus repositorios una herramienta genial.

** Instalación
*** Clonar Repositorio 
Vamos a clonar el repositorio y después daremos permisos de ejecución al script en python
#+BEGIN_SRC 
git clone https://github.com/uGeek/dropbox-paper-backup.git
cd dropbox-paper-backup
chmod u+x dropbox-paper-backup.py
#+END_SRC
*** Instalando dependencias
#+BEGIN_SRC 
pip3 install -r requirements.txt
#+END_SRC
** Crea un destino para la copia de seguridad y solicita un token de autorización
Ejecuta el script
#+BEGIN_SRC 
./dropbox-paper-backup.py ~/carpeta_backup
#+END_SRC
Nos devolverá una url, donde podremos adquirir un token de Dropbox para poder utilizar la api.

Si guardas este token, en un futuro podrás saltarte este paso.

** Funcionamiento 

Comenzará la descarga de todos los documentos que tengamos en Paper Dropbox, en formato *.html* y *.md* a nuestra carpeta destino.

#+BEGIN_SRC 
./dropbox-paper-backup.py --token=<TOKEN> ~/carpeta_bakup
#+END_SRC

A mi personalmente me gusta más descargarlo solo en markdown, así que utilizo el siguiente comando:

#+BEGIN_SRC 
./dropbox-paper-backup.py --token=<TOKEN> -v  markdown ~/carpeta_bakup
#+END_SRC
* TODO Teamviewer en Ubuntu, Debian
:PROPERTIES:
:TITLE: Teamviewer en Ubuntu, Debian
:EXPORT_FILE_NAME: Teamviewer en Ubuntu Debian
:DESCRIPTION: Siempre hay el típico falimiar que te pide que le arregles algo que ha pasado en su PC
:EXPORT_DATE: 2019-09-08 13:29
:CATEGORY: escritorio
:TAG: ubuntu, debian, servidor, android
:IMAGE: ./images-blog/teamviewer.png
:END:

No todo el mundo utiliza Software Libre. Siempre hay el típico familiar que te pide que le arregles algo que ha pasado en su PC y tiene mítico Teamviewer. 


#+HTML: <center>
[[./images-blog/teamviewer.png]]
#+HTML: </center>


De salida, puede parecer imposible para nosotros, aquellos que utilizamos Linux, instalar Teamviewer. Instalando únicamente el archivo *.deb* , puede dar problemas la instalación, así que te explico como hacerlo.


** Instalación
Vamos a la [[https://www.teamviewer.com/es/descarga/linux/][Página de Teamviewer]], para descargar el archivo *.deb*. Lo descargaremos y lo instalaremos del siguiente modo:

#+BEGIN_SRC 
sudo dpkg -i teamviewer_14.5.5819_amd64.deb
#+END_SRC

Si lo ejecutas ahora, no funcionará, Teamviewer necesita algunas dependencias. Para que se instalen escribiremos en nuestra terminal:

#+BEGIN_SRC 
sudo apt install -f 
#+END_SRC
** Conclusión
Ya puedes disfrutar de Teamviewer en tu PC con Linux. Así de sencillo
* TODO AnyDesk en Ubuntu, Debian
:PROPERTIES:
:TITLE: AnyDesk en Ubuntu, Debian
:EXPORT_FILE_NAME: AnyDesk en Ubuntu Debian
:DESCRIPTION: Siempre hay el típico falimiar que te pide que le arregles algo que ha pasado en su PC
:EXPORT_DATE: 2019-09-08 18:07
:CATEGORY: escritorio
:TAG: ubuntu, debian, servidor, android
:IMAGE: ./images-blog/anydesk.png
:END:

Si os soy sincero, me gusta mas AnyDesk que Teamviewer. AnyDesk Software GmbH fue fundado en 2014 por ex empleados de TeamViewer. 


#+HTML: <center>
[[./images-blog/anydesk.png]]
#+HTML: </center>

El proceso de instalación de AnyDesk, es similar al de TeamViewer. Vamos a ver el proceso.
** Instalación
Vamos a la [[https://anydesk.com/es/downloads/linux][Página de AnyDesk]], para descargar el archivo *.deb*. Lo descargaremos y lo instalaremos del siguiente modo:

#+BEGIN_SRC 
sudo dpkg -i anydesk-5.1.2-amd64.deb
#+END_SRC

Si lo ejecutas ahora, no funcionará, AnyDesk necesita algunas dependencias. Para que se instalen escribiremos en nuestra terminal:

#+BEGIN_SRC 
sudo apt install -f 
#+END_SRC
** Conclusión
Ya puedes disfrutar de AnyDesk en tu PC con Linux. Así de sencillo
* TODO Docker: KodExplorer
:PROPERTIES:
:TITLE: Docker: KodExplorer
:EXPORT_FILE_NAME: Docker KodExplorer
:DESCRIPTION: KodExplorer es un servicio web, que nos permite navegar por carpetas, descargar o subir archivos, editar archivos de texto, visualizar videos o audios en streaming
:EXPORT_DATE: 2019-09-09 21:40
:CATEGORY: docker
:TAG: ssh, terminal, nas, servicios
:IMAGE: ./images-blog/kodexplorer.png
:END:

Ya os he hablado en más de una ocasión sobre KodExplorer. KodExplorer es un servicio web, que nos permite navegar por carpetas, descargar o subir archivos, editar archivos de texto, visualizar videos o audios en streaming,...  a través del navegador web. 

#+HTML: <center>
[[./images-blog/kodexplorer.png]]
#+HTML: </center>


En esta versión del docker, podemos enlazar en la sesión de administrador, con una de las carpetas de nuestro servidor, Raspberry,... La ruta de esta carpeta la tienes que introducir donde aparece *<RUTA>*. Yo he montado una nube cifrada que tengo mediante rclone, de esta manera me permite subir y bajar archivos a la nube remotamente, desde el navegador web.

Puedes [[http://demo.kodcloud.com/index.php?user/login][ver una demo aquí]].


** Montar Docker
*** Montar Docker para Raspberry Pi o ARM 32bits
#+BEGIN_SRC 
docker run -d -p 80:80 --name kodexplorer -v $HOME/docker/kodexplorer:/var/www/html -v <RUTA>:/var/www/html/data/User/admin/home ugeek/kodexplorer:arm
#+END_SRC

*** Montar Docker para amd64
#+BEGIN_SRC 
docker run -d -p 80:80 --name kodexplorer -v $HOME/docker/kodexplorer:/var/www/html -v <RUTA>:/var/www/html/data/User/admin/home ugeek/kodexplorer:amd64
#+END_SRC
** Funcionamiento
La primera vez que iniciamos KodExplorer, nos pedirá que introduzcamos dos veces la contraseña de la cuenta *admin*, que va a ser la que vamos a utilizar para enlazar con nuestra carpeta local en la *<RUTA>*.

Tras iniciar el servicio, KodExplorer nos pedirá que actualicemos, ya que hay una versión más actualizada no disponible actualmente en GitHub. Le daremos a actualizar.

Listo!!!! Ya tenemos nuestro KodExplorer totalmente funcional y actualizado a la última
** Fuentes

- [[https://github.com/kalcaddle/KodExplorer][Repositorio en GitHub]]
- [[https://cloud.docker.com/u/ugeek/repository/docker/ugeek/kodexplorer][Docker en DockerHub]]
* TODO Convertir de H.265 a H.264
:PROPERTIES:
:TITLE: Convertir de H.265 a H.264
:EXPORT_FILE_NAME: Convertir de H265 a H264
:DESCRIPTION: Hay dispositivos, como la primera versión del Fire TV Stick de Amazon,  que no reproducen videos en H.265
:EXPORT_DATE: 2019-09-11 18:00
:CATEGORY: ffmpeg
:TAG: video
:IMAGE: ./images-blog/ffmpeg.png
:END:

Hay dispositivos, como la primera versión del Fire TV Stick de Amazon,  que no reproducen videos en H.265. Para poder reproducirlos, tenemos que transcodificarlos a H.264. Vamos a ver este método interesante que he encontrado en [[https://askubuntu.com/questions/707397/batch-convert-h-265-mkv-to-h-264-with-ffmpeg-to-make-files-compatible-for-re-enc][https://askubuntu.com]].

#+HTML: <center>
[[./images-blog/ffmpeg.png]]
#+HTML: </center>

** Transcodificando todos los archivos a H.264

Nos situamos en la carpeta donde están los videos a convertir, y dentro de esta crearemos una carpeta llamada h264vids, donde irán los vídeos transcodificados:
#+BEGIN_SRC 
mkdir h264vids
#+END_SRC
Ahora ejecutamos esta línea y todos los vídeos se transcodificaran a H.264, quedando dentro de la carpeta h264vids.

Este ejemplo supone que sus entradas son .mp4, por ejemplo fueran .mkv, modifícalo en la línea 
#+BEGIN_SRC 
for f in *.mp4; do ffmpeg -i "$f" -map 0 -c copy -c:v libx264 -crf 23 -preset medium h264vids/"${f%.*}.mkv"; done
#+END_SRC

Ajusta *-crf* por calidad y *-preset* por velocidad/eficiencia de codificación, o simplemente elimina estas opciones y utiliza los valores predeterminados. Las opciones disponibles las tienes en [[https://trac.ffmpeg.org/wiki/Encode/H.264][la documentación de ffmpeg]].

** MKV H.265 a MP4 H.264
Siguiendo el ejemplo anterior, este script que dejaremos en la carpeta donde están los videos, nos transcodificará los videos a H.264, pero esta vez con el formato de salida *.mp4* 
#+BEGIN_SRC 
#!/bin/bash

audioformat=$(ffprobe -loglevel error -select_streams a:0 -show_entries stream=codec_name -of default=nw=1:nk=1 "$f")

mkdir h264vids

for f in *.mkv
do
  if [ "$audioformat" = "aac" ]; then
    ffmpeg -i "$f" -c:v libx264 -crf 23 -preset medium -c:a copy -movflags +faststart h264vids/"${f%.*}.mp4"
  else
    ffmpeg -i "$f" -c:v libx264 -crf 23 -preset medium -c:a aac -movflags +faststart h264vids/"${f%.*}.mp4"
  fi
done
#+END_SRC

Puedes pausar la codificación con =ctrl+ z= y reanudar con =fg=.

** Fuente
- https://askubuntu.com/questions/707397/batch-convert-h-265-mkv-to-h-264-with-ffmpeg-to-make-files-compatible-for-re-enc
* TODO Listado de Servicios con System V y Systemd
:PROPERTIES:
:TITLE: Listado de Servicios con System V y Systemd
:EXPORT_FILE_NAME: Listado de Servicios con System V y Systemd
:DESCRIPTION: Buscaba el modo de comprobar los servicios que tengo corriendo y he llegado
:EXPORT_DATE: 2019-09-16 17:55
:CATEGORY: servidor
:TAG: ssh, terminal
:IMAGE: 
:END:

Buscaba el modo de comprobar los servicios que tengo corriendo y he llegado al [[https://www.jesusamieiro.com/como-comprobar-que-servicios-estan-en-ejecucion-en-un-sistema-linux/][Blog de Jesus Mieiro]], donde explica con System V y Systemd, como obtener esta información.

Gracias una vez más, nuestro amigo Grep, toda esta información la podemos filtrar accediendo exactamente al servicio que nos interesa.


** Basado en System V

*** Comprobar el estado de los servicios
#+BEGIN_SRC 
sudo service --status-all
#+END_SRC
*** Filtrar los servicios corriendo
#+BEGIN_SRC 
sudo service --status-all | grep +
#+END_SRC
** Si el sistema esta está Systemd

*** Estado de todos los servicios
#+BEGIN_SRC 
sudo systemctl list-unit-files
#+END_SRC
*** Para filtrar los servicios corriendo
#+BEGIN_SRC 
sudo systemctl list-unit-files | grep enabled
sudo systemctl list-unit-files --state=enabled
#+END_SRC

*** Ver el estado de docker

Vamos a ver, por ejemplo, el estado del servicio docker.
#+BEGIN_SRC 
sudo systemctl list-unit-files | grep docker
#+END_SRC
Si quisiéramos filtrarlo todavía mas, podríamos utilizar *cut*.

#+BEGIN_SRC 
sudo systemctl list-unit-files | grep docker.service | cut -d " " -f2-
#+END_SRC

* TODO Instala Telegram Desktop y Rclone Browser en una Raspberry Pi o Servidor
:PROPERTIES:
:TITLE: Instalar Telegram Desktop y Rclone Browser en una Raspberry Pi o Servidor
:EXPORT_FILE_NAME: Instalar Telegram Desktop y Rclone Browser
:DESCRIPTION: Gracias a al nueva actualización de debian buster, podemos hacer cosas maravillosas, como instalar telegram-desktop en nuestra Raspberry o Servidor remoto y ejecutarlas en tu escritorio
:EXPORT_DATE: 2019-09-17 5:15
:CATEGORY: telegram
:TAG: ssh, raspberry
:IMAGE: ./images-blog/telegram-desktop.png
:END:

Gracias a al nueva actualización de debian buster, podemos hacer cosas maravillosas, como instalar Telegram Desktop o Rclone-Browser en nuestra Raspberry o Servidor remoto y ejecutarlas en tu escritorio, como si fuera una aplicación nativa de tu PC, pero descargando el contenido de Telegram o Rclone en tu Raspberry o Servidor.

En el caso de Telegram, está genial para todo aquel que desea descargar intercambiar archivos entre dispositivos, o descargar archivos que tengas en Telegram, en un canal privado que utilices de nube, o subir archivos a este canal privado.

Si utilizas Rclone, también podríamos utilizar Rclone-Browser para intercambiar el contenido de tu nube en Telegram con el resto de nubes.
 

#+HTML: <center height="50">
[[./images-blog/telegram-desktop.png]]
#+HTML: </center>


Todo esto lo vamos ha hacer posible gracias a x11. En Linux podemos utilizarlo en cualquier distro. Si utilizas Windows o Mac, tendrás que instalar un programa para poder utilizarlo.

X11 es un servidor gráfico que nos permite el exportar el display de un servidor remoto a nuestro escritorio local. De manera que podremos visualizar aplicaciones gráficas del servidor en nuestro escritorio. Lo que se conoce como forwarding a través de SSH.



** Instalación de Telegram Desktop
Telegram Desktop la instalaremos en nuestra Raspberry o Servidor, del mismo modo que en nuestro escritorio Linux. Abriremos la terminal de nuestra Raspberry y escribiremos:
#+BEGIN_SRC 
sudo apt install telegram-desktop
#+END_SRC

** Instalando Rclone-Browser
También podemos instalar Rclone Browser, para gestionar nuestras nubes de un modo gráfico
#+BEGIN_SRC 
sudo apt install rclone-browser
#+END_SRC
** Conexión desde tu escritorio Linux a Telegram Desktop
Nos conectamos vía ssh añadiendo el flag *-X* y se nos abrirá la aplicación de Telegram con interfaz gráfica en nuestro PC.

Sustituye tu nombre de usuario por *angel* y tu *ip* por la ip de tu Raspberry o servidor.
#+BEGIN_SRC 
ssh -X angel@192.168.1.100 telegram-desktop
#+END_SRC
Yo, una vez más, os recomendaría crear un alias para arrancar desde tu PC, el Telegram remoto de tu Raspberry.

Ejemplo:

#+BEGIN_SRC 
alias telegram-pi='ssh -X angel@192.168.1.100 telegram-desktop'
#+END_SRC


** Conexión a Rclone Browser
Del mismo modo, haremos lo propio para abrir Rclone Browser y si lo deseamos, crear un alias.
#+BEGIN_SRC 
ssh -X angel@192.168.1.100 rclone-browser
#+END_SRC
* TODO Emacs siempre a la última versión, betas, edge... gracias a Snap
:PROPERTIES:
:TITLE: Emacs siempre a la última versión, betas, edge... gracias a Snap
:EXPORT_FILE_NAME: Emacs siempre a la ultima versión betas edge gracias a Snap
:DESCRIPTION:
:EXPORT_DATE: 2019-09-18 17:55
:CATEGORY: emacs
:TAG: emacs, snap
:IMAGE: ./images-blog/emacs.png
:END:

Los que utilizamos ubuntu o debian, nos encontramos con el problema de no tener a la última la versión de emacs en los repositorios. 

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

En ubuntu podemos instalar [[https://ugeek.github.io/blog/post/2019-07-22-emacs-26-2-en-ubuntu.html][la última versión desde PPA, tal como os expliqué en este Post]], en cambio en debian tendríamos que compilar la aplicación. Si no quieres complicarte la vida e instalarlo de un modo limpio, desde la versión 26.2, Alex Murray ha creado un paquete snap para poder tener no solo la últimisima versión de emacs, sino que también las versiones beta, edge. 

Emacs por snap se integra perfectamente con aplicaciones instaladas en el propio sistema, como el corrector ortográfico, w3m,... así que no afecta al correcto funcionamiento. Podrás ejecutar tanto la versión gráfica como la versión de terminal.

** Instalación

Si ya tienes snap instalado, es tan simple como escribir en tu terminal, para instalar la última versión estable:

#+BEGIN_SRC 
sudo snap install emacs --classic
#+END_SRC

El quieres probar resto de versiones en desarrollo, puedes instalarlo de la siguiente manera.

#+BEGIN_SRC 
# Versión candidate
sudo snap install emacs --candidate --classic

# Versión beta
sudo snap install emacs --beta --classic

Versión edge
sudo snap install emacs --edge --classic
#+END_SRC

** Convivir emacs de repositorios con snap

*** Emacs de repositorios
Para poder ejecutar versión de emacs instalada desde los repositorios oficiales, escribiremos en la terminal:

#+BEGIN_SRC 
emacs
#+END_SRC
o si queremos especificar la ruta completa:
#+BEGIN_SRC 
/usr/bin/emacs
#+END_SRC
*** Emacs por snap
En cambio, para ejecutar la versión para snap, escribiremos en la terminal:
#+BEGIN_SRC 
/snap/bin/emacs
#+END_SRC

Si quieres utilizar la versión para terminal:
#+BEGIN_SRC 
/snap/bin/emacs -nw
#+END_SRC

El contenido de la aplicación, está instalado en:
#+BEGIN_SRC 
/snap/emacs/
#+END_SRC
** Sustituir la versión del sistema por la de snap
Si lo que quieres es que cuando pongas emacs, arranque directamente la versión de snap, para hacerlo de un modo sencillo te recomiento que crees un alias.

Ejemplo: 

- Si tienes bash
#+BEGIN_SRC 
nano ~/.bashrc
#+END_SRC
- Si tienes zsh
#+BEGIN_SRC 
nano ~/.zshrc
#+END_SRC
y añadiremos
#+BEGIN_SRC 
alias emacs='/snap/bin/emacs'
#+END_SRC


** Conclusión
Como ves, instalar emacs a la última gracias a snap es súper sencillo y te evitas quebraderos de cabeza. Es cierto que los paquetes snap a veces arrancan unos segundos mas lentos, pero es el precio que hay que pagar.

** Fuentes
- https://snapcraft.io/emacs
* TODO Exportando a CSV desde Microsoft Excel Online, Hojas de cálculo de Google, etc
:PROPERTIES:
:TITLE: Exportando a CSV desde Microsoft Excel Online, Hojas de cálculo de Google, etc
:EXPORT_FILE_NAME: Exportando a CSV desde Excel Online
:DESCRIPTION: Exportando a CSV desde Microsoft Excel Online, Hojas de cálculo de Google, etc
:EXPORT_DATE: 2019-09-21 14:12
:CATEGORY: bash
:TAG: terminal
:IMAGE: ./images-blog/excel.png
:END:


Quería trabajar con unos excels de Microsoft Excel Online que me habían compartido y quería integrarlos en un script en bash que he hecho para hacer unos cálculos. 
El script que he hecho funciona a partir de una archivo *.csv*, así que necesitaba exportar esas Hojas de cálculo a este formato. 

#+HTML: <center>
[[./images-blog/excel.png]]
#+HTML: </center>

Hojas de cálculo de Google, permite exportar las hojas a muchos formatos, entre ellos a *.csv*, digamos en cierto modo, es mucho mas abierto. Microsoft Excel Online, aunque ya permite exportar a *.ods*, solo permite a este formato y *.xlsx*. 

Se que hay modos de convertir un archivo a *csv*, abriendo con LibreOffice y exportándolo. También se que puedo hacerlo ejecutándolo en segundo plano desde la terminal. Hay otros programas y conversores. *Ninguno de los métodos* deja el *csv* 100% limpio, columnas separadas únicamente por comas.


Me dió por hacer una prueba. Copiar el contenido de la tabla, que veo en la página web y pegarlo en un editor de texto. Al ver ese contenido desordenado en el editor, hizo que mentalmente mi cerebro corriera *bash* en segundo plano y con *bash* solucioné el problema.

** Bash es la solución
Con este simple comando, dejé el contenido copiado de la página web con el ratón, en un perfecto archivo *.csv*
El contenido de la página está en el *archivo.txt*

#+begin_src 
cat archivo.txt | sed "s/,/./g" | sed "s/\t/,/g" | sed "/^ *$/d"
#+end_src
Explicación:
- =cat= *-->*             Visualiza el archivo de texto
- =sed "s/,/./g"= *-->*    El archivo tenía números decimales que se podría confundir con las "comas" del csv, así que convierto las comas a puntos.
- =sed "s/\t/,/g"= *-->*  La separación de columnas es superior a dos espacios, así que son un tabulado. Convierte los tabulados en comas
- =sed "/^ *$/d"= *-->*    Cada fila, queda representada por una línea en blanco. Sed eliminará las líneas

*** Exportar a cav
Exportamos a archivo.csv el resultado filtrado por el comando

#+begin_src 
cat archivo.txt | sed "s/,/./g" | sed "s/\t/,/g" | sed "/^ *$/d" > archivo.csv
#+end_src

** Conclusión
Como ves, una archivo que tenía que pasar por 2 programas y al final, tener que editarlo a mano para poder arreglar las comas del csv, bash me lo ha solucionado con una única línea de teminal.

* TODO Comando para saber los dockers corriendo y sus puertos
:PROPERTIES:
:TITLE: Comando para saber los dockers corriendo y sus puertos
:EXPORT_FILE_NAME: Comando para saber los dockers corriendo y sus puertos
:DESCRIPTION: Tengo tantos contenedores corriendo, que muchas veces no recuerdo los contenedores que están corriendo ni los puertos que asigne en su día a cada contenedor.
:EXPORT_DATE: 2019-09-23 17:55
:CATEGORY: docker
:TAG: bash,terminal
:IMAGE: ./images-blog/docker.png
:END:


Tengo tantos contenedores corriendo, que muchas veces no recuerdo los contenedores que están corriendo ni los puertos que asigne en su día a cada contenedor.

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

En mi servidor he creado mediante alias un nuevo comando llamado dockers, que soluciona a este problema.

** Comando
Vamos a editar el archivo .bashrc si tienes bash o .zshrc si tienes zsh.

=nano .bashrc= o =nano .zshrc=.

Y añadiremos la siguiente línea:
#+BEGIN_SRC 
alias dockers="docker ps --format 'table {{.Names}}\t{{.Ports}}' |  sed 's|NAMES||g' |  sed 's|PORTS||g' | sort"
#+END_SRC
Lo que hace este comando es hacer un =docker ps=, filtrando las columnas de nombres y puertos.

*Reiniciamos la terminal*
** Ejecutando el comando
Ahora, cada vez que introduzcamos el comando *dockers*, la terminal nos devolverá todos los contenedores que estén corriendo en ese momento, ordenados por orden alfabético y los puertos que tienen asignados.

En mi caso la terminal me devuelve:
#+BEGIN_SRC 
letsencrypt         0.0.0.0:80->80/tcp, 0.0.0.0:443->443/tcp
mariadb             0.0.0.0:3306->3306/tcp
nextcloud           80/tcp, 0.0.0.0:82->443/tcp
tt-rss              443/tcp, 0.0.0.0:81->80/tcp
#+END_SRC
** Conclusión
Una vez más, un comando en bash nos hace la vida más fácil.
 
 
* TODO Donde está el comando ifconfig y como instalarlo
:PROPERTIES:
:TITLE: Donde está el comando ifconfig y como instalarlo
:EXPORT_FILE_NAME: Donde está el comando ifconfig y como instalarlo
:DESCRIPTION: El comando ifconfig ha quedado en desuso y ya no está disponible en los repositorios de las versiones de Debian, Raspbian,...
:EXPORT_DATE: 2019-09-25 19:18
:CATEGORY: bash
:TAG: debian,raspbian,ubuntu
:IMAGE: ./images-blog/bash.jpg
:END:

El comando ifconfig ha quedado en desuso y ya no está disponible en los repositorios de las versiones de Debian, Raspbian,...

#+HTML: <center>
[[./images-blog/bash.jpg]]
#+HTML: </center>


Ahora para examinar la configuración de red de nuestra Debian, utilizaremos el comando *ip*.

** Uso
Para examinar la configuración de red de nuestra Debian, utilizaremos el siguiente comando:
#+BEGIN_SRC 
ip address
#+END_SRC
Más fácil de recordar:
#+BEGIN_SRC 
ip a
#+END_SRC
** Ayuda
Más opciones del comando *ip*
#+BEGIN_SRC 
ip help
#+END_SRC
* TODO Extraer audio de un vídeo con ffmpeg
:PROPERTIES:
:TITLE: Extraer audio de un vídeo con ffmpeg
:EXPORT_FILE_NAME: Extraer audio de un vídeo con ffmpeg
:DESCRIPTION: Con ffmpeg, no solo podemos transcodificar vídeo, sino también extraer el audio.
:EXPORT_DATE: 2019-09-30 18:15
:CATEGORY: bash
:TAG: video,terminal
:IMAGE: ./images-blog/ffmpeg.png
:END:

Con ffmpeg, no solo podemos transcodificar vídeo, sino también extraer el audio.

#+HTML: <center>
[[./images-blog/ffmpeg.png]]
#+HTML: </center>

La extracción con ffmpeg es muy sencilla.
#+BEGIN_SRC 
ffmpeg -i [VIDEO ENTRADA] [AUDIO SALIDA]
#+END_SRC

** Extracción de audio básica
La opción *-i*, indica el archivo de entrada.

*-vn*, indica que no procese el archivo para una trasncodificación, que lo deje tal cual. 
*--acodec copy*, indica que no procese y solo copie el audio de entrada en la salida. El archivo con el que esta grabado el audio del vídeo, tiene que ser el que utilicemos en la salida, sino, tendríamos que transcodificarlo

#+BEGIN_SRC 
ffmpeg -i video_entrada.mp4 -vn -acodec copy audio_salida.mp3
#+END_SRC

** Extraer audio como mp3 o aac
*-acodec mp3*, especificamos que utilice el codec para transcodifique a mp3 
#+BEGIN_SRC 
ffmpeg -i video_entrada.mp4 -vn -acodec mp3 audio_salida.mp3
#+END_SRC
*--acodec aac*, especificamos que utilice el codec para transcodifique a aac

** Extraer como vorbis. ogg
#+BEGIN_SRC 
ffmpeg -i video_entrada.mp4 -vn -acodec libvorbis audio_salida.ogg
#+END_SRC
*-acodec libvorbis*, especificamos que utilice el codec para transcodifique ogg.
** Extraer audio de un trozo del vídeo

#+BEGIN_SRC 
ffmpeg -i video_entrada.avi -ss 30 -to 60 -vn -acodec mp3 audio_salida.mp3
#+END_SRC
*-ss 30 -to 60*, especifiamos que extraermos el audio, solo del segundo *30* a *60*.

** Fuente
- [[https://www.bugcodemaster.com/article/extract-audio-video-using-ffmpeg][BugCodeMaster]]
* TODO Docker: Wallabag
:PROPERTIES:
:TITLE: Docker: Wallabag
:EXPORT_FILE_NAME: Docker: Wallabag
:DESCRIPTION: Os hable de Wallabag en el Podcast, cuando estaba en la primera versión. Al pasar a la segunda versión, todo cambió. La interfaz mejoró muchísimo, más moderna, más opciones,... pero
:EXPORT_DATE: 2019-10-01 5:15 2020-05-23
:CATEGORY: docker
:TAG: ubuntu, debian, nas, raspberry,wallabag
:IMAGE: ./images-blog/wallabag.png
:END:

Os hable de Wallabag en el Podcast, cuando estaba en la primera versión. Al pasar a la segunda versión, todo cambió. La interfaz mejoró muchísimo, más moderna, más opciones,... pero dejó de funcionar para Raspberry. 

#+HTML: <center>
[[./images-blog/wallabag.png]]
#+HTML: </center>

Ha pasado el tiempo y ahora que estoy liado con la creación de Dockers, así que decidí el intentarlo una vez más y esta vez con éxito.

** Montando el Docker
Al montar el Docker siguiendo la documentación, se monta pero, pero no aparece del modo correcto, es como que faltan las hojas de estílo. Es muy importante para solucionar esto el añadir la ruta ip de nuestro servidor al montar el docker:

Ejemplo. Si fuera la ip 192.168.1.100:
#+BEGIN_SRC 
SYMFONY__ENV__DOMAIN_NAME=http://192.168.1.100
#+END_SRC
** Wallabag para ARM o Raspberry Pi
#+BEGIN_SRC 
docker create --name wallabag  \
  -p 80:80 \
  -v $HOME/docker/wallabag/data:/var/www/wallabag/data \
  -v $HOME/docker/wallabag/images:/var/www/wallabag/web/assets/images \
  -e SYMFONY__ENV__DOMAIN_NAME=http://192.168.1.100:80 \
  ugeek/wallabag:arm 
#+END_SRC

** Wallabag docker oficial amd64
#+BEGIN_SRC 
docker create --name wallabag  \
  -p 80:80 \
  -v $HOME/docker/wallabag/data:/var/www/wallabag/data \
  -v $HOME/docker/wallabag/images:/var/www/wallabag/web/assets/images \
  -e SYMFONY__ENV__DOMAIN_NAME=http://192.168.1.100:80 \
wallabag/wallabag
#+END_SRC
** Wallabar para i386

#+BEGIN_SRC 
docker run --name wallabag  -p 80:80 -e SYMFONY__ENV__DOMAIN_NAME=http://192.168.1.100 ugeek/wallabag:i386
#+END_SRC

* TODO Acceder dentro de un Docker como usuario root
:PROPERTIES:
:TITLE: Acceder dentro de un Docker como usuario root
:EXPORT_FILE_NAME: Acceder dentro de un Docker como usuario root
:DESCRIPTION: Vamos a acceder a un contenedor como usuario root
:EXPORT_DATE: 2019-10-04 17:55
:CATEGORY: docker
:TAG: bash,terminal,root
:IMAGE: ./images-blog/docker.png
:END:

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

Vamos a acceder a un contenedor como usuario *root*. Para ello tenemos que utilizar la opción *-u* seguido del usuario, en este caso *root*.
Por ejemplo, para acceder dentro de un contenedor llamado nextcloud, utilizaríamos:

#+BEGIN_SRC 
docker exec -it -u root nextcloud /bin/bash
#+END_SRC
 
 
 
* TODO Docker: Supysonic. El mejor y más ligero servidor de música
:PROPERTIES:
:TITLE: Docker: Supysonic. El mejor y más ligero servidor de música
:EXPORT_FILE_NAME: Docker: Supysonic. El mejor y más ligero servidor de música
:DESCRIPTION: Algo que he estado buscando desde que empecé a instalar mis propios servicios, es un servidor de música tipo [[https://www.spotify.com][Spotify]].
:EXPORT_DATE: 2019-10-07 18:00
:CATEGORY: docker
:TAG: musica,raspberry,servidor,jamstash,supysonic
:IMAGE: ./images-blog/subsonic.png
:END:

Algo que he estado buscando desde que empecé a instalar mis propios servicios, es un servidor de música tipo [[https://www.spotify.com][Spotify]].

#+HTML: <center>
[[./images-blog/subsonic.png]]
#+HTML: </center>

He utilizado servidores como *Plex*, *Jellyfin*, *DLNA*,... Pero aunque todos ellos engloban todo el tema multimedia, buscaba algo más ligero y que únicamente fuera un servidor de música.

De todos los que he utilizado, el que más me gustó fue [[http://www.subsonic.org][Subsonic]]. Subsonic tiene una cuata mensual de 1€ al mes, así que aparecieron nuevos Forks gratuitos y 100% Software Libre como Libresonic, Airsonic,... 

Todos ellos tienen un problema y es que están desarrollados en *java*. Eso significa que si quieres correr este servicio en tu Raspberry, va a devorar tu Ram.

Para solucionar este problema y para satisfacer a los amantes de este servidor y clientes de Subsonic, nació Supysonic. Un servidor de música desarrollado en *python* que utiliza la api de subsonic, de manera que podremos utilizar los clientes igual que lo hacemos con Subsonic.

He creado el Docker para que sea más simple la instalación y lo he guardado en mi repositorio del [[https://hub.docker.com/r/ugeek/supysonic][DockerHub]].

** Docker
Vamos a montar el docker dependiendo de la arquitectura que utilices.

La carpeta =/media=, es la carpeta donde pondremos la música. Personalízalo a tu gusto.

*** Raspberry and ARM

**** Versión 0.4.1
#+BEGIN_SRC 
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:arm-0.4.1
#+END_SRC
**** Versión 0.4
#+BEGIN_SRC 
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:arm
#+END_SRC
*** amd64

**** Versión 0.4.1
#+BEGIN_SRC 
docker run --name supysonic -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:amd64-0.4.1
#+END_SRC
**** Versión 0.4
#+BEGIN_SRC 
docker run --name supysonic -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:amd64
#+END_SRC
*** i386
**** Versión 0.4.1
#+BEGIN_SRC 
docker run --name supysonic -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:i386-0.4.1
#+END_SRC

** Iniciar Servidor
Vamos a iniciar el servidor
#+BEGIN_SRC 
docker start supysonic
#+END_SRC
Si abres tu navegador e introduces la ip:8080, aparecerá la página de administración de supysonic. Ahora no podrás acceder porque no tienes el usuario y contraseña de administración. Vamos a crearlo.

** Crear usuario y contraseña de administrador
Ahora entraremos dentro del contenedor para crear el usuario administrador y contraseña.
#+BEGIN_SRC 
docker exec -it supysonic sh
#+END_SRC
Vamos a crear el el usuario y contraseña
#+BEGIN_SRC 
supysonic-cli user add "NOMBRE ADMINISTRADOR" -a -p "CONTRASEÑA"
#+END_SRC
** Añadir carpeta con tu música utilizando el navegador web

Ya podemos utilizar la página de administración desde tu navegador, introduce la dirección http://tu_ip:8080

De todas maneras, si utilizas la terminal verás que es más practico.
** Añadir carpeta con tu música utilizando la Terminal 
Entramos al contenedor
#+BEGIN_SRC 
docker exec -it supysonic sh
#+END_SRC
Creamos una nueva biblioteca indicando la capeta:
#+BEGIN_SRC 
supysonic-cli folder add "NOMBRE BIBLIOTECA" /media/musica
#+END_SRC

Ejemplo: Hay una biblioteca de música que tengo y llamo *Favoritos*. Voy a crear la biblioteca e indicar la ruta de la carpeta
#+BEGIN_SRC 
supysonic-cli folder add Favoritos /media/Favoritos/
#+END_SRC
*** Sin entrar al contenedor
Podría haber utilizado este comando sin entrar dentro del contenedor
#+BEGIN_SRC 
docker exec -it supysonic supysonic-cli folder add Favoritos /media/Favoritos/
#+END_SRC

** Escanear tu música
Entramos al contenedor
#+BEGIN_SRC 
docker exec -it supysonic sh
#+END_SRC
Una vez añadida tu música, necesitas escanearla para que se añada al servidor.
#+BEGIN_SRC 
supysonic-cli folder scan "NOMBRE BIBLIOTECA"
#+END_SRC

*** Escanear sin entrar al contenedor
Escanea mediante una única línea. Puedes utilizar *cron*, para escanear periódicamente tu biblioteca
#+BEGIN_SRC 
docker exec -it supysonic supysonic-cli folder scan "NOMBRE BIBLIOTECA"
#+END_SRC
Mi biblioteca *Favoritos* la escaneo así:
#+BEGIN_SRC 
docker exec -it supysonic supysonic-cli folder scan Favoritos
#+END_SRC
 
** Clientes
Para poder escuchar tu música, puedes utilizar clientes de Android como [[https://play.google.com/store/apps/details?id=github.daneren2005.dsub][DSub]] o [[https://play.google.com/store/apps/details?id=org.moire.ultrasonic][Ultrasonic]]. 

Uno de los defectos que tiene Supysonic, es no tener reproductor web integrado en el servidor. Así que si queremos utilizarlo mediante un navegador web podemos utilizar [[http://jamstash.com/#/settings][Jamstash]]. En el próximo artículo explicaré como montar el Docker de este servicio en tu servidor.
** Fuentes
- https://github.com/spl0k/supysonic
- https://hub.docker.com/r/ugeek/supysonic
- https://github.com/uGeek/docker-supysonic

* TODO Docker: Jamstash. Cliente de Subsonic, Supysonic, Airsonic
:PROPERTIES:
:TITLE: Docker: Jamstash. Cliente de Subsonic, Supysonic, Airsonic
:EXPORT_FILE_NAME: Docker Jamstash Cliente de Subsonic
:DESCRIPTION: Si tienes el servidor de música *Supysonic*, Subsonic, Airsonic,... Cualquiera de los servidores que utilizan la api de *Subsonic*, quizás quieras utilizar el navegador web como cliente.
:EXPORT_DATE: 2019-10-08 18:00
:CATEGORY: docker
:TAG: raspberry,servidor,jamstash,subsonic
:IMAGE: ./images-blog/jamstash.png
:END:

Si tienes el servidor de música *Supysonic*, Subsonic, Airsonic,... Cualquiera de los servidores que utilizan la api de *Subsonic*, quizás quieras utilizar el navegador web como cliente.

Jamstash es un proyecto que pretende el tener un cliente de Subsonic en tu navegador web, instalable en Google Chrome [[https://chrome.google.com/webstore/detail/jamstash/jccdpflnecheidefpofmlblgebobbloc][a través de su tienda de aplicaciones]].

#+HTML: <center>
[[./images-blog/jamstash.png]]
#+HTML: </center>

Aprovechando el código de la aplicación disponible en GitHub, he montado un contenedor partiendo de un Alpine Linux y un servidor de Nginx. 

Este cliente permite el reproducir, crear listas, añadir a favoritos, descargar canciones, etc...

#+HTML: <center>
[[./images-blog/jamstash2.png]]
#+HTML: </center>

Vamos a ver como montar el contenedor

** Docker para Raspberry o ARM
#+BEGIN_SRC 
docker run --name jamstash -d -p 80:80 ugeek/jamstash:arm
#+END_SRC
** Docker para amd64
#+BEGIN_SRC 
docker run --name jamstash -d -p 80:80 ugeek/jamstash:amd64
#+END_SRC
** Uso de Jamstash
Para utilizar el cliente Jamstash, según la línea del ejemplo anterior, corre por el puesto *80*. Podemos personalizar el puerto cambiando a un puerto libre disponible.

Aquí utilizariamos el puerto 90.
#+BEGIN_SRC 
-p 90:80
#+END_SRC

Siguiendo este nuevo ejemplo, nos conectaríamos desde nuestro navegador web a http://tu_ip:90

** Fuentes
- http://jamstash.com
- https://github.com/tsquillario/Jamstash
- https://github.com/uGeek/docker-jamstash
- https://chrome.google.com/webstore/detail/jamstash/jccdpflnecheidefpofmlblgebobbloc



* TODO Docker: Duck DNS. Facilitando la conexión a tus servicios
:PROPERTIES:
:TITLE: Docker: Duck DNS. Facilitando la conexión a tus servicios
:EXPORT_FILE_NAME: docker-duck-dns-facilitando-la-conexion-a-tus-servicios
:DESCRIPTION: La mayor parte de la gente, tiene una conexión a internet con ip dinámica
:EXPORT_DATE: 2019-10-09 18:00
:CATEGORY: docker
:TAG: servidor,dns,duckdns
:IMAGE: ./images-blog/duckdns.png
:END:

La mayor parte de la gente, tiene una conexión a internet con ip dinámica. Esto quiere decir, que la dirección ip va cambiando de tanto en tanto. No es fija.

#+HTML: <center>
[[./images-blog/duckdns.png]]
#+HTML: </center>

Esto puede ser un gran problema si queremos conectarnos desde fuera de nuestra red, a un servicio que tenemos en nuestro servidor. Si la compañía cambia la ip en ese momento, nunca encontraremos nuestro servidor. Para solucionar este problema podemos utilizar servicios DNS como Duck DNS.

Tal como expliqué en el artículo del [[https://ugeek.github.io/blog/post/2019-05-15-accediendo-a-todos-mis-servicios-desde-cualquier-lugar-sin-vpn.html][Docker de Letsencript]], podemos crear una cuenta con un dominio o hasta 5 de forma gratuita y ejecutando un script en nuestro servidor, *en nuestra red local*, este script enviará cual es nuestra ip a Duck DNS, para que cada vez que introduzcamos el dominio que registramos en Duck DNS, redirija el tráfico hasta nuestra casa.

Yo finalmente por comodidad, he montado un docker de la comunidad LinuxServer que incluye este script. De esta manera solo tengo que programar en que momento del día quiero que se inicie este docker y él se encargará de enviar esta información.  

** Docker Duck DNS
Este es un ejemplo de como montar el docker. Tienes que sustituir *SUBDOMAINS*, en este ejemplo correspondería con la dirección ugeekpodcast.duckdns.org y angel.duckdns.org, el *TOKEN* aparece en la página de Duck DNS y *TZ* corresponde con la hora local del lugar donde vivas.
#+BEGIN_SRC 
docker create \
  --name=duckdns \
  -e PGID=1000 -e PUID=1000  \
  -e SUBDOMAINS=ugeekpodcast,angel \
  -e TOKEN=adbqergh-av7654qwerg-qerg456-45qrg \
  -e TZ=Europe/Madrid \
  lsioarmhf/duckdns
#+END_SRC

*Es un Token de ejemplo falso*

El script se ejecuta cada 5 minutos y envía nuesta IP a los servidores de Duck DNS.
** Cambiar la periocidad de ejecución
Para cambiar el tiempo de ejecución del script y que no sea cada 5 minutos, lo haremos de la siguiente manera:

Entraremos dentro del contenedor
#+BEGIN_SRC 
docker exec -it duckdns /bin/bash
#+END_SRC

Editamos cron
#+BEGIN_SRC 
crontab -e -u abc
#+END_SRC

En mi caso, voy ha hacer que se ejecute cada 30 minutos
#+BEGIN_SRC 
*/30 * * * * /app/duck.sh 2>&1
#+END_SRC

** Ver que todo va ok
Para comprobar que todo funcion bien, haremos un log del contenedor y veremos cada cuanto se ejecuta el script
#+BEGIN_SRC 
docker logs -f duckdns
#+END_SRC
** Fuentes
- https://www.duckdns.org/
- https://hub.docker.com/r/linuxserver/duckdns/


* TODO Calendario en la terminal
:PROPERTIES:
:TITLE: Calendario en la terminal
:EXPORT_FILE_NAME: Calendario en la terminal
:DESCRIPTION: Desde la terminal, podemos hacer que nos muestre un calendario de muchas maneras. Este calendario puede ser útil como información, así como poder exportar o modificar el resultado para el
:EXPORT_DATE: 2019-10-11 17:55
:CATEGORY: terminal
:TAG: bash,calendario
:IMAGE: ./images-blog/calendar.jpg
:END:

Desde la terminal, podemos hacer que nos muestre un calendario de muchas maneras. Este calendario puede ser útil como información, así como poder exportar o modificar el resultado para el uso de scripts, 

#+HTML: <center>
[[./images-blog/calendar.jpg]]
#+HTML: </center>

Vamos a ver algunos ejemplos del uso de *cal* y *ncal*
** cal y ncal
*** cal
Con el comando *cal*, nos presenta el calendario con los días en la parte superior
#+BEGIN_SRC 
  Septiembre 2019     
do lu ma mi ju vi sá  
 1  2  3  4  5  6  7  
 8  9 10 11 12 13 14  
15 16 17 18 19 20 21  
22 23 24 25 26 27 28  
29 30     
#+END_SRC

*** ncal
Con *ncal*, nos muestra los días de la semana a la izquierda
#+BEGIN_SRC 
    Septiembre 2019   
lu     2  9 16 23 30
ma     3 10 17 24   
mi     4 11 18 25   
ju     5 12 19 26   
vi     6 13 20 27   
sá     7 14 21 28   
do  1  8 15 22 29   
#+END_SRC

** Ejemplos de cal y ncal

*** Calendario mes actual
#+BEGIN_SRC 
cal
#+END_SRC
#+BEGIN_SRC 
ncal
#+END_SRC

*** Calendario de un mes en concreto. 
Ejemplo: Mes número 3, (*-m3*).
#+BEGIN_SRC 
cal -m3
#+END_SRC
*** Año completo 
Por ejemplo 2019. Opción *-y* de year, año.
#+BEGIN_SRC 
cal -y 2019
#+END_SRC
*** Mes y un año en concreto
Ejemplo el mes 7 del año 2017
#+BEGIN_SRC 
cal -d 2017-07
#+END_SRC

*** Número de Semana
#+BEGIN_SRC 
ncal -w
#+END_SRC
Para saber en que número de semana estamos, necesitamos utilizar *ncal* y la opción *-w* de week.
#+BEGIN_SRC 
    Septiembre 2019   
lu     2  9 16 23 30
ma     3 10 17 24   
mi     4 11 18 25   
ju     5 12 19 26   
vi     6 13 20 27   
sá     7 14 21 28   
do  1  8 15 22 29   
   35 36 37 38 39 40
#+END_SRC

*** Meses precedentes, posterior...
Mostrar el mes actual, precedente y posterior. Este comanda vale tanto para *cal* como *ncal*.
#+BEGIN_SRC 
cal -3
#+END_SRC

Mostrar los 2 meses posteriores
#+BEGIN_SRC 
cal -A2
#+END_SRC
Mostrar los 2 meses anteriores

#+BEGIN_SRC 
cal -B2
#+END_SRC
Podemos combinar ambas opciones
#+BEGIN_SRC 
cal -B1 -A2
#+END_SRC

*** Número del día en el año
Número del día del año

#+BEGIN_SRC 
cal -j
#+END_SRC
Mostrar todos los días del año
#+BEGIN_SRC 
cal -j 2019
#+END_SRC


*** Iniciar semana en Lunes 

Iniciar la semana en Lunes. Esta opción solo está disponible con *ncal*

#+BEGIN_SRC 
ncal -M
#+END_SRC

Para mostrar el calendario, comenzando por el lunes como lo haría *cal*, vanos a ejecutar este miniscript:

#+BEGIN_SRC 
cal | awk '{ print " "$0; getline; print " Lu Ma Mi Ju Vi Sa Do"; \
getline; if (substr($0,1,2) == " 1") print "                    1 "; \
do { prevline=$0; if (getline == 0) exit; print " " \
substr(prevline,4,17) " " substr($0,1,2) " "; } while (1) }'
#+END_SRC
*** Filtrar con grep

Filtrar los miércoles del mes actual
#+BEGIN_SRC 
ncal | grep mi
#+END_SRC
#+BEGIN_SRC 
mi     4 11 18 25
#+END_SRC

*** Que pasó el día de hoy hace años

La opción *-l*, muestra lo que pasó y *0* en el día de hoy
#+BEGIN_SRC 
calendar -l 0
#+END_SRC
En los próximos 5 días
#+BEGIN_SRC 
calendar -l 5
#+END_SRC

** Fuentes
- https://www.computerhope.com/unix/ucal.htm
- https://www.howtoforge.com/linux-cal-ncal-command/
- [[https://pixabay.com/es/photos/calendario-calendario-mural-d%C3%ADas-1990453/][imagen]]
 
* TODO Cron. Ejemplos
:PROPERTIES:
:TITLE: Cron. Ejemplos
:EXPORT_FILE_NAME: cron-ejemplos
:DESCRIPTION: Cron es muy sencillo y a la vez complejo. Cuando quieres utilizar una programación en el tiempo muy concreta, entre días, meses, días de la semana, cada ciertos minutos... Puede
:EXPORT_DATE: 2019-10-15 19:30
:CATEGORY: bash
:TAG: terminal,cron
:IMAGE: ./images-blog/cron.png
:END:

Cron es muy sencillo y a la vez complejo. Cuando quieres utilizar una programación en el tiempo muy concreta, entre días, meses, días de la semana, cada ciertos minutos... Puede llevar a confusión. 

#+HTML: <center>
[[./images-blog/cron.png]]
#+HTML: </center>

En este artículo añado algunos de los ejemplos y así afinar el tiempo exacto que deseas, en tu programación con cron.

** Estructura cron

#+BEGIN_SRC 
# Ejemplo de definición de trabajo: 
# .---------------- minuto (0 - 59) 
# | .------------- hora (0 - 23) 
# | | .---------- día del mes (1 - 31)
# | | | .------- mes (1 - 12) O ene, feb, mar, abr ... 
# | | | | .---- día de la semana (0 - 6) (domingo = 0 o 7) O dom, lun, mar, mié, jue, vie, sáb 
# | | | | | 
# * * * * * comando de nombre de usuario que se ejecutará 
#+END_SRC

Visualizado de otro modo:
#+BEGIN_SRC 
Minuto  Hora  Día del Mes  Mes   Dia Semana  Usuario  Comando
  *      *       *          *        *        root    comando     
#+END_SRC
El *** , indica "*todos*". Todos los minutos, horas, dias,...

** Comandos de cron
Establece archivo.txt como crontab del usuario
#+BEGIN_SRC 
crontab archivo.txt
#+END_SRC
Abrir crontab para añadir o editar cron
#+BEGIN_SRC 
crontab -e
#+END_SRC
Ver el crontab del usuario actual
#+BEGIN_SRC 
crontab -l
#+END_SRC
Eliminar el crontab actual
#+BEGIN_SRC 
crontab -r
#+END_SRC

** Palabras reservadas
Cron tiene una serie de palabras reservadas para simplificar:
#+BEGIN_SRC 
@reboot              ## Se ejecuta cada vez que iniciamos el sistema 
@yearly/@annually    ## Ejecutar cada año
@monthly             ## Ejecutar cada mesuna vez al mes
@weekly              ## Una vez a la semana
@daily/@midnight     ## Una vez al día
@hourly              ## Cada Hora
#+END_SRC
** Ejemplos cron
Estos son algunos de los ejemplos de cron
#+BEGIN_SRC 
10 * * * *	              ## Cada hora en el minuto 10
30 5 * * *	              ## Todos los dias a las 5:30h
15 22 * * *	              ##  Todos los dias a las 22:15h
00 13 * * 0	              ## Domingos a las 13h
 * TODO 13 * *                      ## Los Domingos. Cada minuto de 13:00h a 13:55h
00 13 5 * *	              ## Los dias 5 de cada mes, a las 13:00
05 * 20 15 *	              ## El día 15 de Julio, cada hora al minuto 5
15 13 * 11 2	              ## Los Martes de Noviembre, a las 13:15h
00 22 15 * Wen	              ## Los 15 de mes, que coincidan en Miércoles, a las 22:00h 
30 * * * 6	              ## Los Sábados, cada minuto 30
30 * * 1 6	              ## Los Sábados de Enero, cada minuto 30
00 13 * 1-3 1,2,3,4,5	      ## De lunes a viernes, de enero a marzo, a las 13:00h
00 13 15-20 * 6-7	      ## Del 15 al 20 de cada mes, que sea Sábado o Domingo, a las 13:00h
10,30,45 * * * 1,3,5	      ## Lunes, Miércoles y Viernes, en el minuto 10, 30 y 45 de todas las horas
*/15 06-14 * * *	      ## Cada día, de 6h-14h, cada 15 minutos
 * TODO 12 1-10/2 2,8 *	      ## Todos los minutos de las 12 del día, cada dos días  empezando por el día 1, en febrero y agosto.
0 */5 1-10,15,20-23 * 3	      ## Cada 5 horas de los días 1 al 10, el día 15 y del día 20 al 23 de cada mes y que el día sea miércoles
3/3 2/14 * * *	              ## Cada 3 minutos empezando por el minuto 3, cada 4 horas empezando por las 14:00h
#+END_SRC
** Restringir acceso a cron
Restringir acceso a cron a todos los usuarios
#+BEGIN_SRC 
echo ALL >>/etc/cron.deny
#+END_SRC
** Permitir acceso a un usuario 
Permitir acceso al usuario *angel*.
#+BEGIN_SRC 
echo angel >>/etc/cron.allow
#+END_SRC
** Fuentes
- https://www.linuxtotal.com.mx/?cont=info_admon_006
- https://geekytheory.com/programar-tareas-en-linux-usando-crontab
 
 
 
* TODO Apagada automática de tu Raspberry si hay alta temperatura
:PROPERTIES:
:TITLE: Apagada automática de tu Raspberry si hay alta temperatura
:EXPORT_FILE_NAME: Apagada automática de tu Raspberry si hay alta temperatura
:DESCRIPTION: Después de las publicaciones sobre la alta temperatura de la Raspberry, te puede entrar la paranoia de que se queme, salga ardiendo, etc ...
:EXPORT_DATE: 2019-10-21 18:00
:CATEGORY: raspberry
:TAG: bash,terminal,script,alta,temperatura
:IMAGE: ./images-blog/raspberrypi.jpg
:END:

Después de las publicaciones sobre la alta temperatura de la Raspberry, te puede entrar la paranoia de que se queme, salga ardiendo, etc ... 

#+HTML: <center>
[[./images-blog/raspberrypi.jpg]]
#+HTML: </center>

Para evitar esto, me he creado un simple script que mediante *cron*, monitorizará la temperatura de mi Raspberry y en caso que la temperatura suba del nivel que yo decida, se apague.


** Script 
El script es muy sencillo. En la variable *TEMP* añadiremos la temperatura actual y preguntaremos si la temperatura es igual o superior a 60º. 

Si es inferior, no sucederá nada. Si ejecutamos el script manualmente, la terminal nos devolverá *Baja temperatura*. 

Si es igual o superior a 60º, recibiremos una notificación por Telegram, *Exceso de Temperatura* y mediante el comando *sudo shutdown now*, apagara nuestra Raspberry, así puedo dormir tranquilo.

Vamos a crearlo.

#+BEGIN_SRC 
nano /home/angel/scripts/temp.sh
#+END_SRC
Y copiaremos nuestro script

#+BEGIN_SRC 
#!/bin/bash

TEMP=$(/opt/vc/bin/vcgencmd measure_temp | cut -d"=" -f2 | cut -d "." -f1)

echo $TEMP

if [ "$TEMP" -ge "60" ]
then
echo "Alta temperatura"
curl -X POST https://api.telegram.org/bot<TOKEN BOT>/sendMessage\?chat_id\=<ID USUARIO>\&text\="Exceso de Temperatura" 
sudo shutdown now

else
echo "Baja temperatura"
fi
#+END_SRC
La línea que comienza por *curl*, es la línea para notificarnos por Telegram el exceso de temperatura. Añade tu Token e ID.

Damos permisos de ejecución

#+BEGIN_SRC 
sudo chmod +x /home/angel/scripts/temp.sh
#+END_SRC

** Cron
*Cosas importantes*. Vamos a utilizar cron como usuario *root*, si no no tendremos permisos para apagar nuestra Raspberry. 
#+BEGIN_SRC 
sudo crontab -e
#+END_SRC
Añadiremos la siguiente línea, para que ejecute el script cada cada 2 minutos. *Importante* especificar la ruta completa del script.
#+BEGIN_SRC 
*/2 * * * * /home/angel/scripts/temp.sh 
#+END_SRC
** Conclusión
Un método súper sencillo de apagar nuestra Raspberry si excede la temperatura de esta. Un ejemplo más, de lo maravilloso que es *cron*.
* TODO Docker: Servidor Webdav
:PROPERTIES:
:TITLE: Docker: Servidor Webdav
:EXPORT_FILE_NAME: docker-servidor-webdav
:DESCRIPTION: Montar un servidor webdav puede ser muy útil, ya que nos va a permitir sincronizar o compartir archivos. Nextcloud, Box.com, Yandex,... utilizan esta tecnología para conectarnos a sus nubes, pero
:EXPORT_DATE: 2019-10-22 17:55
:CATEGORY: servidor
:TAG: webdav,raspberry
:IMAGE: ./images-blog/dav.png
:END:

Montar un servidor webdav puede ser muy útil, ya que nos va a permitir sincronizar o compartir archivos. 

Nextcloud, Box.com, Yandex,... utilizan esta tecnología para conectarnos a sus nubes, pero si lo único que quieres hacer es simplemente compartir, sincronizar o subir y bajar archivos, quizás no necesitas el montar una nube tan pesada como Nextcloud.

#+HTML: <center>
[[./images-blog/dav.png]]
#+HTML: </center>

Para conectarte a un servidor Webdav solo necesitas tu navegador. Te conectas a la url y puerto donde montes el servicio, y el servidor te pedirá el usuario y contraseña para acceder.

Una vez introducido, tendrás acceso a todos los archivos que estén en la carpeta del servidor. Podrás ver todos los archivos desde el navegador.

Si no quieres utilizar el navegador, también podemos utilizar clientes webdav. Hay aplicaciones como *cadaver*, que nos permite el gestionar archivos desde nuestra terminal. *Curl*, permite el descargar y subir archivos a nuestro servidor *webdav*, muy útil para backups. (En breve haré un artículo sobre esto).

[[https://ugeek.github.io/blog/post/2019-06-11-montar-un-servidor-webdav-con-dafs2.html][En este artículo, expliqué como montar la carpeta de un servidor webdav, en tu PC local con fuse]]. Para conectarte desde tu explorador de archivos en Linux, es tan sencillo como escribir =dav://tu_ip:puerto/=, o =davs://tu_ip:puerto/= si tienes un certificado de Letsencript.

*Muy importante si abres el servidor a internet, el securizar el servidor con Letsencript para que todo el tráfico vaya cifrado*.

La mayor parte de exploradores de archivos de Android y IOS, son compatibles con webdav, así que como ves, tus archivos van a ser accesibles desde todos tus dispositivos.

¿Recuerdas [[https://ugeek.github.io/blog/post/2019-07-03-dale-almacenamiento-ilimitado-a-tu-raspberry-servidor-o-pc-con-rclone.html][Rclone]]?, también puedes utilizarlo como cliente y cifrar el contenido de tu nube.

Hay también muchas aplicaciones de video, notas,... compatibles con servidores webdav como por ejemplo [[https://joplinapp.org][Joplin]]. La velocidad de sincronización de tus notas con el servidor webdav, es muchísimo más rápida que con el servidor webdav de Nextcloud. Eso si, por seguridad, la aplicación te obliga a tener letsencript para sincronizar tus notas.

Ahora también Orgzly, permite acceso a tu servidor WebDav, de manera que puedes tener tus orgmode centralizados y sincronizados en tu servidor.
** Contenedor del servidor WebDav
Monté este docker con idea que fuera lo mas ligero posible, así que lo monté partiendo de un Alpine Linux + un servidor de Nginx.
Encontrarás todos estos contenedores en [[https://hub.docker.com/r/ugeek/webdav][mi repositorio de DockerHub]].

_Configuración_

- Username: webdav                   -> usuario
- Password: webdav                   -> contraseña
- port: 80                           -> Puerto del servicio
- root path: $HOME/docker/webdav     -> Ruta de la carpeta, donde estarán los archivos
- --restart=unless-stopped           -> Siempre se inicia, a menos que tu lo detengas

*** Raspberry o ARM
#+BEGIN_SRC 
docker run --name webdav --restart=unless-stopped -p 80:80 -v $HOME/docker/webdav:/media -e USERNAME=webdav -e PASSWORD=webdav -d ugeek/webdav:arm
#+END_SRC
*** amd64 
#+BEGIN_SRC 
docker run --name webdav --restart=unless-stopped -p 80:80 -v $HOME/docker/webdav:/media -e USERNAME=webdav -e PASSWORD=webdav -d ugeek/webdav:amd64
#+END_SRC
*** i386
#+BEGIN_SRC 
docker run --name webdav --restart=unless-stopped -p 80:80 -v $HOME/docker/webdav:/media -e USERNAME=webdav -e PASSWORD=webdav -d ugeek/webdav:i386
#+END_SRC

** Fuentes
- http://www.webdav.org/
- https://hub.docker.com/r/ugeek/webdav
* TODO Orzly. Tus OrgMode syncronizados por WebDav
:PROPERTIES:
:TITLE: Orzly. Tus OrgMode syncronizados por WebDav
:EXPORT_FILE_NAME: orzly-tus-orgmode-syncronizados-por-webdav
:DESCRIPTION: Ahora tienes un motivo mas para utilizar Orgzly y tus notas en OrgMode. Y es que Orgzly, hoy ha añadido en su versión 1.8-Beta.1  de Android, la posibilidad de
:EXPORT_DATE: 2019-10-22 18:30
:CATEGORY: emacs
:TAG: orgmode,webdav
:IMAGE: ./images-blog/orgzly.png
:END:

Ahora tienes un motivo mas para utilizar Orgzly y tus notas en OrgMode. Y es que Orgzly, hoy ha añadido en su versión 1.8-Beta.1  de Android, la posibilidad de sincronizar tus archivos orgmode, mediante WebDav. 

#+HTML: <center>
[[./images-blog/orgzly.png]]
#+HTML: </center>

Eso significa que ahora tanto puedes utilizar nubes púbicas como Box.com o Yandex, así como nubes privadas como Nextcloud, Owncloud,... O simplemente [[https://ugeek.github.io/blog/post/2019-10-22-docker-servidor-webdav.html][montar tu propio servidor WebDav como te explico en este artículo]].

Aunque hasta ahora, siempre he utilizado la sincronización mediante Syncthing, la sincronización mediante WebDav permite el tener el archivo en el servidor y que todos los clientes se conecten al servidor para modificar mis orgmode. Esto evita posibles problemas de sincronización.

Como siempre sucede con Orgzly, la aplicación no permite acceder a los orgmode que haya en subcarpetas. Así que tendremos que especificar la carpeta exacta donde estén estos. Por ejemplo, si nuestro archivo está en una carpeta llamada *notas*, introduciríamos en Orgzly:
#+BEGIN_SRC 
webdav://mi_servidor:puerto/notas/
#+END_SRC
Si tu servidor tiene certificado Letsencript y el contenido va cifrado:
#+BEGIN_SRC 
webdavs://mi_servidor:puerto/notas/
#+END_SRC
Y si tienes más de una carpeta en el mismo servidor, no dudes en añadirlos también. Por ejemplo la carpeta *orgmode*.
#+BEGIN_SRC 
webdav://mi_servidor:puerto/orgmode/
#+END_SRC
...
* TODO Crea tu cron de un modo gráfico
:PROPERTIES:
:TITLE: Crea tu cron de un modo gráfico
:EXPORT_FILE_NAME: Crea tu cron de un modo gráfico
:DESCRIPTION: Si queremos automatizar un script, utilizamos cron. Pero hay que reconocer que hasta que no le pillas el tranquillo, los parametros que tenemos que introducir para esta programación son muy
:EXPORT_DATE: 2019-10-23 18:00
:CATEGORY: bash
:TAG: terminal,ubuntu,debian,cron
:IMAGE: ./images-blog/cron.png
:END:

Si queremos automatizar un script, utilizamos cron. Pero hay que reconocer que hasta que no le pillas el tranquillo, los parametros que tenemos que introducir para esta programación son muy complejos.

#+HTML: <center>
[[./images-blog/cron.png]]
#+HTML: </center>

Al azahar, he encontrado una serie de páginas que nos facilita la construcción de estos parámetros para cron

** Páginas para generar tu cron
- https://crontab.guru/
- https://crontab-generator.org/
- http://www.cronmaker.com/
- http://corntab.com/
- http://cron.schlitt.info/
- https://www.easycron.com/ (Este necesita crear una cuenta)


** Fork de crontab.guru
Si en algún momento deja de existir https://crontab.guru/, he [[https://github.com/uGeek/crontab.guru][Forkeado el repositorio para montar mi crontab.guru]]
* TODO Bsync. Sincronización de archivos bidireccional, que utiliza Rsync
:PROPERTIES:
:TITLE: Bsync. Sincronización de archivos bidireccional, que utiliza Rsync
:EXPORT_FILE_NAME: bsync-sincronizacion-de-archivos-bidireccional-que-utiliza-rsync
:DESCRIPTION: Tal como expliqué en algún que otro Podcast-Artículo, GitHub nos ofrece muchos proyectos súper interesantes y útiles. Es el caso de Bsync, un una herramienta de sincronización de archivos bidireccional,
:EXPORT_DATE: 2019-10-24 22:22
:CATEGORY: sync
:TAG: python,backup,servidor,bsync
:IMAGE: ./images-blog/sync.png
:END:

Tal como expliqué en algún que otro Podcast-Artículo, GitHub nos ofrece muchos proyectos súper interesantes y útiles. Es el caso de Bsync, un una herramienta de sincronización de archivos bidireccional, que utiliza rsync desarrollada por [[http://positon.org/][Marc MAURICE]].

Bsync es una alternativa a Unison escrita en Python3. Puede detectar y aplicar archivos movidos de un lado a otro, Unison, en cambio, usa llamadas de copia para manejar los archivos movidos.  

#+HTML: <center>
[[./images-blog/sync.png]]
#+HTML: </center>

Bsync tiene licencia GPL.

** Instalación
Instalación la haremos descargando el script directamente desde GitHub.
#+BEGIN_SRC 
wget https://raw.github.com/dooblem/bsync/master/bsync
chmod +x bsync
#+END_SRC
** Funcionamiento
*** Ejemplos de sincronización
Sincronización en local:
#+BEGIN_SRC 
./bsync DIRECTORIO1 DIRECTORIO2
#+END_SRC

Si no quieres que te pregunte bsync para confirmar el archivo bueno en la sincronización, puedes utilizar la opción *-b*.

#+BEGIN_SRC 
./bsync DIRECTORIO1 DIRECTORIO2 -b
#+END_SRC

Sincronización vía SSH:
#+BEGIN_SRC 
./bsync ALICE_DIR  bob@sshserver:BOB_DIR
#+END_SRC
*** Directorio Maestro a modo de servidor
El desarrollador nos facilita el poder utilizar bsync con un directorio maestro, que podría ser la carpeta de un servidor:

Alice hace cambios en local
#+BEGIN_SRC 
./bsync ALICE_DIR MASTER_DIR
./bsync BOB_DIR   MASTER_DIR
#+END_SRC
Bob recibirá los cambios de Alice, enviando sus cambios a master al mismo tiempo

** .bsync-ignore 
Podemos ignorar archivos y carpetas, para que no se sincronizen, añadiendo la ruta completa del archivo o carpeta en un archivo de texto plano que situaremos en la carpeta raíz de la carpeta a sincronizar.

Este archivo tendrá el nombre de *.bsync-ignore* 

En este archivo, no podemos añadir comentarios.

#+BEGIN_SRC 
/home/angel/DIRECTORIO-SYNC/archivo.org
/home/angel/DIRECTORIO-SYNC/.config
#+END_SRC

** Ayuda
Comando de ayuda
#+BEGIN_SRC 
./bsync -h
#+END_SRC

** Algunas Características
- Detección de archivos movidos (usando números de inodes)
- Directorios remotos usando SSH
- No hay problema con enlaces simbólicos o permisos
- Detección de conflictos
- Python no es necesario en el lado remoto (solo GNU find y rsync)
- Excluir algunos subdirectorios de la sincronización (solo cree un .bsync-ignorearchivo)
- Mueva sus directorios de sincronización sin perder memoria de sincronización (listas de archivos almacenadas dentro de directorios en .bsync-snap-*archivos)
- Permisos de desactivación automática en sistemas de archivos gordos
- Soporte para MacOSX (requisito: GNU find instalado)

** Fuentes
- https://github.com/dooblem/bsync
- https://github.com/uGeek/bsync No me he podido resistir a Forkear el Repositorio😜  
* TODO Descargar archivos con curl
:PROPERTIES:
:TITLE: Descargar archivos con curl
:EXPORT_FILE_NAME: descargar-archivos-con-curl
:DESCRIPTION: Para descargar archivos desde un servidor, puedes utilizar *wget* o *curl*.
:EXPORT_DATE: 2019-10-25 18:00
:CATEGORY: bash
:TAG: terminal,curl
:IMAGE: ./images-blog/curl.svg
:END:

Para descargar archivos desde un servidor, puedes utilizar *wget* o *curl*.

#+HTML: <center>
[[./images-blog/curl.svg]]
#+HTML: </center>

Vamos a ver como podemos descargar archivos con *curl*. Para ello, tenemos que utilizar la opción *-o*

** Descargando un script de GitHub con curl
La estructura para descargar archivos sería esta.
#+BEGIN_SRC 
curl -o <archivo> <url>
#+END_SRC
Descargando el script con curl
#+BEGIN_SRC 
sudo curl -o /usr/bin/youtube2org https://raw.githubusercontent.com/uGeek/youtube2org/master/youtube2org
#+END_SRC
** Conclusión
Esto sirve para cualquier tipo de archivo que esté en cualquier servidor. Así que ahora puedes jugar descargando archivos...
* TODO Recargar archivo en Emacs
:PROPERTIES:
:TITLE: Recargar archivo en Emacs
:EXPORT_FILE_NAME: recargar-archivo-en-emacs
:DESCRIPTION: Estoy sincronizando constantemente, haciendo pruebas, mis archivos orgmode. Cuando tienes un archivo abierto, si se produce la sincronización en segundo plano, el archivo que estás visualizando no cambia, sigues viendo
:EXPORT_DATE: 2019-10-26 18:00
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/
:END:

Estoy sincronizando constantemente, haciendo pruebas, mis archivos orgmode. Cuando tienes un archivo abierto, si se produce la sincronización en segundo plano, el archivo que estás visualizando no cambia, sigues viendo la misma versión de archivo, en cambio, el archivo que hay en la carpeta, es una nueva versión. Para poder editar la nueva versión es necesario recargar el archivo. Pero...¿Como recargar el nuevo archivo?

** Recargar archivo
*** Primera Opción 
Para poder recargar el archivo, ejecutar en emacs =M-x revert-buffer=.

*** Segunda Opción
Como atajo de teclado, podríamos utilizar =C-x C-v RET=. Este atajo te permite seleccionar entre todos los archivo que hay dentro de la carpeta, donde está el archivo que estamos editanto, pero por defecto, nos propone como primera opción el archivo actual. 

Si pulsamos sobre este archivo, emacs nos propondrá el recargar el archivo actual. Diremos que sí mediante *y*.
* TODO Crea tu Bot de Mastodon en Bash con una sola línea de Terminal
:PROPERTIES:
:TITLE: Crea tu Bot de Mastodon en Bash con una sola línea de Terminal
:EXPORT_FILE_NAME: crea-tu-bot-de-mastodon-en-bash-con-una-sola-linea
:DESCRIPTION: Después de un largo periodo, he decidido volver a Mastodon. Una red social muy parecida a Twitter de Software Libre y descentralizada.
:EXPORT_DATE: 2019-10-28 18:00
:CATEGORY: bot
:TAG: mastodon
:IMAGE: ./images-blog/mastodon.png
:END:


Después de un largo periodo, he decidido volver a Mastodon. Una red social muy parecida a Twitter de Software Libre y descentralizada.

#+HTML: <center>
[[./images-blog/mastodon.png]]
#+HTML: </center>

Mastodon, por ser de Software Libre, es muchísimo mas abierta que otras redes sociales que no lo son. Te permite el crear tu propia aplicación, por ejemplo para automatizar publicaciones. 

Igual que ya hemos aprendido a [[https://ugeek.github.io/blog/post/2019-03-14-crea-un-bot-de-telegram-con-bash-y-una-sola-linea-de-terminal.html][publicar en Telegram con un Bot y una línea de terminal mediante bash]], ahora vamos ha hacer lo propio con Mastodon, 

** Publicando en Mastodon con una línea de terminal
Accede a tu instancia de Mastodon y genera un Token en *Preferencias* -> *Desarrollo* -> *Nueva Aplicación*.

Para publicar con nuestro Bot, necesitamos 
- Especificar la dirección de la instancia de tu servidor Mastodon, en mi caso *mastodon.social*.
- Añadir tu TOKEN
- Añadir Mensaje

*El Token que estoy utilizando (h4890ghiuG), es un Token de ejemplo inventado, sustituye por el tuyo.*

#+BEGIN_SRC 
curl -F "status=Enviando un toot desde mi terminal" -sS https://mastodon.social/api/v1/statuses --header "Authorization: Bearer h4890ghiuG"
#+END_SRC

Para hacerlo a modo de script, con las variables TOKEN y MENSAJE.
#+BEGIN_SRC 
TOKEN=h4890ghiuG
MENSAJE="Enviando un toot desde mi terminal"
curl -X POST -Ss https://mastodon.social/api/v1/statuses \
  --header "Authorization: Bearer ${TOKEN}" \
  -d "status=${MENSAJE}"
#+END_SRC
** Publicando Imágenes
Mastodon nos permite publicar hasta 4 imágenes por toot. Vamos a publicar la imagen *ugeek.png* con el texto "Publicando la mi primera Imagen mediante el Bot en Python".

#+BEGIN_SRC 
from mastodon import Mastodon

# Token y url de la Instancia
mastodon = Mastodon(
    access_token = '84fbgar354',
    api_base_url = 'https://mastodon.social/'
)

media = mastodon.media_post("ugeek.png")
mastodon.status_post("Publicando la mi primera Imagen mediante el Bot en Python", media_ids=media)
#+END_SRC
* TODO Grabar Raspbian, Ubuntu, Debian,... en un Pendrive o SD desde la Terminal
:PROPERTIES:
:TITLE: Grabar Raspbian, Ubuntu, Debian,... en un Pendrive o SD desde la Terminal
:EXPORT_FILE_NAME: grabar-raspbian-ubuntu-debian-en-un-pendrive-o-sd
:DESCRIPTION: Para grabar una imagen de Raspbian, Ubuntu, Debian,... o cualquier otro Sistema Operativo en GNU/Linux, podemos hacerlo de una forma muy liviana y sencilla desde la terminal con dd.
:EXPORT_DATE: 2019-10-29 18:00
:CATEGORY: bash
:TAG: raspberry,raspbian
:IMAGE: ./images-blog/sd.png
:END:

Para grabar una imagen de Raspbian, Ubuntu, Debian,... o cualquier otro Sistema Operativo en GNU/Linux, podemos hacerlo de una forma muy liviana y sencilla desde la terminal con dd.

#+HTML: <center>
[[./images-blog/sd.png]]
#+HTML: </center>

Como ejemplo en este artículo, voy a grabar una imagen de Raspbian.

** Descomprimir Raspbian
Descargo la imagen de raspbian desde su página oficial. Esta imagen está en *zip*, así que voy a descomprimirla
#+BEGIN_SRC 
unzip 2019-09-26-raspbian-buster-lite.zip 
#+END_SRC

** Localizar nuestro Pendrive o SD
Introducimos nuestro Pendrive o SD a nuestro PC y mediante esta línea, localizamos que unidad es
#+BEGIN_SRC 
df -h
#+END_SRC
Por tamaño, la unidad de mi Pendrive es *sdb*.
** Desmontar la unidad
Primero necesitamos desmonta la unidad, en mi caso la unidad es *sdb*.

Ya tenía un raspian antiguo de pruebas. Hay 2 particiones, *sdb1 y sdb2*. Desmonto las dos.
#+BEGIN_SRC 
umount /dev/sdb1
umount /dev/sdb2
#+END_SRC
** Grabar Pendrive o SD
Vamos a utilizar *dd* para grabar la imágen. 

*dd [if=<ORIGEN>] [of=<DESTINO>]*

#+BEGIN_SRC 
sudo dd bs=1M if=2019-09-26-raspbian-buster-lite.img of=/dev/sdb status=progress
#+END_SRC
*if* es la ruta origen, en este caso la imágen de raspbian y *off* es el destino, el Pendrive. *bs=1M*, significa que la escritura se hará en bloques de 1M. *status=progress*, muestra el proceso de grabado, para que no nos desesperemos


Si el archivo es extensión *.img.xz*, podemos grabarlo directamente con este comando:
#+BEGIN_SRC 
sudo xzcat ~/recalbox-rpi3.img.xz | dd bs=1M  of=/dev/mmcblk3p status=progress 
#+END_SRC



* TODO Crea tu Bot en Mastodon con Python
:PROPERTIES:
:TITLE: Crea tu Bot en Mastodon con Python
:EXPORT_FILE_NAME: crea-tu-bot-en-mastodon-con-python
:DESCRIPTION: Hemos visto como publicar en Mastodon mediante un Bot en Bash, Ahora vamos a ver como hacerlo con Python.
:EXPORT_DATE: 2019-10-30 19:32
:CATEGORY: bot
:TAG: python,mastodon
:IMAGE: ./images-blog/mastodon.png
:END:

Hemos visto como publicar en Mastodon mediante un Bot en Bash, Ahora vamos a ver como hacerlo con Python.

#+HTML: <center>
[[./images-blog/mastodon.png]]
#+HTML: </center>

Además, en la parte final del artículo, vamos a ver como publicar un imagen adjunta al toot.

** Instalando librerias
#+BEGIN_SRC 
pip3 install Mastodon.py
#+END_SRC

** Creando el Bot y publicando mensajes de texto

Creamos el archivo, por ejemplo *bot-mastodon.py* y pego el siguiente contenido, añadiendo mi *Token*, *instancia* y mensaje.
*El Token 84fbgar354 es inventado, sustituye por el tuyo*

#+BEGIN_SRC 
from mastodon import Mastodon

# Token y url de la Instancia 
mastodon = Mastodon(
    access_token = '84fbgar354',
    api_base_url = 'https://mastodon.social/'
)

mastodon.status_post("Mensaje desde mi Bot en Python")
#+END_SRC
Ejecutamos para ver si funciona.
#+BEGIN_SRC 
python3 bot-mastodon.py
#+END_SRC


Hay un método muy sencillo de instalarlo mediante *curl*. Con solo una línea de terminal, tendremos la última versión de rclone instalada en nuestra derivada de Debian.

** Instalación
Escribe en tu terminal 
#+BEGIN_SRC 
curl https://rclone.org/install.sh | sudo bash
#+END_SRC
* TODO Habilitar SSH en la Raspberry sin conectar el Monitor
:PROPERTIES:
:TITLE: Habilitar SSH en la Raspberry sin conectar el Monitor
:EXPORT_FILE_NAME: habilitar-ssh-en-la-raspberry-sin-conectar-el-monitor
:DESCRIPTION: Una vez grabado Raspbian en una SD o USB, casi seguro que querrás conectarte vía SSH. Para habilitar el servidor SSH, siempre te recomiendan el conectar tu Raspberry Pi a
:EXPORT_DATE: 2019-10-31 18:00
:CATEGORY: raspberry
:TAG: ssh,bash
:IMAGE: ./images-blog/raspberrypi.jpg
:END:

Una vez grabado Raspbian en una SD o USB, casi seguro que querrás conectarte vía SSH. Para habilitar el servidor SSH, siempre te recomiendan el conectar tu Raspberry Pi a una TV vía HDMI y entrando en la configuración, habilitar el servidor SSH.
#+HTML: <center>
[[./images-blog/raspberrypi.jpg]]
#+HTML: </center>

En realidad esto no es necesario, es mucho más simple.

Cuando copiamos el SD o USB, se crean dos particiones. La carpeta *boot*, es donde está el arranque y simplemente creando un archivo vacío llamado ssh, ya tendremos habilitado el acceso a nuestra Raspberry Pi por SSH.
** Creando el archivo
En nuestro PC averiguamos donde está montada la partición *boot* y accedemos a ella.

Ahora procedemos a crear el archivo *ssh*.
#+BEGIN_SRC 
touch ssh
#+END_SRC
Ya está!!!. Ahora cuando encendamos nuestra Raspberry Pi, ya podremos acceder vía SSH.
* TODO Marcar una línea en tu OrgMode, para después volver a ella
:PROPERTIES:
:TITLE: Marcar una línea en tu OrgMode, para después volver a ella
:EXPORT_FILE_NAME: marcar-una-linea-en-tu-orgmode-para-despues-volver-a-ella
:DESCRIPTION: Mi archivo orgmode, actualmente supera de largo las 40.000 líneas. Hay momentos que estoy accediendo a una parte del documento, por ejemplo la línea /1345,/ donde estoy leyendo parte de
:EXPORT_DATE: 2019-11-01 18:00
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/orgmode.png
:END:

Mi archivo orgmode, actualmente supera de largo las 40.000 líneas. Hay momentos que estoy accediendo a una parte del documento, por ejemplo la línea /1345,/ donde estoy leyendo parte de un contendio que tiene relación con la línea /38915/. 

¿Como podría marcar una línea, para después volver a ella?. 

Normalmente suelo escribir, por ejemplo, la palabra #anchor en ambas líneas y esta manera, mediante la búsqueda, salto de una línea a otra. 

#+HTML: <center>
[[./images-blog/orgmode.png]]
#+HTML: </center>

Hay un método que tiene emacs para marcar una línea y después volver a ella.

** Marcar línea al anillo
Para guardar una marca, *que solo durará la sesión que tengamos el documento abierto*, utilizaremos el atajo:

=C-c %=

=M-x  org-mark-ring-push=

Ahora podremos movernos a lo largo del documento. 
Para Volver a la línea que hemos marcado antes:

=C-c &=

=M-x  org-mark-ring-goto=

* TODO Rclone. Instalando la última versión
:PROPERTIES:
:TITLE: Rclone. Instalando la última versión
:EXPORT_FILE_NAME: rclone-instalando-la-ultima-version
:DESCRIPTION: Rclone está disponible en los repositorios oficiales, pero como siempre os he comentado, es interesante tener instalada la última versión.
:EXPORT_DATE: 2019-11-01 18:00
:CATEGORY: sync
:TAG: bash,rclone
:IMAGE: ./images-blog/rclone.png
:END:
Rclone está disponible en los repositorios oficiales, pero como siempre os he comentado, es interesante tener instalada la última versión. 

Pero... ¿Cómo instalar rclone de un modo sencillo?


#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>


Tan sencillo como...

#+BEGIN_SRC 
curl https://rclone.org/install.sh | sudo bash
#+END_SRC
* TODO Docker: Gotify. Tu servidor de Notificaciones
:PROPERTIES:
:TITLE: Docker: Gotify. Tu servidor de Notificaciones
:EXPORT_FILE_NAME: docker-gotify-tu-servidor-de-notificaciones
:DESCRIPTION: Después de montar un bot con Telegram y Mastodon, ha llegado el momento de crear tu propio servicio de notificaciones. No vamos a depender de servicios de terceros para saber
:EXPORT_DATE: 2019-11-06 17:55
:CATEGORY: docker
:TAG: bot,gotify
:IMAGE: ./images-blog/gotify.png
:END:

Después de montar un bot con Telegram y Mastodon, ha llegado el momento de crear tu propio servicio de notificaciones. No vamos a depender de servicios de terceros para saber todo lo que sucede en nuestros servidores, Raspberry,... allá donde quieras utilizarlo

#+HTML: <center>
[[./images-blog/gotify.png]]
#+HTML: </center>

Gotify es un servidor de notificaciones de Software Libre muy fácil de instalar mediante docker.


** Docker para ARM
Para montar nuestro servidor *Gotify* de notificaciones, por ejemplo por el puerto 90:
#+BEGIN_SRC 
docker create \
  --name=gotify \
  -p 90:80 \
  -v $HOME/docker/gotify/data:/app/data \
  gotify/server-arm7
#+END_SRC
Puedes utilizar cualquier puerto disponible.

Una vez montado el servidor, abrimos nuestro navegador y nos conectamos a http://ip:90.

El usuario es *admin* y la contraseña *admin*.

** Docker para amd64
#+BEGIN_SRC 
docker create \
  --name=gotify \
  -p 90:80 \
  -v $HOME/docker/gotify/data:/app/data \
  gotify/server
#+END_SRC
** docker-compose para traefik
#+BEGIN_SRC 
    version: "3"

    services:
     gotify:
      image: gotify/server
      container_name: gotify
      restart: unless-stopped

      networks:
       - web

      restart: always
      volumes:
       - $HOME/docker/gotify/data:/app/data 
      labels:
       - traefik.backend=gotify
       - traefik.frontend.rule=Host:gotify.mi-dominio.duckdns.org
       - traefik.docker.network=web
       - traefik.port=80
       - traefik.enable=true

    networks:
     web:
      external: true
#+END_SRC
** Crear una aplicación
En Gotify, aplicaciones sería lo mismo que en Telegram el canal del bot.
 
Una vez creada la aplicación desde la página web de administración de Gotify, podemos subir una imagen a esta aplicación, para identificar rápidamente esta.

Copiamos el *Token* de la aplicación que hemos creado. Con el Token y la *ip:puerto*, ya podremos enviar información al servidor y así recibir notificaciones en los clientes.

** Enviar notificaciones con bash
Enviar una notificación desde tu terminal es muy sencillo. Este es un script de ejemplo. Recuerda que el Token, ip y puerto que utilizo, es inventado.
#+BEGIN_SRC 
curl -X POST "http://192.168.1.100:90/message?token=A8EPKuUcvb9sm" \
 -F "title=Título" \
 -F "message=Aquí va mi mensaje" \
 -F "priority=1"
#+END_SRC
El mensaje se compone:
- Título
- Mensaje
- Prioridad

** Notificaciones con Python
Si eres más amante de Python, también puedes enviar información al servidor mediante este código de ejemplo.
#+BEGIN_SRC 
import requests #pip install requests                                                                                                       
resp = requests.post('http://192.168.1.100:90/message?token=A8EPKuUcvb9sm', json={
    "message": "Este es mi mensaje",
    "priority": 2,
    "title": "Título del Mensaje"
})
#+END_SRC

** Instalando gotify-cli
Vamos a [[https://github.com/gotify/cli][esta url y descargaremos la versión para nuestra arquitectura]]. En mi caso voy a utilizar la Raspberry, así que descargaré la versión para arm-7

*** Descargando
#+BEGIN_SRC 
wget -O gotify  https://github.com/gotify/cli/releases/download/v2.1.1/gotify-cli-linux-arm-7
#+END_SRC
*** Dando permisos de ejecución
#+BEGIN_SRC 
chmod +x gotify
#+END_SRC
*** Configurando gotify-cli
Para configurarlo, teclearemos en la terminal:
#+BEGIN_SRC 
./gotify ini 
#+END_SRC
Nos preguntará:
#+BEGIN_SRC 
Gotify URL:
#+END_SRC
- Introducimos la  http://ip:port de nuestro servidor

#+BEGIN_SRC 
Connecting -> Success!
Gotify v2.0.10@2019-10-19-08:49:54

Configure an application token
1. Enter an application-token
2. Create an application token (with user/pass)
Enter 1 or 2: 
#+END_SRC
- Ahora si ya tienes el token de tu aplicación, introducelo. Si no es así te permite el crear una nueva aplicación con su token.

- En el momento en que introduzcamos nuestro token, si todo ha ido bien, recibiremos un mensaje.

- Por último nos pedirá en que lugar queremos guardar el archivo de configuración que hemos creado. 

** Ejemplos de gotify-cli

*** Enviar un Mensaje
#+BEGIN_SRC 
./gotify push "Mensaje" 
#+END_SRC
*** Enviar el resultado de un script
#+BEGIN_SRC 
MENSAJE="Este es un mensaje"
echo $MENSAJE | gotify push
#+END_SRC
*** Enviar un archivo de texto
#+BEGIN_SRC 
gotify push < archivo.txt
#+END_SRC
***  Enviar con título y prioridad
#+BEGIN_SRC 
./gotify push -t "Mi titulo" -p 10 "Este es mi mensaje"
#+END_SRC

Ayuda
#+BEGIN_SRC 
./gotify -h
#+END_SRC
Más información [[https://github.com/gotify/cli][en el repositorio en GitHub]].

** Cada vez más clientes
Actualmente no disponemos de un gran número de clientes de Gotify, pero esta lista va creciendo cada día más. 

Tengo instalado Gotify en mi Android. Podemos instalarla tanto desde [[https://f-droid.org/de/packages/com.github.gotify/][F-Droid]], [[https://github.com/gotify/android/releases/latest][apk]] así como desde [[https://play.google.com/store/apps/details?id=com.github.gotify][Google Play]].

También hay una extensión para [[https://addons.mozilla.org/es/firefox/addon/gotify-for-firefox/][Firefox]] y [[https://github.com/rorpage/gotify-chrome][Google Chrome]]. 

** Conclusión
Gotify se ha convertido en un servicio imprescindible para mi. Si lo complementas con el docker de Letsencrypt, te permitirá abrir el servicio a internet de un modo seguro y recibir las notificaciones estés donde estés.

** Fuentes
- https://gotify.net
- https://github.com/gotify/cli
- https://hub.docker.com/r/gotify/server-arm7
* TODO Simplifica o abrevia tus conexiones SSH
:PROPERTIES:
:TITLE: Simplifica o abrevia tus conexiones SSH
:EXPORT_FILE_NAME: simplifica-o-abrevia-tus-conexiones-ssh
:DESCRIPTION: Cuando tienes muchas Raspberry, Servidores, Pc's,... y te conectas a ellos vía SSH, llega un momento que no recuerdas las IP's, puertos, etc... También es mucho más rápido en el
:EXPORT_DATE: 2019-11-09 09:45
:CATEGORY: ssh
:TAG: bash,zsh
:IMAGE: ./images-blog/bash.png
:END:

Cuando tienes muchas Raspberry, Servidores, Pc's,... y te conectas a ellos vía SSH, llega un momento que no recuerdas las IP's, puertos, etc... También es mucho más rápido en el momento de conectarnos destinar a cada dispositivo un nombre abreviado que podamos recordar y no tener que poner toda la línea completa.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Vamos a ver como crear este archivo de configuración muy simple.

** Crear archivo de configuración
Vamos a crear el archivo de configuración. Utilizaremos de editor Vim.
#+BEGIN_SRC 
vim ~/.ssh/config
#+END_SRC
Rellenamos la Ip, puerto, usuario y nombre que utilizaremos para conectarno. En mi caso *rp4*
#+BEGIN_SRC 
Host rp4
    Hostname 192.168.1.100
    IdentityFile ~/.ssh/id_rsa
    IdentitiesOnly yes
    User pi
    Port 22
#+END_SRC
Ahora voy a añadir también mi Raspberry Pi 3.
#+BEGIN_SRC 
Host rp4
    Hostname 192.168.1.100
    IdentityFile ~/.ssh/id_rsa
    IdentitiesOnly yes
    User pi
    Port 22
Host rp3
    Hostname 192.168.1.101
    IdentityFile ~/.ssh/id_rsa
    IdentitiesOnly yes
    User angel
    Port 22
#+END_SRC
- Hostname: ip del servidor
- Port: puerto
- User: usuario
- IdentityFile: Es la ruta del archivo donde está la clave privada del servidor
- IdentitiesOnly:Especifica que la conexión se hará solo bajo el archivo *IdentityFile*


** Simplificar si hay cosas en común
#+BEGIN_SRC 
Host rp4
    Hostname 192.168.1.100
    User pi
Host rp3
    Hostname 192.168.1.101
    User angel
Host *
    IdentityFile ~/.ssh/id_rsa
    IdentitiesOnly yes
    Port 22
#+END_SRC
** Conectarme ahora de un modo simple, gracias al archivo de configuración
#+BEGIN_SRC 
ssh rp4
#+END_SRC
y
#+BEGIN_SRC 
ssh rp3
#+END_SRC

Quizás quieras abrir una aplicación de tu servidor remoto en local:
#+BEGIN_SRC 
ssh -X rp4
#+END_SRC

** Fuentes 
- https://www.atareao.es/ubuntu/configuracion-de-ssh/



 
* TODO Docker: Mariadb
:PROPERTIES:
:TITLE: Docker: Mariadb
:EXPORT_FILE_NAME: Docker: Mariadb
:DESCRIPTION: Mariadb es una base de datos que hemos utilizado para muchos servicios y que podemos instalarla desde un docker. Hay dockers de mariadb tanto oficial, de la comunidad LinuxServer,... Pero
:EXPORT_DATE: 2019-11-11 17:55
:CATEGORY: docker
:TAG: mariadb
:IMAGE: ./images-blog/mariadb.png
:END:

Mariadb es una base de datos que hemos utilizado para muchos servicios y que podemos instalarla desde un docker. Hay dockers de mariadb tanto oficial, de la comunidad LinuxServer,... Pero yo he optado por crear uno yo mismo.

El Docker que creé lo subí al DockerHub, y dos meses después ya supera mucho más de 10.000 descargas.


#+HTML: <center>
[[./images-blog/mariadb.png]]
#+HTML: </center>

El objetivo erá utilizar un mariadb muy ligero que partiera de un Alpine Linux.

** Montar el Docker
El puerto por defecto de mariadb, que es el 3306, yo en le ejemplo lo estoy desviando al 3307. Puedes utilizar el que tu desees.

Recuerda poner la contraseña de la base de datos, poniéndola en lugar de =my-secret-pw=.

Si creas el contenedor como está aquí:
- usuario -> root
- ip -> La del servidor
- Puerto -> 3307
- Contraseña -> my-secret-pw

Las carpetas que están en *-v*, son las carpetas de configuración de mariadb.

*** Para ARM
#+BEGIN_SRC 
docker run --name mariadb \
-p  3307:3306 \
-v $HOME/docker/mariadb/config:/var/lib/mysql \
-v $HOME/docker/mariadb/conf.d:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=my-secret-pw -d \
ugeek/mariadb:arm
#+END_SRC

*** Para amd64 
Arquitectura 64bits
#+BEGIN_SRC 
docker run --name mariadb \
-p  3307:3306 \
-v $HOME/docker/mariadb/config:/var/lib/mysql \
-v $HOME/docker/mariadb/conf.d:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=my-secret-pw -d \
ugeek/mariadb:amd64
#+END_SRC


** Crea la base de datos 
Entramos dentro del contenedor:
#+BEGIN_SRC 
docker exec -i -t mariadb sh
#+END_SRC
Una vez dentro, ejecutaremos los siguiente comandos. 

*** Ejecutamos mariadb
#+BEGIN_SRC 
mysql -u root -p
#+END_SRC
*** Creamos la base de datos
#+BEGIN_SRC 
CREATE DATABASE IF NOT EXISTS <name>; 
#+END_SRC
Damos privilegios para que acceda el servicio:
#+BEGIN_SRC 
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost';
#+END_SRC
#+BEGIN_SRC 
flush privileges;
#+END_SRC
Salimos de mariadb:
#+BEGIN_SRC 
\q
#+END_SRC
Salimos del contenedor:
#+BEGIN_SRC 
exit
#+END_SRC
* TODO Compilando La última versión de Nano 
:PROPERTIES:
:TITLE: Compilando La última versión de Nano
:EXPORT_FILE_NAME: compilando-la-ultima-version-de-nano
:DESCRIPTION: Me he puesto manos a la obra a como sacar el máximo de partido a nano, un editor de texto a veces desprestigiado frente a otros, pero uno de los
:EXPORT_DATE: 2019-11-12 21:18
:CATEGORY: aplicación
:TAG: terminal,bash,zsh,nano
:IMAGE: ./images-blog/nano.png
:END:

Me he puesto manos a la obra a como sacar el máximo de partido a nano, un editor de texto a veces desprestigiado frente a otros, pero uno de los más utilizados por su simplicidad. 

Un usuario que acaba de introducirse en el mundo de la terminal y desea editar una archivo de configuración, la primera vez que utiliza vim o emacs, no sabe ni como salir. Nano, en cambio, soluciona este problema. Normalmente lo único que hacemos con un editor como nano es editar y guardar, pero en realidad podemos personalizarlo mucho mediante el archivo de configuración y podemos alcanzar un gran nivel de productividad.


#+HTML: <center>
[[./images-blog/nano.png]]
#+HTML: </center>

En siguientes artículos os hablaré más de como alcanzarconseguir todo esto, pero en esta primera entrega, vamos a compilar la última versión ya que he utilizado desde la versión 2 a la 4 y he encontrado muchísimas diferencias. 

Así que para partir de un punto de partida en común y no encontrar errores en los archivos de configuración, voy a explicaros como compilar esta última versión. 
** Instalamos dependencias

Hay que instalar alguna dependencia necesaria.
#+begin_src 
sudo apt install libncursesw5-dev
#+end_src

** Versión 4.5 
Vamos a descargar, descomprimir el archivo y acceder a la carpeta de esta última versión publicada el 4 de octubre del 2019
#+BEGIN_SRC 
wget https://nano-editor.org/dist/v4/nano-4.5.tar.gz
tar xfvz nano-4.5.tar.gz
cd nano-4.5
#+END_SRC

Ahora ejecutaremos los siguiente comandos:

#+BEGIN_SRC 
./configure --prefix=/usr     \
            --sysconfdir=/etc \
            --enable-utf8     \
            --docdir=/usr/share/doc/nano-4.5 &&
make
#+END_SRC

Ahora necesitamos entrar como usuario *root*.

#+BEGIN_SRC 
sudo su
#+END_SRC

#+BEGIN_SRC 
make install &&
install -v -m644 doc/{nano.html,sample.nanorc} /usr/share/doc/nano-4.5
#+END_SRC

Vamos a comprobar si ya tenemos instalada la versión 4.5

#+BEGIN_SRC 
nano --version
#+END_SRC

** Fuente
- https://www.nano-editor.org
- http://www.linuxfromscratch.org/blfs/view/svn/postlfs/nano.html


* TODO Compilando la última versión de Emacs
:PROPERTIES:
:TITLE: Compilando la última versión de Emacs
:EXPORT_FILE_NAME: compilando-la-ultima-version-de-emacs
:DESCRIPTION: En el Artículo anterior compilamos Nano y ahora toca el turno de Emacs. Los que utilizamos Debian, Ubuntu, Raspbian... tenemos el problema que en los repositorios oficiales, no encontramos nunca
:EXPORT_DATE: 2019-11-13 19:10
:CATEGORY: emacs
:TAG: bash,zsh,compilar
:IMAGE: ./images-blog/emacs.png
:END:

En el Artículo anterior compilamos Nano y ahora toca el turno de Emacs. Los que utilizamos Debian, Ubuntu, Raspbian... tenemos el problema que en los repositorios oficiales, no encontramos nunca la última versión estos editores de texto. Ya os expliqué como instalarlo mediante los paquetes snap. Un método muy sencillo, pero a la vez, los paquetes snaps tiene el defecto de ir mucho más lento que instalarlo por PPA o desde los repositorios de nuestra distro. 

También podemos encontrar problemas al vincular algún paquete de emacs con librerías de nuestro sistema opertativo.

Tras probar todas las opciones, la mejor opción es compilarlo tu mismo. 

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>


Tras unos tres años utilizando Emacs de manera intensiva, os puedo asegurar que si compilas Emacs tu mismo, notarás una gran mejora en la velocidad de arranque y edición de tus archivos.

Vamos a ver como compilar Emacs.


** Dependencias necesarias
Instalamos las siguientes dependencias
#+begin_src 
sudo apt-get install build-essential texinfo libx11-dev libxpm-dev libjpeg-dev libpng-dev libgif-dev libtiff-dev libgtk2.0-dev libncurses-dev libxpm-dev automake autoconf
#+end_src
** Descargamos la versión 26.3
Descargamos la última versión de Emacs
#+BEGIN_SRC 
wget https://ftp.gnu.org/gnu/emacs/emacs-26.3.tar.xz
#+END_SRC
Descomprimimos y accedemos a la carpeta
#+BEGIN_SRC 
tar xfv emacs-26.3.tar.xz
cd emacs-26.3
#+END_SRC

** Comenzamos la Compilación
Ejecutamos los siguientes comandos

#+begin_src
./configure --with-gnutls=no --prefix=/usr --localstatedir=/var &&  make
#+end_src

*Accedemos como usuario root*
#+BEGIN_SRC 
su root
#+END_SRC
Compilamos
#+BEGIN_SRC 
make install &&
chown -v -R root:root /usr/share/emacs/26.3 &&
rm -vf /usr/lib/systemd/user/emacs.service
#+END_SRC

** Conclusión
Ha sido muy fácil compilar Emacs a la versión 26.3. Ahora toca disfrutar!!!
* TODO Emacs. Guardando el último lugar que estás editando para, volver en otra sesión
:PROPERTIES:
:TITLE: Emacs. Guardando el último lugar que estás editando, para volver en otra sesión
:EXPORT_FILE_NAME: emacs-guardando-el-ultimo-lugar-que-estas-editando-para-volver-en-otra-sesion
:DESCRIPTION: Una de las cosas que más rabia me da cuando estoy editando mis archivos de configuración, orgmode,... en Emacs, es que cuando dejo a medias la edición un archivo y
:EXPORT_DATE: 2019-11-14 22:35
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/emacs.png
:END:

Una de las cosas que más rabia me da cuando estoy editando mis archivos de configuración, orgmode,... en Emacs, es que cuando dejo a medias la edición un archivo y más tarde quiero volver a editarlo, Emacs por defecto te abre el archivo al justo inicio.

Ya os comenté que mi archivo de notas en orgmode, supera de largo las 40.000 líneas. Imagina el tener que volver a una posición de una nota concreta.

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>


El truquillo para [[https://ugeek.github.io/blog/post/2019-11-01-marcar-una-linea-en-tu-orgmode-para-despues-volver-a-ella.html][navegar de una línea a otra]], está genial. Pero mi sueño sería que al cerrar mi documento, la próxima vez que lo abra, vuelva exactamente allí donde lo dejé.

¿Será esto posible con Emacs?. En Emacs todo es posible. jejeje

** save-place-mode
A partir de la versión 25, Emacs ha integrado de serie el modo *save-place-mode*, que permite hacer exactamente esto, poder guardar la posición exacta del cursor en el momento de cerrar el documento, para que la próxima vez que lo abramos, nos lleve exactamente en el lugar donde lo dejamos.


** Habilitando el modo save-place-mode y guardando la posición
Tan sencillo como poner en tu archivo de configuración de emacs, tanto sea *.emacs* como *init.el*:
#+BEGIN_SRC 
(save-place-mode 1) 
#+END_SRC
** Sincronizando la posición en todos mis dispositivos 
¿Como puedo tener sincronizada la posición del cursor en todos mis dispositivos?

Para ello, por defecto, este modo guarda la posición del cursor, en un archivo situado en *~/.emacs.d/places*, pero mediante la opción *save-place-file*, podemos poner el archivo donde deseemos, pudiendo sincronizarlo en una nube como syncthing, Nextcloud, Dropbox, etc...

Por ejemplo:
#+BEGIN_SRC 
(setq save-place-file "~/sync/orgmode-places")
#+END_SRC
El resultado final sería este:

#+BEGIN_SRC 
(save-place-mode 1) 
(setq save-place-file "~/sync/orgmode-places")
#+END_SRC

** Conclusión 
Con modos como este, es imposible que cambie de editor de texto. Como siempre os comento, lo bueno que tiene Emacs y lo hace casi perfecto, es que puedes personalizarlo al 100% a tu gusto y necesidad. Si en Emacs algo no existe, seguro que hay alguien que pueda desarrollarlo. 

** Fuente
- https://www.emacswiki.org/emacs/SavePlace
* TODO Test de velocidad en la terminal
:PROPERTIES:
:TITLE: Test de velocidad en la terminal
:EXPORT_FILE_NAME: test-de-velocidad-en-la-terminal
:DESCRIPTION: Comprobar la velocidad de tu conexión a internet desde tu terminal es muy sencillo. Como puedes ver, para hacerlo, no necesitas necesariamente utilizar el navegador web.
:EXPORT_DATE: 2019-11-20 19:00
:CATEGORY: terminal
:TAG: bash,python,zsh
:IMAGE: ./images-blog/cron.png
:END:

Comprobar la velocidad de tu conexión a internet desde tu terminal es muy sencillo. Como puedes ver, para hacerlo, no necesitas necesariamente utilizar el navegador web.

#+HTML: <center>
[[./images-blog/cron.png]]
#+HTML: </center>


Vamos a utilizar [[https://github.com/sivel/speedtest-cli][speedtest-cli]], una librería en python que de un modo muy sencillo, nos va a proporcionar esta información

** Instalando pip
#+BEGIN_SRC 
sudo apt install python3-pip
#+END_SRC
** Instalando speedtest-cli
#+BEGIN_SRC 
pip3 install speedtest-cli
#+END_SRC
** Comprobando la velocidad
Tan sencillo como:
#+BEGIN_SRC 
speedtest-cli
#+END_SRC
** Ayuda
Encontrarás muchas mas opciones, en la ayuda.
#+BEGIN_SRC 
speedtest-cli -h
#+END_SRC
* TODO Ordena, renombra y actualiza tus metadatos con Tiny Media Manager
:PROPERTIES:
:TITLE: Ordena, renombra y actualiza tus metadatos con Tiny Media Manager
:EXPORT_FILE_NAME: ordena-renombra-y-actualiza-tus-metadatos-con-tiny-media-manager
:DESCRIPTION: Si tienes un servidor multimedia como Jellyfin o Plex, en muchas ocasiones, es probable que la información de tus películas o series, no aparezcan correctamente
:EXPORT_DATE: 2019-11-27 20:05
:CATEGORY: jellyfin
:TAG: plex,servidor,multimedia
:IMAGE: ./images-blog/tmm.png
:END:


Si tienes un servidor multimedia como Jellyfin o Plex, en muchas ocasiones, es probable que la información de tus películas o series, no aparezcan correctamente. No estaría mal el ayudar a tu servidor con esta dura tarea de indexar tus archivos. 

Para ello, vamos a instalar una aplicación como Tiny Media Manager.

#+HTML: <center>
[[./images-blog/tmm.png]]
#+HTML: </center>



Tiny Media Manager nos va a renombrar, modificar correctamente los metadatos y descargar portadas de nuestro contenido multimedia.

La había probado hace muchísimo tiempo, pero no hace mucho, me la recomendó nuevamente [[https://elblogdelazaro.gitlab.io/][Carlos del Blog de Lazaro]].

** Instalación

*** Java 
Tiny Media Manager, está desarrollado en Java, así que es necesario instalar JDK u OpenJDK, si tu distro no lo trae instalado. Es probable que tu distro traiga una versión incluso mas actualizada.
#+BEGIN_SRC 
sudo apt install openjdk-8-jdk
sudo apt install libmediainfo
#+END_SRC
*** Descargando y ejecutando Tiny Media Manager  

Tan sencillo como ir a la página oficial de TiniMediaManager y [[https://www.tinymediamanager.org/download/][descargar el archivo comprimido, em mi caso, para linux]].

Una vez descargado, descomprimimos el contenido del archivo en una carpeta, accederemos al interior de esta y ejecutaremos el script que encontraremos llamado: *tinyMediaManagerUpdater.sh*
#+BEGIN_SRC 
./tinyMediaManagerUpdater.sh
#+END_SRC

** Docker
Gracias una vez más al trabajo de [[https://github.com/romancin][Román Martín]], ha creado este contenedor de Tiny Media Manager para arquitectura 64bits, donde nos vamos a evitar todo el tedioso proceso del apartado anterior y podremos montar este contenedor, que nos permitirá acceder a Tiny Media Manager desde nuestro navegador web. Esto nos va a permitir tanto en nuestro PC local, así como si tenemos un servidor, el poder utilizar esta aplicación remotamente.
#+BEGIN_SRC 
docker run -d --name=tinymediamanager \
-v $HOME/tinymediamanager/config:/config \
-v $HOME/docker/media:/media \
-e GROUP_ID=0 -e USER_ID=0 -e TZ=Europe/Madrid \
-p 5800:5800 \
-p 5900:5900 \
romancin/tinymediamanager:latest
#+END_SRC
Una vez montado el contenedor, accederemos en este caso a la ip:5800

** Uso
La verdad es que esta aplicación es de todo, menos amigable. Gracias a Mc Josan del Blog de [[https://naseros.com][NASeros]] (os recomiendo totalmente su blog y [[https://www.youtube.com/channel/UCuxoUnuGxFSHbR5_I4YbA1Q][Canal de vídeos en youtube]]), que hace unos vídeos muy pero que muy bien explicados, nos dejó esta explicación de su uso, que aunque la versión que explica, es una versión anterior de Tiny Media Manager, su uso es exactamente el mismo.

#+HTML:<center><iframe width="560" height="315" src="https://www.youtube.com/embed/1XVnQoTLW5k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center>
- https://www.youtube.com/watch?v=1XVnQoTLW5k
** Fuente

- https://www.tinymediamanager.org/
- https://github.com/romancin/tinymediamanager-docker
- https://naseros.com/2015/12/11/tiny-media-manager-series-2a-parte/


* TODO Los paquetes snap no aparecen una vez instalados
:PROPERTIES:
:TITLE: Los paquetes snap no aparecen una vez instalados
:EXPORT_FILE_NAME: los-paquetes-snap-no-aparecen-una-vez-instalados
:DESCRIPTION: Ya sabéis que últimamente ando utilizando debian como distro principal tanto en mi PC como servidor. Aunque snap funciona perfectamente en Debian, es posible que no quede plenamente del todo
:EXPORT_DATE: 2019-12-04 17:55
:CATEGORY: snap
:TAG: ubuntu,debian
:IMAGE: ./images-blog/snap.png
:END:


Ya sabéis que últimamente ando utilizando debian como distro principal tanto en mi PC como servidor. Aunque snap funciona perfectamente en Debian, es posible que no quede plenamente del todo integrado y cuando instalas un snap, por ejemplo *mumble*, si lo escribes en tu terminal, *no hay respuesta*, la sensación que te queda es que no lo has instalado, pero realmente *si*.

#+HTML: <center>
[[./images-blog/snap.png]]
#+HTML: </center>

Los ejecutables de los paquetes snap que instalamos, están situados en la carpeta =/snap/bin/=, así que sería tan sencillo como ejecutar en la terminal: =/snap/bin/mumble=

La verdad, es que esto no queda del todo elegante. Lo ideal sería simplemente escribir *mumble*, como cualquier otra aplicación del propio sistema. Así que vamos a solucionar este pequeño problema

** Añadiendo los snaps a Debian

La solución es tan sencilla como añadir la final del archivo *.bashrc* o *.zshrc*, la siguiente línea:
#+BEGIN_SRC 
PATH=$PATH:/snap/bin
#+END_SRC
- Ahora si reinicias tu termial, cuando escribas *mumble*, se ejecutará el snap sin problemas.
* TODO Instalando SSH en Fedora, Centos o RedHat
:PROPERTIES:
:TITLE: Instalando SSH en Fedora, Centos o RedHat
:EXPORT_FILE_NAME: instalando-ssh-en-fedora-centos-o-redhat
:DESCRIPTION: Por defecto Fedora no tiene habilitado SSH. Para hacerlo, primero tenemos que instalar OpenSSH.
:EXPORT_DATE: 2019-12-11 20:30
:CATEGORY: ssh
:TAG: fedora,centos,redhat
:IMAGE: ./images-blog/fedora.png
:END:

Por defecto Fedora no tiene habilitado SSH. Para hacerlo, primero tenemos que instalar OpenSSH.

#+HTML: <center>
[[./images-blog/fedora.png]]
#+HTML: </center>


** Instalación
#+BEGIN_SRC 
dnf -y install openssh-server openssh-clients
#+END_SRC
** Crear e iniciar servicio

Con *systemctl enable*, creamos y habilitamos el servicio, para que la siguiente vez que arranquemos Fedora, inicie nuestro servidor SSH.
#+BEGIN_SRC 
systemctl enable sshd.service
#+END_SRC
Iniciamos el servicio
#+BEGIN_SRC 
systemctl start sshd.service
#+END_SRC

Ahora ya podemos conectarnos por SSH a nuestro Fedora

* TODO Remmina. De los mejores Clientes VNC
:PROPERTIES:
:TITLE: Remmina. De los mejores Clientes VNC
:EXPORT_FILE_NAME: remmina-de-los-mejores-clientes-vnc
:DESCRIPTION: Utilizo VNC para conectarme a mis servidores o PC's remotos con interfaz gráfica. Hay muchos clientes de VNC, pero *remmina* es uno de mis favoritos, porque puedo acceder a mis
:EXPORT_DATE: 2019-12-18 18:25
:CATEGORY: vnc
:TAG: servidor,escritorio
:IMAGE: ./images-blog/remmina.png
:END:


Utilizo VNC para conectarme a mis servidores o PC's remotos con interfaz gráfica. Hay muchos clientes de VNC, pero *remmina* es uno de mis favoritos, porque puedo acceder a mis escritorios desde el icono en la bandeja de entrada situado en mi escritorio.

Os recomiendo este cliente, ya que en linux tenemos muchos clientes buenísimos y livianos, pero pocos tan sencillos e intuitivos como este.

#+HTML: <center>
[[./images-blog/remmina.png]]
#+HTML: </center>


Es una aplicación que tiene constantes actualizaciones

** Instalación
*** Desde Repositorios 
#+BEGIN_SRC 
sudo apt install remmina
#+END_SRC
*** Snap

#+begin_src 
sudo snap install remmina
#+end_src

*** Flatpak

#+begin_src 
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
flatpak install --user flathub org.remmina.Remmina
flatpak run --user org.remmina.Remmina
#+end_src

*** PPA todas las distros
Visita la web: https://remmina.org/how-to-install-remmina/
** Archivos de configuración
Puedes guardar tu configuración para exportarlo a otra máquina, copiando los archivos de configuración en las siguientes rutas:
*** Repositorios o PPA
Si has instalado desde repositorios o PPA:
#+BEGIN_SRC 
/home/usuario/.local/share/remmina/ 
/home/usuario/.remmina/
#+END_SRC

*** Flatpak
#+BEGIN_SRC 
~/.var/app/org.remmina.Remmina/data/remmina/
#+END_SRC
*** Snap
#+BEGIN_SRC 
~/snap/remmina/
#+END_SRC
** Icono en bandeja de entrada
Escribe en tu terminal:
#+begin_src 
Remmina -i
#+end_src

Si utilizas un escritorio como *i3wm*, puedes hacer que inicie al arranque del escritorio y añada el icono en tu escritorio, añadiendo a tu archivo de configuración:
#+BEGIN_SRC 
exec --no-startup-id remmina -i
#+END_SRC
** Ayuda 

La terminal nos muestra muchas de las posibilidades de *remmina*. 

Para acceder a esta ayuda, escribe en tu terminal: =remmina -h=

#+BEGIN_SRC 
  org.remmina.Remmina [OPCIÓN…] FILE

Opciones de ayuda:
  -h, --help                  Mostrar opciones de ayuda
  --help-all                  Muestra todas las opciones de ayuda
  --help-gapplication         Mostrar las opciones de GApplication
  --help-gtk                  Mostrar opciones GTK+

Opciones de la aplicación:
  -a, --about                 Mostrar la ventana Acerca de
  -c, --connect=FILE          Connect to desktop described by file (.remmina or type supported by plugin)
  -e, --edit=FILE             Edit desktop connection described by file (.remmina or type supported by plugin)
  -k, --kiosk                 Start Remmina in Kiosk mode
  -n, --new                   Crear un perfil de conexión nuevo
  -p, --pref=PAGENR           Mostrar página de diálogo de preferencias
  -x, --plugin=PLUGIN         Ejecutar el complemento
  -q, --quit                  Salir de la aplicación
  -s, --server=SERVER         Usar nombre de servidor predeterminado (para --nuevo)
  -t, --protocol=PROTOCOL     Usar protocolo predeterminado (para --nuevo)
  -i, --icon                  Iniciar como icono de la bandeja
  -v, --version               Mostrar la versión de la aplicación
  -V, --full-version          Show the application’s version, including the plugin versions
  --display=VISOR             Visor [display] X que usar
#+END_SRC

** Fuentes

- https://remmina.org/
- https://snapcraft.io/remmina
* TODO Habilitar Repositorios Privativos en Debian
:PROPERTIES:
:TITLE: Habilitar Repositorios Privativos en Debian
:EXPORT_FILE_NAME: habilitar-repositorios-privativos-en-debian
:DESCRIPTION: Es probable que tengas una tarjeta gráfica especifica que te gustaría sacarle todo el potencial, o simplemente descomprimir un archivo *.rar* que te han dejado y no sabes como descomprimirlo.
:EXPORT_DATE: 2019-12-20 22:40
:CATEGORY: debian
:TAG: bash
:IMAGE: ./images-blog/debian.jpg
:END:

Es probable que tengas una tarjeta gráfica especifica que te gustaría sacarle todo el potencial, o simplemente descomprimir un archivo *.rar* que te han dejado y no sabes como descomprimirlo. Estas utilizando Debian y tienes que habilitar los repositorios privativos.

#+HTML: <center>
[[./images-blog/debian.jpg]]
#+HTML: </center>


Por defecto, Debian viene habilitada solo con la rama *main* (rama principal), una rama donde encontraremos la gran parte de los paquetes que utilizaremos. Aunque el objetivo de Debian es tener todo sus paquetes totalmente libres, hay usuarios que demandan paquetes privativos para poder hacer uso de lo anteriormente explicado, así que Debian añade dos ramas más en sus servidores:

Ramas disponibles en Debian:
- main: Son paquetes 100% libres y que cumplen con las directrices de software libre de Debian
- contrib: Hay paquetes que cumplen con las directrices de software libre de Debian, pero contienen paquetes no libres.
- non-free: Contiene paquetes privativos


** Añadiendo los repositorios con paquetes privativos
Por defecto, como he explicado antes, Debian solo tiene habilitada la rama *main*. Para habilitar el resto de ramas, tenemos que editar el archivo *sources.list*:
#+BEGIN_SRC 
sudo su                        # entrar como root
nano /etc/apt/sources.list     # editar archivo, por ejemplo con nano
#+END_SRC

*El contenido que aparecerán en el archivo, son los servidores para acceder a los repositorios de Debian así como la versión. Pueden ser diferentes en función de la versión de Debian, así como los servidores que decidiste utilizar en el momento de la primera instalación.*

El listado de servidores en el momento de la instalación, es muy amplio. Puedes decidir entre uno u otro en función de tu ubicación, por ejemplo.

Por defecto, tomando de ejemplo Debian Buster, en el archivo encontramos solo habilitado el repositorio *main*.
#+BEGIN_SRC 
deb http://deb.debian.org/debian/ buster main 
deb-src http://deb.debian.org/debian/ buster main 

deb http://security.debian.org/debian-security buster/updates main 
deb-src http://security.debian.org/debian-security buster/updates main 

# buster-updates, previously known as 'volatile'
deb http://deb.debian.org/debian/ buster-updates main 
deb-src http://deb.debian.org/debian/ buster-updates main 
#+END_SRC

Para habilitar los repositorios *contrib* y *non-free*, es tan sencillo como añadir las palabras =contrib non-free= al final de la línea

#+BEGIN_SRC 
deb http://deb.debian.org/debian/ buster main contrib non-free
deb-src http://deb.debian.org/debian/ buster main contrib non-free

deb http://security.debian.org/debian-security buster/updates main contrib non-free
deb-src http://security.debian.org/debian-security buster/updates main contrib non-free

# buster-updates, previously known as 'volatile'
deb http://deb.debian.org/debian/ buster-updates main contrib non-free
deb-src http://deb.debian.org/debian/ buster-updates main contrib non-free
#+END_SRC

** Actualizar
Ahora solo nos queda actualizar los repositorios para poder instalar cualquier paquete que esté disponible en cualquiera de las tres ramas:
#+BEGIN_SRC 
apt update
#+END_SRC

** Fuentes 
- https://www.debian.org/doc/manuals/debian-reference/ch02.es.html#_debian_is_100_free_software
- https://www.debian.org/social_contract#guidelines

* TODO Docker: Bitwarden. Un servidor de contraseñas en tu Raspberry Pi
:PROPERTIES:
:TITLE: Docker: Bitwarden. Un servidor de contraseñas en tu Raspberry Pi
:EXPORT_FILE_NAME: docker-bitwarden-un-servidor-de-contrasenas-en-tu-raspberry-pi
:DESCRIPTION: Hace un tiempo utilizaba como gestor de contraseñas Keepass, pero desde que descubrí Bitwarden, no dudé en dar el cambio.
:EXPORT_DATE: 2019-12-21 00:05
:CATEGORY: docker
:TAG: servidor,raspberry
:IMAGE: ./images-blog/bitwarden.png
:END:

Hace un tiempo utilizaba como gestor de contraseñas Keepass, pero desde que descubrí Bitwarden, no dudé en dar el cambio.

#+HTML: <center>
[[./images-blog/bitwarden.png]]
#+HTML: </center>

Uno de mis requisitos, era que funcionara en mi Raspberry. Como siempre os comento, tener todos mis servicios en una placa que tan solo consume unos 4(w), en el caso de la Raspberry 4, me permite tener muchos servicios por muy bajo coste.

No encontraba un contenedor que funcionara bien en mi Raspberry, hasta que Carlos del [[https://elblogdelazaro.gitlab.io/][Blog de Lazaro]], me recomendó este.

El servidor de Bitwarden funciona muy bien también en la Raspberry 3, es un servicio muy ligero, así que vale la pena utilizarlo.

Mediante el cliente de Android, Plugin de Firefox o Google Chrome,... me permite tener las contraseñas en todos mis dispositivos. El Plugin del navegador es genial. Te sugiere el guardar una contraseña si no la tienes guardada o auto escribir el usuario y contraseña, cada vez que accedes a un servicio, si este tienes la contraseña guardada.


Recuerda que este contenedor no es oficial, pero el Dockerfile está disponible en un repositorio de GitHub.
** Docker Raspberry Pi
El puerto en el que corre el servicio en este ejemplo, es el puerto 80. Si quisieramos exponerlo en el puerto 90, por ejemplo, utilizariamos: *-p 90:80*.
#+BEGIN_SRC 
docker run -d --name bitwarden -v $HOME/docker:/data/ -p 80:80 bitwardenrs/server:raspberry
#+END_SRC
** Docker ARM 64bits
Si tienes una placa ARM con procesador de 64bits, también tiene una versión exclusiva. Visita la [[https://hub.docker.com/r/bitwardenrs/server/tags][sección de Tags]]
#+BEGIN_SRC 
docker run -d --name bitwarden -v $HOME/docker:/data/ -p 80:80 bitwardenrs/server:aarch64
#+END_SRC

** Docker amd64

#+BEGIN_SRC 
docker run -d --name bitwarden -v $HOME/docker:/data/ -p 80:80 bitwardenrs/server:latest
#+END_SRC

** Fuente
- https://hub.docker.com/r/bitwardenrs
- https://github.com/dani-garcia/bitwarden_rs


* TODO Convertir texto a voz con espeak
:PROPERTIES:
:TITLE: Convertir texto a voz con espeak
:EXPORT_FILE_NAME: convertir-texto-a-voz-con-espeak
:DESCRIPTION: Este medio día, he visto nuevamente un clásico, Juegos de Guerra (War Games) y la voz del Súper ordenador me ha recordado a mi Raspberry con espeak.
:EXPORT_DATE: 2019-12-23 17:40
:CATEGORY: tts
:TAG: bash
:IMAGE: ./images-blog/espeak.png
:END:

Este medio día, he visto nuevamente un clásico, Juegos de Guerra (War Games) y la voz del Súper ordenador me ha recordado a mi Raspberry con espeak.  

Mediante la terminal, podemos hacer que nuestro GNU/Linux hable como un robot y lea todo el texto que introduzcamos en nuestra terminal, archivo, etc...

#+HTML: <center>
[[./images-blog/espeak.png]]
#+HTML: </center>

Espeak es un tts (text to speech), que precisamente no reproduce una voz muy real. Hoy en día la voz tts de google suena muchísimo mejor, pero puede ser muy útil para algún proyecto sencillo en nuestra Raspberry.


** Instalación
Espeak esta en los respositorios de todas las distros. La instalación en ubuntu, debian,raspbian,... es tan sencilla como:
#+BEGIN_SRC 
sudo apt-get install espeak
#+END_SRC
** Funcionamiento
Tan sencillo como:
#+BEGIN_SRC 
espeak 'Hello! How are you!'
#+END_SRC
** Idiomas
Por defecto, *espeak* habla en inglés. Así que si quieres que lea el texto con pronunciación en castellano, tendremos que indicarle que así lo haga.

Para ver todos los idiomas disponibles:
#+BEGIN_SRC 
espeak --voices
#+END_SRC
*** Castellano

Primero, indicaremos mediante *-v*, que vamos a utilizar un nuevo idioma.

Para indicar que este será castellano, escribiremos *es*.

El resultado final será: *-ves*.
#+BEGIN_SRC 
espeak -ves 'Hola, ahora hablo castellano'
#+END_SRC
*** Catalán
También podemos utilizar el catalán entre otros idiomas. Nos ayudaremos de *grep* para ver si está disponible el catalan
#+BEGIN_SRC 
espeak --voices | grep catalan
#+END_SRC
Probemos que tal suena:
#+BEGIN_SRC 
espeak -vca 'Bon dia'
#+END_SRC

** Listar voces disponibles
Espeak no solo tiene la voz por defecto. Para listar todas las voces disponibles:
#+BEGIN_SRC 
espeak --voices=variant
#+END_SRC
Para indicar la voz que deseamos utilizar, tenemos que añadir *+* acompañado del resultado que aparece en la columna *FILE*. Hay varias opciones, *m* corresponde a una voz masculina y *f* a una femenina.

Voces disponibles en Debian Buster:

#+BEGIN_SRC 
Pty Language Age/Gender VoiceName          File          Other Languages
 5  variant        F  female2              !v/f2         
 5  variant        F  female3              !v/f3         
 5  variant        F  female4              !v/f4         
 5  variant        F  female5              !v/f5         
 5  variant        F  female_whisper       !v/whisperf   
 5  variant        -  klatt                !v/klatt      
 5  variant        -  klatt2               !v/klatt2     
 5  variant        -  klatt3               !v/klatt3     
 5  variant        -  klatt4               !v/klatt4     
 5  variant        M  male2                !v/m2         
 5  variant        M  male3                !v/m3         
 5  variant        M  male4                !v/m4         
 5  variant        M  male5                !v/m5         
 5  variant        M  male6                !v/m6         
 5  variant        M  male7                !v/m7         
 5  variant        M  whisper              !v/whisper    
 5  variant      70F  female1              !v/f1         
 5  variant      70M  croak                !v/croak      
 5  variant      70M  male1                !v/m1 
#+END_SRC

Vamos a ver un ejemplo:
#+BEGIN_SRC 
espeak -ves+f2 'Esto es una prueba de voz desde mi Raspberry'
#+END_SRC
** Velocidad
Podemos variar la velocidad de reproducción de la voz. Para eso utilizaremos la opción *-s*.

El valor por defecto es *160*. 

Veamos un ejemplo:
#+BEGIN_SRC 
espeak -ves+f2 -s130 'Ahora hablo más lento' 
#+END_SRC
** Tono
Para personalizar aun más la voz elegida, utilizaremos *-p*.

Por defecto, el tono de voz está a *50*.

#+BEGIN_SRC 
espeak -ves+f2 -s130 -p80 'Ahora he cambiado un poco mi tono de voz'
#+END_SRC

** Leer un archivo de texto
Ya hemos decidido el idioma, velocidad, voz,... Ejecutar *espeak* mediante *echo*, está bien como respuestas a un scripts. Si queremos que lea un archivo de texto:
#+BEGIN_SRC 
espeak -f archivo.txt
#+END_SRC
Siguiendo la configuración previa:
#+BEGIN_SRC 
espeak -ves+f2 -s130 -p80 -f archivo.txt
#+END_SRC

** Guardar la voz en un archivo de audio 
En lugar de escucharlo por nuestros altavoces, podemos hacer que todo lo que lea espeak lo guarde en un archivo de audio tipo wav, ogg o mp3.

Para ello haremos uso de la opción *-w*.

Espeak por defecto, solo tiene la opción para exportar a *wav*, así que para obtener un archivo *mp3* u *ogg*, tendremos que convertirlo.

*** Wav
Voy a exportar el archivo a *.wav*.
#+BEGIN_SRC 
espeak -ves+f2 -s130 -p80 -f archivo.txt -w 'archivo de audio.wav'
#+END_SRC
*** Ogg
Instalaremos vorbis-tools
#+BEGIN_SRC 
sudo apt install vorbis-tools
#+END_SRC
Convertir el archivo wav en ogg.
#+BEGIN_SRC 
oggenc 'archivo de audio.wav'
#+END_SRC


*** mp3

Para convertir de wav a mp3, utilizaremos *lame*.

Primero lo instalaremos
#+BEGIN_SRC 
sudo apt install lame
#+END_SRC
Ahora convertimos:
#+BEGIN_SRC 
lame archivo.wav archivo.mp3
#+END_SRC
** Versión gráfica de espeak
Si no te gusta la terminal, podemos utilizar una aplicación gráfica llamada gespeaker
#+BEGIN_SRC 
sudo apt install gespeaker
#+END_SRC

** Ayuda
#+BEGIN_SRC 
espeak -h
#+END_SRC
** Fuente
- http://espeak.sourceforge.net/
- https://debianfacil.wordpress.com/2009/03/10/espeak-convertir-texto-en-voz/
* TODO Instalar un Servidor con Debian
:PROPERTIES:
:TITLE: Instalar un Servidor con Debian
:EXPORT_FILE_NAME: instalar-un-servidor-con-debian
:DESCRIPTION: Quizás te estas planteando el montarte un servidor con debian, pero no sabes muy bien por donde empezar. Si has instalado alguna vez debian, la imagen contiene varias versiones de
:EXPORT_DATE: 2019-12-28 21:45
:CATEGORY: servidor
:TAG: debian
:IMAGE: ./images-blog/debian.png
:END:

Quizás te estas planteando el montarte un servidor con debian, pero no sabes muy bien por donde empezar. Si has instalado alguna vez debian, la imagen contiene varias versiones de escritorio, pero... *¿Dónde está la versión de servidor?*

#+HTML: <center height="250" width="250">
[[./images-blog/debian.jpg]]
#+HTML: </center>


Si no has instalado nunca debian, la instalación es muy simple, igual que el resto de distros. La imágen la encontrarás en https://www.debian.org. Una vez grabada en un CD-ROM o USB, al inicio te da a elegir que tipo de instalador deseas utilizar, uno gráfico u otro para terminal. Ambos tienen los mismo pasos. 

- Poner tu usuario y contraseña
- Contraseña para *root*
- En que partición deseas instalar Debian
- Que servidores deseas utilizar para descargarte los paquetes...

Llegando casi al final de la instalación, nos pregunta que tipo de escritorio queremos utilizar para Debian. 

Tendremos que seleccionar la opción *SSH server*.

#+HTML: <center>
[[./images-blog/debian-server1.png]]
#+HTML: </center>

Ahora si, al final, nos pregunta donde instalar el cargador del GRUP. Tiene que estar en una partición, que será el primer lugar donde accederá nuestra máquina y así podrá arrancar Debian.

#+HTML: <center>
[[./images-blog/debian-server2.png]]
#+HTML: </center>

** Saber la ip del servidor
Ya tenemos nuestro servidor y tal como hemos hecho en los pasos anteriores, en lugar de instalar un entorno de escritorio, hemos instalado un servidor *SSH*, para acceder a nuestro servidor.

Para conocer y acceder al servidor, necesitamos conocer la ip. 
#+BEGIN_SRC 
ip a
#+END_SRC
Ahora que ya la conocemos, podremos acceder a nuestro servidor. Para que con el tiempo nuestro router no cambie la ip y nos volvamos locos averiguando que pasa, debemos otorgarle una ip fija o estática.

** Instalando sudo
En Debian, cuando tenemos que instalar un programa o modificar algo del sistema, tenemos que entrar como usuario *root*, no funciona igual que en Ubuntu, Raspbian, etc...

Aunque se que instalando *sudo* y modificando el archivo */etc/sudoers* con *visudo*, podemos utilizar sudo igual que en ubuntu, he decidido no hacerlo por seguridad, ya que debian no lo recomienda. 

Pero cuando he ido a instalar *Syncthing*, al añadir los repositorios de Syncthing, debian me pedía el poner *sudo* y como debian-server viene con lo justo, no tiene ni el comando sudo instalado. 

Así que si necesitas instalarlo:


#+BEGIN_SRC 
apt-get install sudo
#+END_SRC

** Conclusión

Tener un servidor con Debian está genial, ya que Debian es muy estable, traé solo lo justo para funcionar y poco a poco vas construyendo tu servidor con solo aquello que necesitas. 

Hay unas pequeñas diferencias respecto a Ubuntu o Raspbian, como lo que explicaba en el apartado anterior, pero en poco tiempo te acabas adaptando.

* TODO Bullet Journal Digital en OrgMode
:PROPERTIES:
:TITLE: Bullet Journal Digital en OrgMode
:EXPORT_FILE_NAME: bullet-journal-digital-en-orgmode
:DESCRIPTION: Si eres un amante del Bullet Journal y OrgMode, estas de suerte. Hace algo más de un año, hice un script en bash para crear la plantilla de lo que
:EXPORT_DATE: 2019-12-30 19:46
:CATEGORY: emacs
:TAG: orgmode,notas,diario,bulletjournal
:IMAGE: ./images-blog/bujo.png
:END:


Si eres un amante del Bullet Journal y OrgMode, estas de suerte. Hace algo más de un año, hice un script en bash para crear la plantilla de lo que sería una libreta Bullet Journal, pero en formato digital.


#+HTML:  <center height="250" width="250">
[[./images-blog/bujo.png]]
#+HTML: </center>


Como no puede ser de otra manera, vamos a utilizar OrgMode como formato, para tener todas las tareas, trackers y la gestión del día a día en este Bullet Journal.

En la parte final del OrgMode, he añadido un diario con todos los días, donde podremos escribir en unas breves líneas, todo aquello que vamos haciendo.


Ahora conozco más *bash* y podría mejorarlo, pero la verdad es que funciona muy bien y quizás no vale la pena.


Vamos a crear nuestro Bullet Journal!!!
** Clonando el Repositorio
Primero vamos a clonar el repositorio que tengo en GitHub
#+BEGIN_SRC 
git clone https://github.com/uGeek/bujo-digital.git
#+END_SRC
** Creando el Bullet Journal
Una vez clonado el repositorio, encontraremos dos scritps, *bujo.sh* y *bujo-ca.sh*, traducido al catalán por Alfons.

Ejecuta bujo.sh
#+BEGIN_SRC 
./bujo.sh
#+END_SRC
El script te preguntará para que año quieres generar este Bullet Journal. En este caso, 2020.

Encontrarás en esta misma carpeta, el archivo [[https://raw.githubusercontent.com/uGeek/bujo-digital/master/bujo-2020.org][bujo-2020.org]].

#+HTML:<center>
#+HTML:<img src="https://raw.githubusercontent.com/uGeek/bujo-digital/master/images/bujo-ca.gif">
#+HTML:</center>

Ya tienes tu Bullet Journal 2020 y Diario para Org Mode!!!. Ahora puedes utilizarlo con Emacs, Orgzly, etc...

[[https://raw.githubusercontent.com/uGeek/bujo-digital/master/bujo-2020.org][Descarga el Bullet Journal del 2020]]
** Fuentes
- Repositorio en GitHub: https://github.com/uGeek/bujo-digital
- Imagen de https://unsplash.com/photos/mO3s5xdo68Y
* TODO Supysonic 0.5.0. Total compatibilidad con todos los clientes Subsonic
:PROPERTIES:
:TITLE: Supysonic 0.5.0. Total compatibilidad con todos los clientes Subsonic
:EXPORT_FILE_NAME: supysonic-0-5-0-total-compatibilidad-con-todos-los-clientes-subsonic
:DESCRIPTION: Como os comenté en el podcast y artículo sobre Supysonic, una de las limitaciones que tenía, es la limitación de su *api* que hacia que no fuera 100% compatible con
:EXPORT_DATE: 2019-12-31 18:00
:CATEGORY: supysonic
:TAG: subsonic,servidor,musica,raspberry
:IMAGE: ./images-blog/subsonic.png
:END:

Como os comenté en el podcast y artículo sobre Supysonic, una de las limitaciones que tenía, es la limitación de su *api* que hacia que no fuera 100% compatible con la totalidad de clientes para Subsonic disponibles. Eso hacía que aplicaciones como *Clementine* en escritorio o la propia aplicación oficial de *Subsonic*, no funcionaran con este servidor.

*Esto ha llegado a su fin!!!*

#+HTML: <center>
[[./images-blog/subsonic.png]]
#+HTML: </center>

Con la nueva actualización del servidor de Supysonic versión 0.5.0, actualizada hace solo 6 dias, ha mejorado y actualizado su *api* y ahora podrás utilizarlo con el cliente que desees.

Como podrás imaginar, no me he podido resistir a actualizar [[https://hub.docker.com/r/ugeek/supysonic][el docker]].

Ahora mientras estoy utilizando mi PC, estoy escuchando música en streaming con [[https://www.clementine-player.org/es/][Clementine]], gracias al docker montado con el servidor Supysonic en mi Raspberry.

*Si tienes una versión anterior de Supysonic, el volumen de configuración es incompatible con esta nueva versión, tendrás que crear un volumen de configuración nuevo*.

Otra diferencia, es que algunos comandos de supysonic-cli, en esta versión han cambiado y son diferentes a versiones anteriores.

** Montar Docker Versión 0.5.0
*** Raspberry o ARM 32bits
#+BEGIN_SRC 
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:arm-0.5.0
#+END_SRC
Una vez se monte, se ejecutará el servidor, para salir tendremos que teclear en la terminal *Ctrl+c*.

*** amd64
#+BEGIN_SRC 
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:amd64-0.5.0
#+END_SRC
Una vez se monte, se ejecutará el servidor. Para salir tendremos que teclear en la terminal *Ctrl+c*.

** Iniciando Supysonic

Iniciamos el docker
#+BEGIN_SRC 
docker start supysonic
#+END_SRC
Entramos dentro del contenedor para crear el administrador
#+BEGIN_SRC 
docker exec  -it supysonic sh
#+END_SRC
También podemos acceder a la interfaz web de adminstración a http://tu_ip:8080

*** Crear usuario

Dentro ya del conenedor, voy a crear el usuario *angel*.
#+BEGIN_SRC 
supysonic-cli user add angel -p mi_contraseña
#+END_SRC
A este usuario, voy ha hacerlo administrador, para añadir mi biblioteca musical
#+BEGIN_SRC 
supysonic-cli user  setroles -A angel
#+END_SRC
Si queremos cambiar la contraseña
#+BEGIN_SRC 
supysonic-cli user changepass angel nueva_contraseña
#+END_SRC

*** Añadir Biblioteca

Para añadir la biblioteca musical utilizaremo: *supysonic-cli folder add <name> <path>*

La carpeta */media/*, viene añadida por defecto. Si quieres añadir varias subcarpetas y escanerarla por separado como yo, tienes que eliminar esta carpeta por defecto, ya que no puede escanear subcarpetas que están dentro de una carpeta principal. Vamos, una carpeta compartida en dos bibliotecas.

Tengo una carpeta donde añado las novedades, la carpeta *new*.
#+BEGIN_SRC 
supysonic-cli folder add New /media/new/
#+END_SRC
Escanera la biblioteca con nombre *New*, en la carpeta */media/new/*
#+BEGIN_SRC 
supysonic-cli folder scan -f New
#+END_SRC
Escanear simultáneamente dos subcarpetas que tengo, la carpeta *new* y *favoritos*.

#+BEGIN_SRC 
supysonic-cli folder scan -f New Favoritos
#+END_SRC

*** Mas opciones
Siguiendo los ejemplos anteriores, añado la ayuda disponible en [[https://github.com/spl0k/supysonic/blob/master/docs/cli.md][GitHub]].

** Interfaz de línea de comandos
La interfaz de línea de comandos (a menudo abreviada CLI) es una interfaz que permite operaciones de administración sin el uso de la interfaz web. Puede ejecutarse en modo interactivo ( supysonic-cli) o emitir un solo comando ( supysonic-cli <argumentos>).

Si ejecuta sin argumentos, supysonic-cli abrirá un mensaje interactivo. Puede usar la herramienta de línea de comandos para hacer algunas cosas:

*** Comandos de ayuda
Cuando estas perdido...
#+BEGIN_SRC 
Usage:
    supysonic-cli help
    supysonic-cli help user
    supysonic-cli help folder

Arguments:
    user                        Display the help message for the user command
    folder                      Display the help message for the folder command
#+END_SRC
*** Comandos de gestión de usuarios
#+BEGIN_SRC 
Usage:
    supysonic-cli user add <user> [-p <password>] [-e <email>]
    supysonic-cli user delete <user>
    supysonic-cli user changepass <user> <password>
    supysonic-cli user list
    supysonic-cli user setroles [-a|-A] [-j|-J] <user>

Arguments:
    add                         Add a new user
    delete                      Delete the user
    changepass                  Change the user's password
    list                        List all the users
    setroles                    Give or remove rights to the user

Options:
  -p --password <password>      Specify the user's password
  -e --email <email>            Specify the user's email
  -a --noadmin                  Revoke admin rights
  -A --admin                    Grant admin rights
  -j --nojukebox                Revoke jukebox rights
  -J --jukebox                  Grant jukebox rights
#+END_SRC

*** Comandos de gestión de carpetas
#+BEGIN_SRC 
Usage:
    supysonic-cli folder add <name> <path>
    supysonic-cli folder delete <name>
    supysonic-cli folder list
    supysonic-cli folder scan [-f] [--background | --foreground] [<name>...]

Arguments:
    add                         Add a new folder
    delete                      Delete a folder
    list                        List all the folders
    scan                        Scan all or specified folders

Options:
  -f --force                    Force scan of already known files even if they
                                haven't changed
  --background                  Scan in the background. Requires the daemon to
                                be running.
  --foreground                  Scan in the foreground, blocking the process
                                while the scan is running
#+END_SRC
** Fuente
- https://github.com/spl0k/supysonic
- https://hub.docker.com/r/ugeek/supysonic

 
* TODO Controlando mis Contenedores desde Android
:PROPERTIES:
:TITLE: Controlando mis Contenedores desde Android
:EXPORT_FILE_NAME: controlando-mis-contenedores-desde-android
:DESCRIPTION: Buscando una aplicación practica para controlar mis contenedores desde el móvil, me topé con  [[https://play.google.com/store/apps/details?id=com.nevishs.drawerdockerapp:DESCRIPTION:hl=es_419][Docker Management]], una aplicación de acceso anticipado que no se conecta a ningún servidor extraño,
:EXPORT_DATE: 2020-01-01 18:00
:CATEGORY: docker
:TAG: android,contenedores
:IMAGE: ./images-blog/dockermanagement.png
:END:

Buscando una aplicación practica para controlar mis contenedores desde el móvil, me topé con  [[https://play.google.com/store/apps/details?id=com.nevishs.drawerdockerapp&hl=es_419][Docker Management]], una aplicación de acceso anticipado que no se conecta a ningún servidor extraño, no tiene publicidad y tiene justo lo que buscaba, una aplicación para iniciar, detener y borrar mis contenedores e imágenes.

#+HTML: <center>
[[./images-blog/dockermanagement.png]]
#+HTML: </center>

Pero [[https://play.google.com/store/apps/details?id=com.nevishs.drawerdockerapp&hl=es_419][Docker Management]] hace mucho más

** Opciones
- conectarse a múltiples servidores
- enumerar, crear, iniciar, detener, reiniciar, eliminar, contenedores
- ver el uso de recursos de los contenedores
- ver registros de contenedores
- enumerar, construir, eliminar imágenes
- conectarse mediante contraseña o rsa

#+HTML: <center>
[[./images-blog/dockermanagement1.png]]
#+HTML: </center>

** Características principales 
- las credenciales están encriptadas
- la información del servidor se almacena solo en el teléfono (se borra si se elimina la aplicación)

#+HTML: <center>
[[./images-blog/dockermanagement2.png]]
#+HTML: </center>


** Conclusiones
Si tienes Android, no tienes nada que perder instalándola y dejándola, por si en algún momento tienes pereza de utilizar la terminal. Además, los permisos de la aplicación son los justos:
Información de la conexión Wi-Fi, ver conexiones wifi, ver conexiones de red, acceso completo a la red.

[[https://play.google.com/store/apps/details?id=com.nevishs.drawerdockerapp&hl=es_419][Instálala desde Google Play haciendo click aquí]]

** Fuente
- Desarrollador: nevis.applications@gmail.com Toronto, Canadá





* TODO Bat, el Cat enriquecido
:PROPERTIES:
:TITLE: Bat, el Cat enriquecido
:EXPORT_FILE_NAME: bat-el-cat-enriquecido
:DESCRIPTION: Bat es un cat enriquecido. Lo veo un poco como una mezcla de cat + less.
:EXPORT_DATE: 2020-01-04 10:00
:CATEGORY: bash
:TAG: zsh,terminal,aplicación
:IMAGE: ./images-blog/bat.svg
:END:


Bat es un *cat* enriquecido. Lo veo un poco como una mezcla de *cat* + *less*.

Permite el resaltado de sintaxis de una gran cantidad de lenguajes de programación y marcado, entre ellos el *orgmode*, *csv*, *markdown*, *html*, *bash*, *python*, ... 


#+HTML: <center>
[[./images-blog/bat.svg]]
#+HTML: </center>



Muestra caracteres no imprimibles, canaliza su propia salida a *less* cuando la salida es demasiado grande para una pantalla. También se integra con git.

** Instalación
*** Raspberry

Descargamos el paquete *.deb*
#+BEGIN_SRC 
wget https://github.com/sharkdp/bat/releases/download/v0.12.1/bat_0.12.1_armhf.deb
#+END_SRC
Instalamos
#+BEGIN_SRC 
sudo dpkg -i bat_0.12.1_armhf.deb
#+END_SRC
*** Para amd64
Descargamos el paquete *.deb*
#+BEGIN_SRC 
wget https://github.com/sharkdp/bat/releases/download/v0.12.1/bat_0.12.1_amd64.deb
#+END_SRC
Instalamos
#+BEGIN_SRC 
sudo dpkg -i bat_0.12.1_armhf.deb
#+END_SRC
*** Restode paqueteria
[[https://github.com/sharkdp/bat/releases][Para Mac, windows,... encontrarás el resto de instalaciones en su repositorio en GitHub]].


** Funcionamiento 
El funcionamiento es exactamente igual que cat
*** Mostrar un solo archivo en el terminal
#+BEGIN_SRC 
bat README.md
#+END_SRC
*** Mostrar varios archivos a la vez 
#+BEGIN_SRC 
bat archivo1 archivo2
#+END_SRC

*** Mostrar Caracteres no imprimibles
Utilizando la opción *-A/ --show-all* muestra y resalta caracteres no imprimibles.
#+BEGIN_SRC 
bat -A archivo.org
#+END_SRC

*** Salir si el archivo es muy largo
Igual que muchas aplicaciones *cli*, inspiradas en *vi*, para salir de la visualización de un archivo muy largo, pulsaremos la tecla *q*.

*** Ayuda
Estas son las opciones que muestra *bat --help*.
#+BEGIN_SRC 
A cat(1) clone with syntax highlighting and Git integration.

USAGE:
    bat [OPTIONS] [FILE]...
    bat <SUBCOMMAND>

OPTIONS:
    -l, --language <language>         Set the language for syntax highlighting.
    -L, --list-languages              Display all supported languages.
    -m, --map-syntax <from:to>...     Map a file extension or name to an existing syntax.
        --theme <theme>               Set the color theme for syntax highlighting.
        --list-themes                 Display all supported highlighting themes.
        --style <style-components>    Comma-separated list of style elements to display (*auto*,
                                      full, plain, changes, header, grid, numbers, snip).
    -p, --plain                       Show plain style (alias for '--style=plain').
    -n, --number                      Show line numbers (alias for '--style=numbers').
    -A, --show-all                    Show non-printable characters (space, tab, newline, ..).
    -r, --line-range <N:M>...         Only print the lines from N to M.
    -H, --highlight-line <N>...       Highlight the given line.
        --color <when>                When to use colors (*auto*, never, always).
        --italic-text <when>          Use italics in output (always, *never*)
        --decorations <when>          When to show the decorations (*auto*, never, always).
        --paging <when>               Specify when to use the pager (*auto*, never, always).
        --wrap <mode>                 Specify the text-wrapping mode (*auto*, never, character).
        --tabs <T>                    Set the tab width to T spaces.
    -h, --help                        Print this help message.
    -V, --version                     Show version information.

ARGS:
    <FILE>...    File(s) to print / concatenate. Use '-' for standard input.

SUBCOMMANDS:
    cache    Modify the syntax-definition and theme cache
#+END_SRC
** Conclusión
Te animo a visitar [[https://github.com/sharkdp/bat][el repositorio de GitHub para ver la documentación y encontrar la utilidad más adaptada a tí]].
** Fuentes 
- https://github.com/sharkdp/bat


 
* TODO Descargando un directorio de git con gitdir
:PROPERTIES:
:TITLE: Descargando un directorio de git con gitdir
:EXPORT_FILE_NAME: descargando-un-directorio-de-git-con-gitdir
:DESCRIPTION: Hoy ojeando *Reddit*, he visto esta magnífica utilidad que nos permite bajar una carpeta determinada de un repositorio de git. La aplicación está desarrollada en Python y como es natural,
:EXPORT_DATE: 2020-01-06 17:50
:CATEGORY: git
:TAG: git,repositorio,github,gitlab
:IMAGE: ./images-blog/git.png
:END:


Hoy ojeando *Reddit*, he visto esta magnífica utilidad que nos permite bajar una carpeta determinada de un repositorio de git. La aplicación está desarrollada en Python y como es natural, tenemos que tener instalado tanto *Python 3*, así como *Pip3*.
#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>

** Instalación 
*** Desde Pip3
#+BEGIN_SRC 
pip3 install --user gitdir
#+END_SRC
En Debian y Raspbian, he tenido que buscar donde se había guardado *gitdir*. =/home/angel/.local/lib/python3.7/site-packages/gitdir/gitdir.py= 


Cambia *angel*, por tu usuario.
#+BEGIN_SRC 
python3 /home/angel/.local/lib/python3.7/site-packages/gitdir/gitdir.py  -h
#+END_SRC
La opción *-h*, es para ofrecernos la ayuda.

#+BEGIN_SRC 
usage: gitdir [-h] [--flatten] url

Download directories/folders from GitHub

positional arguments:
  url

optional arguments:
  -h, --help     show this help message and exit
  --flatten, -f  Flatten directory structures. Do not create extra directory
                 and download found files to current directory.
#+END_SRC

*** Creando un alias
He creado un alias para en cualquier lugar de mi máquina, cuando escriba *gitdir*, pueda utilizar esta aplicación.
#+BEGIN_SRC 
alias gitdir="python3 /home/angel/.local/lib/python3.7/site-packages/gitdir/gitdir.py"
#+END_SRC


*** Clonando el Repositorio 
Otro método de instalación, sería instalando *gitdir* clonando el repositorio de *GitHub*. Primero voy a situarme en raíz del home.

#+BEGIN_SRC 
cd
#+END_SRC
Ahora clonamos el repositorio
#+BEGIN_SRC 
git clone https://github.com/sdushantha/gitdir.git
#+END_SRC
Desde esta misma ruta, recién clonado el repositorio, ya podemos correr *gitdir*.
#+BEGIN_SRC 
python3 gitdir/gitdir/gitdir.py
#+END_SRC
Como veis, está en el directorio =gitdir/gitdir.py= dentro del repositorio.

*** Creando alias
Si hemos clonado el respositorio en la raíz del Home, vamos a crear también el alias.
#+BEGIN_SRC 
alias gitdir="python3 ~/gitdir/gitdir/gitdir.py"
#+END_SRC



** Funcionamiento
Ya tenemos *gitdir* en nuestro sistema, ahora vamos a utilizarlo.

Navega por la web de *GitHub*, por ejemplo, y copia la *url* de una carpeta de un repositorio.

#+BEGIN_SRC 
gitdir <URL>
#+END_SRC

Voy a utilizar esta: https://github.com/sdushantha/gitdir/tree/master/gitdir
#+BEGIN_SRC 
gitdir https://github.com/sdushantha/gitdir/tree/master/gitdir
#+END_SRC
Se descargará la carpeta con todos los archivos que contiene.

** Fuentes
- https://www.reddit.com/r/commandline/comments/avbai1/gitdir_download_a_single_directoryfolder_from_a/
- https://github.com/sdushantha/gitdir
- He forqueado el Repositorio: https://github.com/Bash-Projects/gitdir
* TODO Todoist en Emacs
:PROPERTIES:
:TITLE: Todoist en Emacs
:EXPORT_FILE_NAME: todoist-en-emacs
:DESCRIPTION: Todoist es una aplicación muy conocida para crear y gestionar tus tareas. Con un paquete de Melpa, podremos acceder mediante la api de todoist a todas nuestras listas.
:EXPORT_DATE: 2020-01-08 17:50
:CATEGORY: emacs
:TAG: orgmode,tareas
:IMAGE: ./images-blog/todoist.png
:END:

Todoist es una aplicación muy conocida para crear y gestionar tus tareas. Con un paquete de Melpa, podremos acceder mediante la api de todoist a todas nuestras listas.

#+HTML: <center>
[[./images-blog/todoist.png]]
#+HTML: </center>

** Instalación

Podemos instalarlo desde los [[https://melpa.org/#/todoist][repositorios de Melpa]]
#+BEGIN_SRC 
M-x package-install todoist
#+END_SRC
También podemos añadir el archivo todoist.el, que encontraremos en el [[https://github.com/abrochard/emacs-todoist][repositorio del proyecto]].

** Copia tu Token

Todoist nos proporciona un Token para utilizar su api, vamos a [[https://todoist.com/Users/viewPrefs?page=integrations][acceder aquí para copiar nuestro Token]]

** Archivo de configuración
Copia en tu *.emacs* o *init.el*, la siguiente línea sustituyendo las "XXX...", por nuestro token 

#+BEGIN_SRC 
(setq todoist-token "XXXXXXXXXXXXXXXXXXXX")
#+END_SRC
Ejemplo. Este token es inventado.
#+BEGIN_SRC 
(setq todoist-token "13fc4b42rtrte370a7gqerg0880bae6f4909a71qerg7d")
#+END_SRC
** Ejecuta todoist

Vamos a acceder a todosit. Para ello tenemos que introducir en emacs
#+BEGIN_SRC 
M-x todoist
#+END_SRC
** Uso todoist

- *C-x t* => Abrir el menú de tareas. Crear, actualizar, borrar, cerrar.
- *C-x p* => Abrir el menú de proyectos Nuevo proyecto, actualizar y borrar proyecto

*** Utilizar como Orgmode

También podemos utilizarlo como el OrgMode. Simplemente añadimos una nueva tarea y para que suba a todoist, teclearemos el siguiente atajo =C-x t u=.
** Conclusión
Es una muy buena opción para quien comparte tareas con otros usuarios o está muy habituado a utilizar *Todoist*. Aún así, el orgmode como gestión de tareas, aporta muchísimas más opciones. Pero esta es una demostración más que Emacs es un pequeño sistema operativo.

** Fuentes
- https://github.com/abrochard/emacs-todoist



 
* TODO W3M. Navegador para Terminal y Emacs
:PROPERTIES:
:TITLE: W3M. Navegador para Terminal y Emacs
:EXPORT_FILE_NAME: w3m-navegador-para-terminal-y-emacs
:DESCRIPTION: w3m es un navegador para terminal muy liviano, con el que no solo podremos ver cualquier web en modo texto, sino que además podremos ver también las imágenes.
:EXPORT_DATE: 2020-01-09 19:22
:CATEGORY: emacs
:TAG: orgmode,bash
:IMAGE: ./images-blog/w3m.png
:END:

w3m es un navegador para terminal muy liviano, con el que no solo podremos ver cualquier web en modo texto, sino que además podremos ver también las imágenes. 

Aunque como sabéis, soy pro atajos de teclado y evitar al máximo el ratón, si no se nos da muy bien, también podremos utilizar el ratón en la terminal para abrir los enlaces que van apareciendo en las webs.

#+HTML: <center>
[[./images-blog/w3m.png]]
#+HTML: </center>


w3m también podremos utilizarlo dentro de Emacs, permitiéndonos copiar webs en orgmode, etc,... pero esto lo dejo para otro artículo.

El Objetivo del artículo de hoy, es instalar w3m y conocer los atajos básicos para emacs.



** Instalación
Dependiendo de la distro que utilices, busca los paquetes *w3m* y *w3m-img*.

En Debian y derivadas
#+begin_src 
sudo apt install w3m w3m-img
#+end_src
** Uso
Para abrir w3m y conectarse a google, es tan sencillo como:
#+begin_src 
w3m google.com
#+end_src
Para salir, utilizaremos la tecla *q*.

** W3M en Emacs

Para abrir W3m en Emacs, tendremos que introducir:
#+BEGIN_SRC 
M-x w3m
#+END_SRC
** Atajos
La primera vez que utilizas *w3m* en Emacs, puede ser un poco complicado. Vamos a conocer algunos atajos.

- U -> Ir a una url
- TAB  -> Saltar de un Link a otro
- Enter -> Pulsando sobre el enlace de la imágen, podremos ver esa imágen. Para ocultar, vuelve a pulsar Enter
- T -> Mostrar o ocultar todas las imágenes de la web
- B -> Página Anterior
- N -> Página Siguiente
- J -> Scroll una línea hacia abajo
- K -> Scroll una línea hacia arriba
- M -> Navegador externo
- H -> Ayuda

*** Otros Atajos

- B -> (w3m-view-preview-page) Ir a la pagina anterior
- N -> (w3m-view-next-page) Ir a la página siguiente
- I -> (w3m-view-image) Ver imagen con una aplicación externa
- A -> (w3m-bookmark-add-current-url) Añadir la url activa a les direcciones de interés
- M-a -> (w3m-bookmark-add-this-url) Añadir una url a les direcciones de interés
- v -> (w3m-bookmark-view) Ver las direcciones de interés
- E -> (w3m-bookmark-edit) Visitar el archivo de las direcciones de interés
- C-k -> (w3m-bookmark-kill-entry) Quitar la url de las direcciones de interés

** Configuración personalizada en emacs
Podemos añadir en el archivo de configuración *.emacs* o *init.el*, estas líneas para acceder de un modo más rápido a w3m o navegar por w3m más sencillo.
*** Abrir w3m
Podemos abrir w3m con =M-x w3m=, pero también podemos crear un atajo personalizado.

Abrir w3m con el atajo *C-c w*.
#+BEGIN_SRC 
(global-set-key (kbd "C-c w") 'w3m)    
#+END_SRC
*** Enlaces numerados
Para moverte a máxima velocidad sin tener que desplazarte, enumerando cada enlace de la página web que estamos viendo, utilizamos: =M-x w3m-lnum-goto=

Vamos a crear un atajo, por ejemplo *C-c l*.
#+BEGIN_SRC 
(global-set-key (kbd "C-c l") 'w3m-lnum-goto)
#+END_SRC
*** Abrir w3m y buscar en google
Abrir de w3m con la búsqueda a google. Utilizo por ejemplo, el atajo *C-c g*.
#+BEGIN_SRC 
(global-set-key (kbd "C-c g") 'w3m-search)
#+END_SRC
*** Desplazarte por la página con las flechas del teclado
Para desplazarnos por la web, utiliza los mismo atajos que *vim*, (h,j,k,l). 
Si en su lugar quieres utilizar las flechas del teclado
#+BEGIN_SRC 
(add-hook 'w3m-mode-hook
      (lambda ()
        (local-set-key '[up] 'previous-line)
        (local-set-key '[down] 'next-line)
        (local-set-key '[left] 'backward-char)
        (local-set-key '[right] 'forward-char)))
#+END_SRC
 

* TODO html2txt. Convirtiendo una web a texto plano con w3m
:PROPERTIES:
:TITLE: html2txt. Convirtiendo una web a texto plano con w3m
:EXPORT_FILE_NAME: html2txt-convirtiendo-una-web-a-texto-plano-con-w3m
:DESCRIPTION: Ya hemos aprendido a utilizar w3m en Emacs y desde la terminal. Ahora vamos a convertir cualquier web o archivo *.html* a texto plano.
:EXPORT_DATE: 2020-01-13 17:55
:CATEGORY: w3m
:TAG: bash,zsh
:IMAGE: ./images-blog/w3m.png
:END:

Ya hemos aprendido a utilizar w3m en Emacs y desde la terminal. Ahora vamos a convertir cualquier web o archivo *.html* a texto plano.

#+HTML: <center>
[[./images-blog/w3m.png]]
#+HTML: </center>

** Convertir a txt
Tan sencillo como escribir en la terminal:
#+BEGIN_SRC 
w3m URL > archivo.txt
#+END_SRC
w3m, es un navegador interactivo. La opción *-dump*, hace que la página se vea de un modo *no interactivo*, en texto plano. El ancho del documento por defecto, es de 80 letras.
#+BEGIN_SRC 
w3m -dump URL > archivo.txt
#+END_SRC
También podemos convertir un archivo *.html* que tengamos en nuestro disco duro.
#+BEGIN_SRC 
w3m -dump archivo.html > archivo.txt
#+END_SRC
** Cambiar ancho 
Con la opción *-cols*, podemos personalizar el ancho del documento al número de letras que deseemos.

En este ejemplo, voy a utilizar 100 letras
#+BEGIN_SRC 
w3m -dump -cols=100 URL > archivo.txt
#+END_SRC
** UTF-8
Si el texto de la url está en otro idioma, para que todas las letras salgan con sus acentos correctamente, etc... utilizaremos el formato UTF-8.
#+BEGIN_SRC 
w3m -dump -o display_charset=UTF-8 URL > archivo.txt
#+END_SRC
** Conclusión
Ahora podemos automatizar con scripts o desde nuestra terminal, la conversión de una web a texto plano. Con ello podremos tomar notas de aquellas web que nos interese.
* TODO Descargando el último archivo de lanzamiento de un repositorio git. Latest Releases
:PROPERTIES:
:TITLE: Descargando el último archivo de lanzamiento de un repositorio git. Latest Releases
:EXPORT_FILE_NAME: descargando-el-ultimo-archivo-de-lanzamiento-de-un-repositorio-git-latest-releases
:DESCRIPTION: Vamos a utilizar un script para descargar el último archivo de lanzamiento (latest releases) de un repositorio git.
:EXPORT_DATE: 2020-01-14 21:50
:CATEGORY: git
:TAG: scripts,bash
:IMAGE: ./images-blog/git.png
:END:

Vamos a utilizar un script para descargar el último archivo de lanzamiento (latest releases) de un repositorio git.

#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>




Es muy sencillo. Tan simple como conectarnos al apartado *releases* del repositorio de git y desde ahí pulsamos para descargar el archivo.

Ahora mediante este scritp que he creado, vamos a automatizar la descarga y así no tener que vistar la web.

#+BEGIN_SRC 
#!/bash/bin                                                                                                                                                                                                        
#
# ugeek.github.io
# 14/01/20
#

echo "Escribe el nombre del repositorio"
echo "            Ejemplo: uGeek/script"
read URL
echo "¿Que tipo de archivo quieres descargar?, zip, deb, rpm,..."
read ARCHIVO

curl -s https://api.github.com/repos/$URL/releases/latest \
| grep "browser_download_url.*$ARCHIVO" \
| cut -d : -f 2,3 \
| tr -d \" \
| wget -qi -
#+END_SRC


** Descargando el script
Descarga este script desde el repositorio que he creado en GitHub.
#+BEGIN_SRC 
wget https://raw.githubusercontent.com/uGeek/script/master/git-latest-release.sh
#+END_SRC

** Fuente
- https://github.com/uGeek/script

 
* TODO Editor de Texto Nano
:PROPERTIES:
:TITLE: Editor de Texto Nano
:EXPORT_FILE_NAME: editor-de-texto-nano
:DESCRIPTION: En anteriores artículos, hemos visto como compilar nano, ahora veremos un poco como utilizarlo y conocer sus atajos.
:EXPORT_DATE: 2020-01-15 20:12
:CATEGORY: nano
:TAG: ssh,terminal
:IMAGE: ./images-blog/nano.png
:END:

En anteriores artículos, hemos visto como compilar nano, ahora veremos un poco como utilizarlo y conocer sus atajos.


#+HTML: <center>
[[./images-blog/nano.png]]
#+HTML: </center>

** Atajos
*Ctrl+g* o  *F1*, muestra la ayuda y no solo nos explica el funcionamiento de nano, sino también todos los atajos. 

Vamos a ver algunos de los atajos más útiles.

- Ctrl-c : cancela comando actual
- Ctrl-s : Guardar el documento actual
- Ctrl-x o F2: Salir y guardar o no documento

- Ctrl-w o F6: Buscar
- Alt-r o Ctrl-\ : Buscar y remplazar texto

- Ctrl-_  o Ctrl-Shift--: Ir a un determinado número de línea

- Ctrl-r : Insertar otro archivo de texto en el que esté abierto en ese momento
- Ctrl-l : Actualizar el buffer, en el caso que dos personas esten editando el documento


*** Rehacer - Deshacer
- Alt-u : Deshacer
- Alt-e : Rehacer

*** Copiar, Cortar, Pegar y seleccionar un texto
- Alt-a : Seleccionamos un texto que desdeamos copiar o cortar. Pulsa *Alt-a* una vez has seleccionado el texto
- Ctrl-k : Cortar
- Alt-6  : Copiar
- Ctrl-u : Pegar

*** Otros
- Alt-i : Habilitar y deshabilitar el auto identado
- Alt-m : Habilitar el uso del ratón

  
** Corrector Ortográfico
*** Instalación 
#+BEGIN_SRC 
sudo apt install spell
#+END_SRC

Ahora para poder corregir el texto mediante *nano*, pulsaremos las teclas *Ctrl-t*. Nano se desplazará hasta la palabra con error de ortografía para que sustituyamos el texo.

** Todos los Atajos
- ^ es igual a la tecla *Ctrl*
- *M* es igual a la tecla *Alt*


#+BEGIN_SRC 
ATAJOS          DESCRIPCIÓN

^G    (F1)      Mostrar esta ayuda
^X    (F2)      Cerrar el búfer actual / Salir de nano
^O    (F3)      Escribir el búfer actual (o la región marcada) a disco
^R    (Ins)     Insertar otro fichero en el búfer actual (o en un nuevo búfer)

^W    (F6)      Buscar hacia delante una cadena o expresión regular
^\    (M-R)     Reemplazar una cadena o expresión regular
^K    (F9)      Cortar la línea actual (o la región marcada) y guardarla en el cutbuffer
^U    (F10)     Pegar el cutbuffer en la línea actual

^J    (F4)      Justificar el párrafo actual
^T    (F12)     Invocar el corrector ortográfico (si está disponible)

^C    (F11)     Mostrar la posición del cursor
^_    (M-G)     Ir a una línea y columna

M-U             Deshacer la última operación
M-E             Rehacer la última operación deshecha

M-A   (^6)      Marcar texto desde la posición actual del cursor
M-6   (M-^)     Copiar la línea actual (o la región marcada) y guardarla en el cutbuffer

M-]             Ir a la llave correspondiente

^Q              Buscar hacia atrás una cadena o expresión regular
M-Q   (M-▲)     Seguir buscando hacia atrás
M-W   (M-▼)     Seguir buscando hacia delante

^B    (◀)       Ir hacia atrás un carácter
^F    (▶)       Ir hacia delante un carácter
^◀    (M-Space) Ir hacia atrás una palabra
^▶    (^Space)  Ir hacia delante una palabra
^A    (Home)    Ir al principio de la línea actual
^E    (End)     Ir al final de la línea actual

^P    (▲)       Ir a la línea anterior
^N    (▼)       Ir a la siguiente línea
M--   (M-_)     Desplazar el texto una línea arriba sin mover el cursor textualmente
M-+   (M-=)     Desplazar el texto una línea abajo sin mover el cursor textualmente

#+END_SRC
* TODO Emacs en Android
:PROPERTIES:
:TITLE: Emacs en Android
:EXPORT_FILE_NAME: emacs-en-android
:DESCRIPTION: Podemos utilizar Emacs en Android gracias a Termux a través de la Terminal. La novedad es que desde hace mas o menos un mes, hay un nuevo paquete x11 para
:EXPORT_DATE: 2020-01-16 17:50
:CATEGORY: emacs
:TAG: termux,android
:IMAGE: ./images-blog/emacs-android.png
:END:

Podemos utilizar Emacs en Android gracias a Termux a través de la Terminal. La novedad es que desde hace mas o menos un mes, hay un nuevo paquete x11 para Termux llamado emacs-x. Gracias a la combinación de 3 aplicaciones, Termux, Hacker’s keyboard y XServer XSDL, podremos utilizar Emacs también de forma gráfica.


Esto abre la posibilidad de utilizar Emacs tanto en tablets, Android Tv… del mismo modo como lo haríamos en un PC.

#+HTML: <center>
[[./images-blog/emacs-android.png]]
#+HTML: </center>

** En Termux
Escribimos en Termux:

#+BEGIN_SRC 
pkg upgrade
pkg install x11-repo
pkg install emacs-x
#+END_SRC

** Iniciaremos XServer XSDL:
#+BEGIN_SRC 
export DISPLAY=:0
#+END_SRC
Recordar que al iniciar XServer XSDL, podremos configurar la posición vertical de la pantalla, teclado, etc…
Iniciamos Emacs:

#+BEGIN_SRC 
emacs
#+END_SRC
Si nos vamos a la aplicación de XServer XSDL y esperamos unos segundos, aparecerá Emacs en modo gráfico.

** Fuente 
- https://www.reddit.com/r/emacs/comments/9m76ak/termux_package_emacsx/
* TODO Instalando la última versión de Firefox
:PROPERTIES:
:TITLE: Instalando la última versión de Firefox
:EXPORT_FILE_NAME: instalando-la-ultima-version-de-firefox
:DESCRIPTION: Voy a instalar la ultimísima versión de Firefox y no depender de la versión disponible en los repositorios de mi distro. Para ello, descargaremos la versión disponible en los repositorios
:EXPORT_DATE: 2020-01-16 18:45
:CATEGORY: aplicaciones
:TAG: firefox
:IMAGE: ./images-blog/firefox.png
:END:


Voy a instalar la ultimísima versión de Firefox y no depender de la versión disponible en los repositorios de mi distro. Para ello, descargaremos la versión disponible en los repositorios de [[www.mozilla.org][mozilla]].
#+HTML: <center>
[[./images-blog/firefox.png]]
#+HTML: </center>

** Descargando
Descargaré la última versión en este momento, la *73.0b3* (recuerda que las versiones que llevan una *b*, forman parte del canal beta), pero puedes hacer exactamente lo mismo con la última versión disponible en el momento que leas este artículo.

Vamos a ver todas las versiones publicadas en https://download-installer.cdn.mozilla.net/pub/firefox/releases/

Descargamos la versión para y arquitectura *linux-x86_64*
#+BEGIN_SRC 
wget https://download-installer.cdn.mozilla.net/pub/firefox/releases/73.0b3/linux-x86_64/es-ES/firefox-73.0b3.tar.bz2
#+END_SRC
** Descomprimiendo
Descomprimimos el archivo
#+BEGIN_SRC 
tar xvf firefox-73.0b3.tar.bz2
#+END_SRC
** Moviendolo al directorio opt
Voy a mover a la carpeta =/opt/= la carpeta *firefox* que hemos descomprimido

#+BEGIN_SRC 
sudo mv firefox/ /opt/
#+END_SRC
** Ejecuta firefox con 
Ahora solo queda ejecutar Firefox.

Yo en i3wm, creo un atajo a este Firefox. También podrías crear un icono en tu escritorio para ejecutar este ejecutable
#+BEGIN_SRC 
/opt/firefox/firefox
#+END_SRC


* TODO Copiando una página web o parte de ella a OrgMode
:PROPERTIES:
:TITLE: Copiando una página web o parte de ella a OrgMode
:EXPORT_FILE_NAME: copiando-una-pagina-web-o-parte-de-ella-a-orgmode
:DESCRIPTION: Vamos a utilizar un paquete que nos va a permitir copiar el contenido de una página web o parte de él, con enlaces, etc... a orgmode
:EXPORT_DATE: 2020-01-17 17:55
:CATEGORY: emacs
:TAG: w3m,orgmode
:IMAGE: ./images-blog/w3m.png
:END:

Vamos a utilizar un paquete que nos va a permitir copiar el contenido de una página web o parte de él, con enlaces, etc... a orgmode

#+HTML: <center>
[[./images-blog/w3m.png]]
#+HTML: </center>

Este paquete no está en los repositorios de Melpa, así que vamos crearlo en nuestro disco duro y cargarlo al inicio.

** Paquete org-w3m.el
Vamos a crear el archivo *org-w3m.el*, por ejemplo en la siguiente ruta =~/dotfile/emacs/paquetes/org-w3m.el=.

#+BEGIN_SRC 
nano ~/dotfile/emacs/paquetes/org-w3m.el
#+END_SRC

Copia el siguiente contenido.

#+BEGIN_SRC 
;; org-w3m.el --- Support from copy and paste from w3m to Org-mode

;; Copyright (C) 2008-2012 Free Software Foundation, Inc.

;; Author: Andy Stewart <lazycat dot manatee at gmail dot com>
;; Keywords: outlines, hypermedia, calendar, wp
;; Homepage: http://orgmode.org
;;
;; This file is part of GNU Emacs.
;;
;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:

;; This file implements copying HTML content from a w3m buffer and
;; transforming the text on the fly so that it can be pasted into
;; an org-mode buffer with hot links.  It will also work for regions
;; in gnus buffers that have been washed with w3m.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Acknowledgments:

;; Richard Riley <rileyrgdev at googlemail dot com>
;;
;;      The idea of transforming the HTML content with org-mode style is
;;      proposed by Richard, I'm just coding it.
;;

;;; Code:

(require 'org)

(defun org-w3m-copy-for-org-mode ()
  "Copy current buffer content or active region with `org-mode' style links.
This will encode `link-title' and `link-location' with
`org-make-link-string', and insert the transformed test into the kill ring,
so that it can be yanked into an Org-mode buffer with links working correctly."
  (interactive)
  (let* ((regionp (org-region-active-p))
         (transform-start (point-min))
         (transform-end (point-max))
         return-content
         link-location link-title
         temp-position out-bound)
    (when regionp
      (setq transform-start (region-beginning))
      (setq transform-end (region-end))
      ;; Deactivate mark if current mark is activate.
      (if (fboundp 'deactivate-mark) (deactivate-mark)))
    (message "Transforming links...")
    (save-excursion
      (goto-char transform-start)
      (while (and (not out-bound)                 ; still inside region to copy
                  (not (org-w3m-no-next-link-p))) ; no next link current buffer
        ;; store current point before jump next anchor
        (setq temp-position (point))
        ;; move to next anchor when current point is not at anchor
        (or (get-text-property (point) 'w3m-href-anchor) (org-w3m-get-next-link-start))
        (if (<= (point) transform-end)  ; if point is inside transform bound
            (progn
              ;; get content between two links.
              (if (> (point) temp-position)
                  (setq return-content (concat return-content
                                               (buffer-substring
                                                temp-position (point)))))
              ;; get link location at current point.
              (setq link-location (get-text-property (point) 'w3m-href-anchor))
              ;; get link title at current point.
              (setq link-title (buffer-substring (point)
                                                 (org-w3m-get-anchor-end)))
              ;; concat `org-mode' style url to `return-content'.
              (setq return-content (concat return-content
                                           (org-make-link-string
                                            link-location link-title))))
          (goto-char temp-position)     ; reset point before jump next anchor
          (setq out-bound t)            ; for break out `while' loop
          ))
      ;; add the rest until end of the region to be copied
      (if (< (point) transform-end)
          (setq return-content
                (concat return-content
                        (buffer-substring (point) transform-end))))
      (org-kill-new return-content)
      (message "Transforming links...done, use C-y to insert text into Org-mode file")
      (message "Copy with link transformation complete."))))

(defun org-w3m-get-anchor-start ()
  "Move cursor to the start of current anchor.  Return point."
  ;; get start position of anchor or current point
  (goto-char (or (previous-single-property-change (point) 'w3m-anchor-sequence)
                 (point))))

(defun org-w3m-get-anchor-end ()
  "Move cursor to the end of current anchor.  Return point."
  ;; get end position of anchor or point
  (goto-char (or (next-single-property-change (point) 'w3m-anchor-sequence)
		 (point))))

(defun org-w3m-get-next-link-start ()
  "Move cursor to the start of next link.  Return point."
  (catch 'reach
    (while (next-single-property-change (point) 'w3m-anchor-sequence)
      ;; jump to next anchor
      (goto-char (next-single-property-change (point) 'w3m-anchor-sequence))
      (when (get-text-property (point) 'w3m-href-anchor)
        ;; return point when current is valid link
        (throw 'reach nil))))
  (point))

(defun org-w3m-get-prev-link-start ()
  "Move cursor to the start of previous link.  Return point."
  (catch 'reach
    (while (previous-single-property-change (point) 'w3m-anchor-sequence)
      ;; jump to previous anchor
      (goto-char (previous-single-property-change (point) 'w3m-anchor-sequence))
      (when (get-text-property (point) 'w3m-href-anchor)
        ;; return point when current is valid link
        (throw 'reach nil))))
  (point))

(defun org-w3m-no-next-link-p ()
  "Whether there is no next link after the cursor.
Return t if there is no next link; otherwise, return nil."
  (save-excursion
    (equal (point) (org-w3m-get-next-link-start))))

(defun org-w3m-no-prev-link-p ()
  "Whether there is no previous link after the cursor.
Return t if there is no previous link; otherwise, return nil."
  (save-excursion
    (equal (point) (org-w3m-get-prev-link-start))))

;; Install keys into the w3m keymap
(defvar w3m-mode-map)
(defvar w3m-minor-mode-map)
(when (and (boundp 'w3m-mode-map)
           (keymapp w3m-mode-map))
  (define-key w3m-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
  (define-key w3m-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode))
(when (and (boundp 'w3m-minor-mode-map)
           (keymapp w3m-minor-mode-map))
  (define-key w3m-minor-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
  (define-key w3m-minor-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode))
(add-hook
 'w3m-mode-hook
 (lambda ()
   (define-key w3m-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
   (define-key w3m-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode)))
(add-hook
 'w3m-minor-mode-hook
 (lambda ()
   (define-key w3m-minor-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
   (define-key w3m-minor-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode)))

(provide 'org-w3m)

;;; org-w3m.el ends here
#+END_SRC

** Archivo de configuración

Ahora en el archivo *.emacs* o *init.el*, vamos a añadir la siguiente línea para cargar el paquete que acabamos de crear, al arranca Emacs.
#+BEGIN_SRC 
(load-file "~/dotfile/emacs/paquetes/org-w3m.el")
#+END_SRC

** Copiar y Pegar en el archivo OrgMode 
1) Seleccionamos el texto a copiar
2) Pulsamos *C-c C-x C-w* o introducimos: *M-x org-w3m-copy-for-org-mode*
3) Pegamos en nuestro org
* TODO Screen. Enviar scripts a segundo plano
:PROPERTIES:
:TITLE: Screen. Enviar scripts a segundo plano
:EXPORT_FILE_NAME: screen-enviar-scripts-a-segundo-plano
:DESCRIPTION: Aprovechando que Linux permite la multitarea, vamos a enviar un script corriendo a segundo plano.
:EXPORT_DATE: 2020-01-21 20:50
:CATEGORY: bash
:TAG: screen,zsh
:IMAGE: ./images-blog/bash.png
:END:

Aprovechando que Linux permite la multitarea, vamos a enviar un script corriendo a segundo plano.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Para ello vamos a utilizar *screen*. *Screen* mediante la opción *-S*, permite el crear un nombre de sesión. Ideal para recordar en que sesión se está ejecutando este script y así poder volver a esta.

** Enviar script a segundo plano
Vamos a enviar el *script.sh* a segundo plano. En este ejemplo el nombre de la sesión es =nombre_sesion=.

#+BEGIN_SRC 
screen -dmS nombre_sesion script.sh
#+END_SRC
- -S -> Establecer un nombre de sesión
- -d -m -> Modo separado, crea una sesión aparte. Ideal para scripts de inicio del sistema.

** Volver a la sesión
Para volver a la sesión donde se está ejecutando *script.sh*, escribiremos:
#+BEGIN_SRC 
screen -r nombre_sesion
#+END_SRC

** Ver todas las sesiones
Si no recuerdas el nombre de sesión o simplemente, quieres ver cuantos procesos están corriendo en segundo plano con *screen*, escribiremos el siguiente comando
#+BEGIN_SRC 
screen -ls 
#+END_SRC

** Cambiar el nombre de la sesión
Imaginemos que el número de sesión es 22180 y queremos ponerle el nombre backup-rclone una vez iniciado:
#+BEGIN_SRC 
screen -S 22180 -X sessionname backup-rclone
#+END_SRC

En lugar de utilizar en número, también podemos canbiar el nombre sesión
** Matar la sesión
#+BEGIN_SRC 
screen -XS nombre_sesion quit
#+END_SRC
* TODO Nuevo firmware de la Raspberry 4 para bajar la temperatura
:PROPERTIES:
:TITLE: Nuevo firmware de la Raspberry 4 para bajar la temperatura
:EXPORT_FILE_NAME: nuevo-firmware-de-la-raspberry-4-para-bajar-la-temperatura
:DESCRIPTION: Hasta que ha llegado la nueva versión de firmware *000137ab*, hemos visto como a nuestra Raspberry 4 se disparaba la temperatura. Desde prácticamente el día después de su lanzamiento, ya
:EXPORT_DATE: 2020-01-22 18:17
:CATEGORY: raspberry
:TAG: firmware
:IMAGE: ./images-blog/raspberrypi.jpg
:END:

Hasta que ha llegado la nueva versión de firmware *000137ab*, hemos visto como a nuestra Raspberry 4 se disparaba la temperatura. Desde prácticamente el día después de su lanzamiento, ya había un firmware que corregia en parte este problema, pero reducía muchisimo la velocidad de transmisión de datos del USB3.0. Vamos, que no se sabía muy bien hasta que punto valía la pena el actualizar a este firmware.

#+HTML: <center>
[[./images-blog/raspberrypi.jpg]]
#+HTML: </center>

Hoy, este problema ha sido del todo corregido y mediante una actualización, podemos conseguir una temperatura normal y disfrutar sin miedo de nuestra Raspberry 4.

Esta actualización de firmware, es útil para la Raspberry 4, pero no afecta en nada a las anteriores versiones, ya que el problema está en el USB3.0 y la Raspberry 4 es la única versión que lo tiene.

Con esta nueva actualización de firmware, también bajamos el consumo hasta casi 0,5 w.

** Flashear eeprom
Para actualizar el firmware, necesitamos flashear la memoria eeprom.  
Para hacer ello, necesitamos instalar *rpi-eeprom*.

Ya que estamos, actualizaremos Raspbian

#+BEGIN_SRC 
sudo apt update && sudo apt upgrade
#+END_SRC

Instalamos rpi-eeprom y rpi-eeprom-images
#+BEGIN_SRC 
sudo apt install rpi-eeprom rpi-eeprom-images 
#+END_SRC

Ahora reiniciamos Raspbian para que al iniciar el sistema operativo, cargue el nuevo firmware

** Ver versión de Firmware
Una vez instalado, vamos a comprobar la versión del firmware

#+BEGIN_SRC 
sudo rpi-eeprom-update
#+END_SRC

Si la versión de firmware es *000137ab* o superior, quiere decir que tu Raspberry tiene instalado correctamente esta última versión de firmware.

** Unirse al Canal Beta
También podemos unirnos al canal beta de actualizaciones de firmware de la Raspberry 4 y así estar a la última. Actualmente no es posible iniciar nuestra Raspberry desde un USB tal como hacíamos con la versión 3, pero si es posible iniciar con el arranque de red, una funcionalidad disponible solo en el canal beta.

Para instalar el Canal beta, editamos el archivo: 

#+BEGIN_SRC 
sudo nano /etc/default/rpi-eeprom-update
#+END_SRC

Cambiamos *critical* por *beta*
#+BEGIN_SRC 
FIRMWARE_RELEASE_STATUS="beta"
#+END_SRC

Volvemos a actualizar
#+BEGIN_SRC 
sudo rpi-eeprom-update
#+END_SRC

** Fuentes

- https://hackaday.com/2019/10/30/rpi4-now-overclocked-net-booted-and-power-sipping/
- https://www.tomshardware.com/features/raspberry-pi-4-firmware-cool-temps-network-boot
- https://raspberryparanovatos.com/noticias/arranque-red-firmware-raspberry-pi-4/
- https://raspberryparatorpes.net/raspbian-2/nuevo-firmware-para-raspberry-pi-4/
* TODO Aprendiendo todo.txt. todotxt-cli
:PROPERTIES:
:TITLE: Aprendiendo todo.txt. todotxt-cli
:EXPORT_FILE_NAME: aprendiendo-todo-txt-todotxt-cli
:DESCRIPTION: También puedes encontrar muchas aplicaciones para todos los sistemas operativos, navegadores, etc... Te adjunto [[http://todotxt.org/][la web de todo.txt]] donde encontrarás más información.
:EXPORT_DATE: 2020-01-27 20:25
:CATEGORY: todo.txt
:TAG: tareas,textoplano
:IMAGE: ./images-blog/todotxt.png
:END:

También puedes encontrar muchas aplicaciones para todos los sistemas operativos, navegadores, etc... Te adjunto [[http://todotxt.org/][la web de todo.txt]] donde encontrarás más información.

#+HTML: <center>
[[./images-blog/todotxt.png]]
#+HTML: </center>

Gina Trapani , editora fundadora de Lifehacker, creó esta sencilla aplicación para gestionar tus tareas mediante un scritp en bash.

[[https://lifehacker.com/todo-txt-cli-manages-your-tasks-from-the-command-line-5155450][Este artículo, casi es una traducción del propio publicado por Gina Trapani en Lifehacker]], a excepción de la instalación y configuración del todo.txt en otra carpeta. He podido entender mejor que nunca el script de todo.txt para terminal y tal como lo iba probando, lo ido redactando.

Voy a darle nuevamente la oportunidad a todo.txt
** Instalación
todotxt-cli, está disponible en todas las distribuciones linux. Para instalarlo en Debian, Ubuntu, Raspbian,...

#+BEGIN_SRC 
sudo apt install todotxt-cli
#+END_SRC

** todo-txt
*** Comando
Para ejecutar todo.txt cli, escribiremos en la terminal
#+BEGIN_SRC 
todo-txt
#+END_SRC

*** Archivo todo.txt

¿Donde está el archivo todo.txt?
#+BEGIN_SRC 
todo-txt archive
   ~/.todo-txt/todo.txt
#+END_SRC

*** Cambiar la carpeta de tu archivo txt
Si quieres cambiar la ruta de la capeta de tu archivo *todo.txt*, crearemos un archivo de configuración.

Creamos la carpeta y directorio de configuración
#+BEGIN_SRC 
mkdir .todo/ ; nano ~/.todo/config
#+END_SRC

Sitúa la carpeta que contienen los archivo todo.txt. En este ejemplo, la carpeta =~/todo=.
#+BEGIN_SRC 
export TODO_DIR="$HOME/todo"
export TODO_FILE="$TODO_DIR/todo.txt"
export DONE_FILE="$TODO_DIR/done.txt"
export REPORT_FILE="$TODO_DIR/report.txt"
export TMP_FILE="/tmp/todo.tmp"
export TODOTXT_DEFAULT_ACTION=ls
#+END_SRC

*** Alias

Si quieres sencillez, puedes crear el alias *t*, para abreviar.

Añade a tu archivo de configuración .bashrc, .zshrc....
#+BEGIN_SRC 
alias t='todo-txt'
#+END_SRC

Ahora no tendrás que escribir necesariamente *todo-txt* cada vez que quieras utilizar todo.txt cli. Ya tenemos creado nuestro alias.
** Funcionamiento
*** Añadiendo una línea

A partir de ahora, el comando *todo-txt*, lo sustituiré por *t*, ya que he añadido mi alias 

Voy a añadir mi primer línea al archivo *todo.txt*.
#+BEGIN_SRC 
t add "mi primera tarea"
#+END_SRC

Para simplificarlo, también permite el sustituir *add* por *a*.
#+BEGIN_SRC 
t a "mi segunda tarea"
#+END_SRC
Mucho más fácil

*** Añadir una línea a otro todo.txt

#+BEGIN_SRC 
t addto quizas_despues.txt "Tercera tarea"
#+END_SRC

*** Listar tareas

Para listar todas las tareas de mi todo.txt y ver el número de línea
#+BEGIN_SRC 
t ls
#+END_SRC

También podemos utilizar, pero es más sencillo utilizar *ls*.
#+BEGIN_SRC 
t listfile
#+END_SRC

Listar tareas de otro *todo.txt*
#+BEGIN_SRC 
t ls done.txt
#+END_SRC

*** Añadir prioridad

La *1* (primera tarea) del *todo.txt*, voy a darle prioridad *A*.

#+BEGIN_SRC 
t pri 1 A 
#+END_SRC

*** Marcar como realizada una tarea

Voy a marcar como realizada, *done*, la tarea situada en la segunda línea.
#+BEGIN_SRC 
t do 2
#+END_SRC

*** Editar tareas

- replace: reemplazar -> reemplazar una tarea
- append:  agregar -> añadir a una nota existente
- prepend: anteponer 

Ejemplo, Añadir a una nota existente, realizado a las 3 de la tarde
#+BEGIN_SRC 
t append 2 "ready at 3PM"
#+END_SRC

Reemplazar segunda tarea
#+BEGIN_SRC 
t replace 2 "Nueva tarea"
#+END_SRC

Añadir al principio de la tarea. Añadirá la palabra *Importante* al principio de la tarea nº2.
#+BEGIN_SRC 
t prepend 2 "Importante"
#+END_SRC

*** Listar contextos 
Para listar los contextos
#+BEGIN_SRC 
t lsc
#+END_SRC

También podemos listarlos con
#+BEGIN_SRC 
t listcon
#+END_SRC

*** Listar proyectos 
Para listar proyectos
#+BEGIN_SRC 
 t ls prj
#+END_SRC

También podemos utilizar
#+BEGIN_SRC 
t  listproj
#+END_SRC
*** Mover tareas a otro todo.txt
La tarea nº10, ahora no la vamos a poder realizar, la moveremos a la lista *quizas_despues.txt*

#+BEGIN_SRC 
t move 10 quizas_despues.txt
#+END_SRC
*** Buscar en un todo.txt por una palabra
Voy a buscar en mi todo.txt, tareas que contengan la palabra *trabajo*.
#+BEGIN_SRC 
 t lf todo.txt trabajo
#+END_SRC

También podría hacer lo mismo con otro todo.txt
#+BEGIN_SRC 
 t lf done.txt trabajo
#+END_SRC


** Vídeo 
Gina Trapani explica en su artículo, que como una imagen vale más que mil palabras...
#+html: <iframe src="https://player.vimeo.com/video/3263629" width="640" height="483" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
#+html:<p><a href="https://vimeo.com/3263629">Todo.txt CLI 2.0 Demonstration</a> from <a href="https://vimeo.com/user1254136">Gina Trapani</a> on <a href="https://vimeo.com">Vimeo</a>.</p>
** Ayuda

#+BEGIN_SRC 
Usage: todo-txt [-fhpantvV] [-d todo_config] action [task_number] [task_description]

  Actions:
    add|a "THING I NEED TO DO +project @context"
    addm "THINGS I NEED TO DO
          MORE THINGS I NEED TO DO"
    addto DEST "TEXT TO ADD"
    append|app ITEM# "TEXT TO APPEND"
    archive
    command [ACTIONS]
    deduplicate
    del|rm ITEM# [TERM]
    depri|dp ITEM#[, ITEM#, ITEM#, ...]
    do ITEM#[, ITEM#, ITEM#, ...]
    help [ACTION...]
    list|ls [TERM...]
    listall|lsa [TERM...]
    listaddons
    listcon|lsc [TERM...]
    listfile|lf [SRC [TERM...]]
    listpri|lsp [PRIORITIES] [TERM...]
    listproj|lsprj [TERM...]
    move|mv ITEM# DEST [SRC]
    prepend|prep ITEM# "TEXT TO PREPEND"
    pri|p ITEM# PRIORITY
    replace ITEM# "UPDATED TODO"
    report
    shorthelp
#+END_SRC

** Fuentes

- https://github.com/todotxt/todo.txt-cli
- https://lifehacker.com/todo-txt-cli-manages-your-tasks-from-the-command-line-5155450
- https://github.com/nthorne/todo.txt-cli-again-addon
- https://www.tecmint.com/manage-todo-tasks-from-linux-terminal/
* TODO Integración total de todotxt en Emacs
:PROPERTIES:
:TITLE: Integración total de todotxt en Emacs
:EXPORT_FILE_NAME: integracion-total-de-todotxt-en-emacs
:DESCRIPTION: Utilizar org-mode con Emacs, no quiere decir que sea incompatible con el todo.txt.
:EXPORT_DATE: 2020-01-29 19:05
:CATEGORY: emacs
:TAG: todo.txt,tareas
:IMAGE: ./images-blog/todotxt.png
:END:

Utilizar org-mode con Emacs, no quiere decir que sea incompatible con el todo.txt. 

De hecho, con este artículo demostraré que ambos sistemas pueden ser complementario el uno del otro.
#+HTML: <center>
[[./images-blog/todotxt.png]]
#+HTML: </center>

Tengo que reconocer que este modo de gestión de tareas integrado dentro de Emacs,  me ha encantado y además da la sensación de volverte mucho más productivo. 

** Instalación

Vamos a instalar este paquete desde los repositorios de Melpa. 
#+BEGIN_SRC 
M-x package-install todotxt
#+END_SRC

** Configuración

Añadir al archivo de configuración de emacs, *init.el*.

#+BEGIN_SRC 
; Habilitar todotxt
(require 'todotxt)

; Ruta del archivo todo.txt
(set-variable 'todotxt-file "~/todo/todo.txt")

; Atajo C-c t para abrir el listado todo.txt
(global-set-key (kbd "C-c t") 'todotxt)
#+END_SRC

** Funcionamiento

Cuando utilicemos el atajo *C-c t*, se dividirá en 2 la pantalla de emacs, accediendo a nuestro archivo todo.txt y pudiendo gestionar nuestras tareas sin salir del buffer actual.

Para salir del modo todotxt, pulsaremos la tecla *q*.

*** Recopilación de Tareas

Para crear una tarea, es tan simple como abrir todotxt en emacs, pulsar la tacla *a*, escribir la tarea, pulsar la tecla *t* y asociarle un proyecto o contexto, pulsar *r* ya añadir la prioridad, por ejemplo ponemos *A*.

*** Agregar fecha de finalización

Nos situamos sobre la tarea, pulsamos la tecla *d* y en la parte superior de Emacs, se abrirá el calendario de Emacs. Selecciona el día en el calendario y este se agregará de modo automático en la tarea como fecha de finalización.

*** Atajos

- Listar - *l*
- Listar tareas incompletas - *i*
- Añadir tareas - *a*
- Completar tarea - *c*
- Etiquetar tarea - *t*
- Filtrar por proyectos o tareas - */*
- Buscar - Buscar igual que hacemos en Emacs. *C-s*
- Prioridad - *r*
- Editar tarea - *e*
- Guardar - *s*
- Archivar al archivo done.txt - *A*
- Deshacer - *u*
- Revetir en caso de que el todo.txt haya sido con editro externo - *g*
- Salir - *q*

** Fuentes

- https://github.com/rpdillon/todotxt.el
* TODO A python también le gusta el todo.txt. todotxt-machine
:PROPERTIES:
:TITLE: A python también le gusta el todo.txt. todotxt-machine
:EXPORT_FILE_NAME: a-python-tambien-le-gusta-el-todo-txt-todotxt-machine
:DESCRIPTION: Posiblemente una de mis aplicaciones favoritas de todo.txt es todotxt-machine. Una aplicación desarrollada en Python que su funcionamiento es más similar a SimpleTask con su potente filtrado de Contextos, Proyectos.
:EXPORT_DATE: 2020-01-31 17:56
:CATEGORY: todo.txt
:TAG: tareas,python
:IMAGE: ./images-blog/todotxt.png
:END:


Posiblemente una de mis aplicaciones favoritas de todo.txt es todotxt-machine. Una aplicación desarrollada en Python que su funcionamiento es más similar a SimpleTask con su potente filtrado de Contextos, Proyectos.

#+HTML: <center>
[[./images-blog/todotxt.png]]
#+HTML: </center>

** Instalación

#+BEGIN_SRC 
sudo pip3 install todotxt-machine
#+END_SRC

También si lo deseamos, podemos instalarlo desde los repositorios de GitHub
#+BEGIN_SRC 
git clone https://github.com/AnthonyDiGirolamo/todotxt-machine.git
cd todotxt-machine
./todotxt-machine.py
#+END_SRC

** Abrir un archivo todo.txt
Para abrir la aplicación con el archivo todo.txt
#+BEGIN_SRC 
todotxt-machine ~/todo/todo.txt
#+END_SRC

También podemos hacerlo incluyendo el done.txt
#+BEGIN_SRC 
todotxt-machine ~/todo/todo.txt ~/todo/done.txt
#+END_SRC

** Archivo de configuración
Si no quieres tener que poner el archivo *todo.txt* cada vez que abrimos todotxt-machine, crearemos un archivo de configuración
#+BEGIN_SRC 
nano ~/.todotxt-machinerc
#+END_SRC

#+BEGIN_SRC 
[settings]
file = ~/todo.txt
archive = ~/done.txt
#+END_SRC

Ahora si abrimos *todotxt-machine*, se nos abrirá nuestro *todo.txt* por defecto.

** Temas
Podemos personalizar el tema tanto como queramos. Hay 4 temas por defecto que puedes probar.
- base16-light
- base16-dark
- solarized-light
- solarized-dark

Ejemplo:
#+BEGIN_SRC 
[settings]
file = ~/todo.txt
archive = ~/done.txt
colorscheme = solarized-dark
#+END_SRC

** Funcionamiento
Pulsando la tecla *f*, nos abrirá a la derecha un módulo para poder filtrar por contextos o proyectos. Con la tecla *TABULADO*, no moveremos entre el listado y este módulo de filtros.

Para seleccionar los filtros, pulsaremos la tecla *Espacio*.

- *f* -> Filtrar por listas
- *t* -> Opciones de orden, crear bordes...
- *s* -> Ordenar
- *e* -> Estando sobre la línea, editar
- *b* -> Generar bordes en cada tarea
- *S* -> Grabar
- *D* -> Situado sobre la línea, borrarla
- *n* -> Nueva tarea
- *x* -> Tarea completada
- *X* -> Completar tarea y enviarla a done.txt
- *h* -> Ayuda



** Ayuda
#+BEGIN_SRC 
todotxt-machine

Usage:
  todotxt-machine
  todotxt-machine TODOFILE [DONEFILE]
  todotxt-machine [--config FILE]
  todotxt-machine (-h | --help)
  todotxt-machine --version
  todotxt-machine --show-default-bindings

Options:
  -c FILE --config=FILE               Path to your todotxt-machine configuraton file [default: ~/.todotxt-machinerc]
  -h --help                           Show this screen.
  --version                           Show version.
  --show-default-bindings             Show default keybindings in config parser format
                                      Add this to your config file and edit to customize

#+END_SRC

** Fuentes 
- https://github.com/AnthonyDiGirolamo/todotxt-machine
- https://pypi.org/project/todotxt-machine/
* TODO Marca de tiempo con Emacs
:PROPERTIES:
:TITLE: Marca de tiempo con Emacs
:EXPORT_FILE_NAME: marca-de-tiempo-con-emacs
:DESCRIPTION: Edito con Emacs en diferentes dispositivos. Eso implica entre otras cosas, sincronizar estos archivos tanto con Rclone como Syncthing.
:EXPORT_DATE: 2020-02-05 18:25
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/emacs.png
:END:

Edito con Emacs en diferentes dispositivos. Eso implica entre otras cosas, sincronizar estos archivos tanto con Rclone como Syncthing.
#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

Estaba buscando un modo de que Emacs, cada vez que editara un archivo de texto, agregar a la fecha. Así estar tranquilo que realmente se hizo la última sincronización correctamente.

Buscando la documentación encontrado cómo hacerlo y además es muy sencillo.



** Funcionamiento
:PROPERTIES:
:CREADO:   [2020-02-05 Wed 13:05]
:END:

Añade en las 8 primeras líneas de tu archivo orgmode,  esta línea.

#+BEGIN_SRC 
Time-stamp: <>
#+END_SRC

Si no te gusta este formato, también puedes añadir esta.

#+BEGIN_SRC 
Time-stamp: " "
#+END_SRC

Introduces este comando, verás que se actualiza tanto la fecha y hora, como el nombre del dispositivo en el que estás editando el archivo.

#+BEGIN_SRC 
M-x time-stamp
#+END_SRC

Este sería el modo de actualizar de forma manual.

Ahora lo interesante, mediante la configuración, sería añadir un método automatizado.


** Archivo de configuración

Vamos a añadir esta opción en el archivo de configuración, que nos va a permitir que cada vez que grabemos el archivo que estemos editando, agregue la fecha, hora y dispositivo en el que lo estamos editando.

#+BEGIN_SRC 
(add-hook 'before-save-hook 'time-stamp)
#+END_SRC

** Fuentes

- https://www.gnu.org/software/emacs/manual/html_node/emacs/Time-Stamps.html
- https://www.emacswiki.org/emacs/TimeStamp
* TODO Wireguard en 2 minutos con wgc
:PROPERTIES:
:TITLE: Wireguard en 2 minutos con wgc
:EXPORT_FILE_NAME: wireguard-en-2-minutos-con-wgc
:DESCRIPTION: Uno de los defectos que he encontrado a Wireguard,  es que aunque no es complicada su configuración de servidor y clientes, la verdad es que no es nada amigable
:EXPORT_DATE: 2020-02-11 19:02
:CATEGORY: wireguard
:TAG: vpn,raspberry,debian,ubuntu
:IMAGE: ./images-blog/wireguard.png
:END:


Uno de los defectos que he encontrado a Wireguard,  es que aunque no es complicada su configuración de servidor y clientes, la verdad es que no es nada amigable  y eso al final puede hacer que te desanimes.
#+HTML: <center>
[[./images-blog/wireguard.png]]
#+HTML: </center>

¿Te imaginas montar un servidor y configuración de clientes en tan solo 2 minutos?

Gracias al pequeño script que he creado llamado wgc,  podras hacer tus sueños realidad.

Vamos a conocer su funcionamiento.

*** Descargar wgc

Creamos la carpeta =/etc/wireguard=

Tenemos que crearla como *sudo*. Para acceder, =sudo su=

#+BEGIN_SRC 
mkdir -p /etc/wireguard ; cd /etc/wireguard
#+END_SRC

Descargamos *wgc*.
#+BEGIN_SRC 
wget https://raw.githubusercontent.com/uGeek/wgc/master/wgc
#+END_SRC

Damos permisos de ejecución
#+BEGIN_SRC 
sudo chmod +x wgc
#+END_SRC

Ejecutamos *wgc* y nos mostrará la ayuda
#+BEGIN_SRC 
./wgc
#+END_SRC

** Instalar Wireguard

Si no lo tienes instalado, *wgc* lo hará por tí.

**** Debian

#+BEGIN_SRC 
./wgc -id
#+END_SRC

**** Raspbian

#+BEGIN_SRC 
./wgc -ir
#+END_SRC

**** Ubuntu

#+BEGIN_SRC 
./wgc -iu
#+END_SRC

Recuerda que tras la instalación, tu sistema se reiniciará.

** Conocer mi interfaz de red y ip

Para conocer nuestra interfaz de red e ip, tenemos que ejecutar en la terminal:
#+BEGIN_SRC 
ip a
#+END_SRC

Nos mostrará algo parecido a esto
#+BEGIN_SRC 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens172: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:cb:b3:7e brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.111/24 brd 192.168.1.255 scope global dynamic ens172
       valid_lft 42939sec preferred_lft 42939sec
    inet6 fe80::22c:27ff:fecb:b57e/64 scope link 
       valid_lft forever preferred_lft forever
#+END_SRC

La interfaz de red, en mi caso, es la número 2, *ens172* y la ip *192.168.1.111*.

** Crear archivo de configuración del servidor
**** Para Debian

#+BEGIN_SRC 
sudo ./wgc -sd
#+END_SRC

**** Para Ubuntu

#+BEGIN_SRC 
sudo ./wgc -su
#+END_SRC

**** Para Raspbian

#+BEGIN_SRC 
sudo ./wgc -sr
#+END_SRC

Creará el archivo *wg0.conf* de configuración del servidor.
También creará 2 archivos más, la llave pública y privada del servidor.


*Wgc* nos devolverá la llave pública del servidor para que la añadas al propio *wgc*.

Utiliza tu editor de texto favorito. En mi caso, voy a utilizar *nano*.

#+BEGIN_SRC 
nano wgc
#+END_SRC

Ahora añadimos la *ip* pública, tipo ugeek.duckdns.org o en mi caso, voy a utilizar la privada, *192.168.1.111* y la llave pública que ha devuelto *wgc*.
** Crear Cliente

Para crear el cliente, utilizaremos el comando *wgc* seguido del nombre que daremos al cliente.

Yo tengo un Xiami A3, así que le pondré de nombre *A3*.

#+BEGIN_SRC 
./wgc A3 
#+END_SRC

Añadimos el número de cliente, este será el *1*, ya que es el primero que creamos.

- Nos mostrará un código *QR* para capturarlo con nuestro móvil, tablet,...
- Dos líneas para añadir en el servidor

*Ahora crea tantos Clientes como quieras!!!*

** Levantar el servidor

Para levantar el servidor, utilizaremos:
#+BEGIN_SRC 
sudo wg-quick up wg0
#+END_SRC

** Comprobar que Wireguard funciona correctamente

#+BEGIN_SRC 
sudo wg
#+END_SRC

** Detener el servidor

#+BEGIN_SRC 
sudo wg-quick down wg0
#+END_SRC

** Iniciar Wireguard al encender nuestra Raspberry, Servidor,...

Para ello, una vez más utilizaremos systemd.

#+BEGIN_SRC 
sudo systemctl enable wg-quick@wg0.service
#+END_SRC

Iniciamos
#+BEGIN_SRC 
sudo systemctl start wg-quick@wg0.service
#+END_SRC
* TODO Archivar tareas de tu OrgMode en Emacs
:PROPERTIES:
:TITLE: Archivar tareas de tu OrgMode en Emacs
:EXPORT_FILE_NAME: archivar-tareas-de-tu-orgmode-en-emacs
:DESCRIPTION: Si utilizas el orgmode para crear tus tareas, o como es mi caso,  para crear los artículos que voy a publicar en el blog,  una vez finalizados y
:EXPORT_DATE: 2020-02-12 18:30
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/emacs.png
:END:


Si utilizas el orgmode para crear tus tareas, o como es mi caso,  para crear los artículos que voy a publicar en el blog,  una vez finalizados y publicados, necesito quitarlo del archivo actual y desplazarlo a otro para tenerlo guardado.
#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

En el caso de las tareas, sería que una tarea que ya está totalmente finalizada, enviarla a un archivo llamado archivo.org, dónde están todas las tareas archivadas.

Vamos a ver esta posibilidad tan sencilla, que podemos tener integrada en nuestro flujo de trabajo diario con archivos orgmode y Emacs

** Configuración

1) *Creamos el archivo archivo.org*, el la misma ubicación donde tenemos *tareas.org*.

2) Al inicio del archivo orgmode tareas.org, añadiremos lo siguiente:

#+BEGIN_SRC 
#+ARCHIVE: archivo.org::
#+END_SRC

Puedes poner el nombre de archivo que quieras

Podríamos utilizar otra ruta
#+BEGIN_SRC 
#+ARCHIVE: ~/archivo.org::
#+END_SRC
Ahora, guardará las tareas archivadas en la carpeta HOME.

También podemos utilizar el comodín *%s*, para que añada el nombre del archivo orgmode actual que estamos editando, seguido de -archivo.org
#+BEGIN_SRC 
#+ARCHIVE: %s-archivo.org::
#+END_SRC

** Archivar

Con el comando =C-c C-x a=, añadirá la etiqueta *ARCHIVE*.
Además, el color quedará sombreado y el subárbol de debajo se ocultará.

** Mover tareas Archivadas

Si pulsamos el atajo =C-c C-x C-a=, enviará la entrada donde estamos situados, al archivo *archivo.org.*

Este atajo sería el equivalente a introducir el comando =M-x org-archive-subtree-default=.

*Esta tarea se moverá instantaneamente o probablemente será escrita en el momento que salgamos de Emacs*

Para mover todo un subarbol, utilizaremos el atajos =C-c C-x C-s=.

** Fuentes

- https://orgmode.org/manual/Internal-archiving.html#Internal-archiving
- https://orgmode.org/manual/Moving-subtrees.html#Moving-subtrees

* TODO Instalando, Compilando el última versión de Rclone-Browser
:PROPERTIES:
:TITLE: Instalando, Compilando el última versión de Rclone-Browser
:EXPORT_FILE_NAME: instalando-compilando-el-ultima-version-de-rclone-browser
:DESCRIPTION: En los repositorios oficiales de Ubuntu, Debian,... Ya encontramos *Rclone-Browser*, de manera que con un simple =sudo apt install rclone-browser=, lo tendremos instalados. Pero la versión que hay en los
:EXPORT_DATE: 2020-02-16 14:37
:CATEGORY: rclone
:TAG: backup
:IMAGE: ./images-blog/rclone.png
:END:

  
En los repositorios oficiales de Ubuntu, Debian,... Ya encontramos *Rclone-Browser*, de manera que con un simple =sudo apt install rclone-browser=, lo tendremos instalados. Pero la versión que hay en los repositorios, es la versión 1.2 de creador de la aplicación.
#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

A parte de ser una versión antigua, con las nuevas versiones de Ubuntu, Debian,... ya no podemos ver la barra del estado del archivo cuando lo subimos o bajamos.

[[https://github.com/kapitainsky][kapitainsky]] ha hecho un Fork y actualizado estas deficiencias, estando hoy ya en la versión 1.7.

Para poder disfrutar de esta versión, tendremos que compilar, pero veréis que es muy sencillo.

Para el resto de distros o sistemas operativos, te recomiendo vistar el repositorio de GitHub que encontrarás en las fuentes del artículo.

** Instalación
#+BEGIN_SRC 
sudo apt update && sudo apt -y install git g++ cmake make qtdeclarative5-dev
#+END_SRC

** Clonar Repositorio y compilar

#+BEGIN_SRC 
git clone https://github.com/kapitainsky/RcloneBrowser.git
#+END_SRC

Accedemos al interior de la carpeta
#+BEGIN_SRC 
cd RcloneBrowser
#+END_SRC


Crear nueva carpeta de compilación
#+BEGIN_SRC 
mkdir build && cd build
#+END_SRC
 
Ejecuta cmake desde la carpeta de compilación para crear un archivo MAKE

#+BEGIN_SRC 
cmake ..
#+END_SRC

Ejecute make desde la carpeta de compilación para crear binario
#+BEGIN_SRC 
make
#+END_SRC

Instalar sudo make install

#+BEGIN_SRC 
sudo make install
#+END_SRC

** Abriendo el Rclone-Browser
Vamos ahora a teclear en la terminal
#+BEGIN_SRC 
rclone-browser
#+END_SRC

Ya podemos disfrutar de esta última versión

** Script de instalación
Si quieres ejecutarlo desde un script
#+BEGIN_SRC 
#!/bin/bash
#
#  Instalar rclone-browser
#  angel ugeekpodcast@gmail.com
#

sudo apt update && sudo apt -y install git g++ cmake make qtdeclarative5-dev
git clone https://github.com/kapitainsky/RcloneBrowser.git
cd RcloneBrowser
mkdir build && cd build
cmake ..
make
sudo make install

rclone-browser
#+END_SRC
** Fuente
- https://github.com/kapitainsky/RcloneBrowser#linux
- https://github.com/Bash-Projects/RcloneBrowser


* TODO Simplenote para terminal. Sncli
:PROPERTIES:
:TITLE: Simplenote para terminal. Sncli
:EXPORT_FILE_NAME: simplenote-para-terminal-sncli
:DESCRIPTION: sncli es una aplicación desarrollada en Python que da acceso a tu cuenta Simplenote a través de la línea de comando.
:EXPORT_DATE: 2020-02-26 20:02
:CATEGORY: notas
:TAG: simplenote,terminal,aplicaciones
:IMAGE: ./images-blog/simplenote.png
:END:

sncli es una aplicación desarrollada en Python que da acceso a tu cuenta Simplenote a través de la línea de comando. 
#+HTML: <center>
[[./images-blog/simplenote.png]]
#+HTML: </center>

Puedes acceder a tus notas a través de una GUI de consola personalizable que implementa atajos tipo vi o mediante una interfaz de línea de comandos simple que puedes escribir.

** Instalación

#+BEGIN_SRC 
sudo pip3 install sncli
#+END_SRC

** Archivo de configuración
La ruta del archivo por defecto es  =/home/angel/.snclirc=.
Aquí estoy utilizando mi nombre de usuario *angel*.

** Utilizar otra ruta del archivo de configuración
Si queremos utilizar una ruta personalizada, utilizaremos la opción *-c*.
#+BEGIN_SRC 
sncli -c ~/emacs/snclirc
#+END_SRC

** Configurar el usuario y contraseña
La plantilla del archivo sería:
#+BEGIN_SRC 
[sncli]
cfg_sn_username = ugeekpodcast@gmail.com
cfg_sn_password = vamnoiqhr8p9yq3ugf7btijv
#+END_SRC

Sustituye el usuario y contraseña por los tuyos

** Cambiando el editor de texto para las notas

Voy a editar el archivo de configuración, para poner como editor de texto de mis notas emacs.
#+BEGIN_SRC 
nano /home/angel/.snclirc
#+END_SRC

Ahora añadiremos esta línea al archivo:
#+BEGIN_SRC 
cfg_editor = emacs -q -nw +{line}
#+END_SRC

Si quisieras utilizar nano
#+BEGIN_SRC 
cfg_editor = nano +{line}
#+END_SRC

** Caché

La notas quedan guardadas en local en =~/.sncli=

** Atajos

Los atajos son prácticamente los mismos que utilizamos en vim.

*** Movimiento

- j -> Moverse por el listado de notas hacia abajo
- k -> Moverse por el listado de notas hacia arriba
- J -> Estando dentro de una nota, ver la siguiente
- K -> Estando dentro de una nota, ver la anterior
- Space -> Página hacia abajo
- b -> Página hacia arriba
- s -> Ver el estado y cambiar el estado con el servidor (Online)
- l -> logs

*** Crea Notas, editar,...

- C -> Crear una nueva nota
- e -> Editar nota
- Enter -> Ver nota
- / -> Buscar
- d -> Ordenar por fecha
- A -> Limpiar búsqueda
- Ctrl + t -> Ordenar por etiquetas
- T -> Enviar una nota a la papelera (Te pide confirmación, antes de harcerlo).
- p -> Añadir pin a una nota
- m -> Marcar la nota como markdown
- t -> Añadir etiqueta a una nota

*** Navegar por las versiones

- < -> Versión anterior
- > -> Versión siguiente

*** Opciones para salir

Como en vim:

- :w -> Guardar
- :Q! -> Forzar la salida
- :q -> Salir
- :q! -> Forzar la salida
- :wq -> Grabar y salir

*** Ayuda

- h -> Ayuda

** Fuente

- https://github.com/insanum/sncli

* TODO Telegram Desktop. Atajos de teclado
:PROPERTIES:
:TITLE: Telegram Desktop. Atajos de teclado
:EXPORT_FILE_NAME: telegram-desktop-atajos-de-teclado
:DESCRIPTION: Siguiendo con mi objetivo de utilizar todas las aplicaciones de mi pc, únicamente con teclado, sin necesidad de utilizar el ratón, hoy toca el turno de Telegram Desktop.
:EXPORT_DATE: 2020-02-28 20:30 2020-04-03
:CATEGORY: telegram
:TAG: atajos
:IMAGE: ./images-blog/telegram.jpg
:END:

Siguiendo con mi objetivo de utilizar todas las aplicaciones de mi pc, únicamente con teclado, sin necesidad de utilizar el ratón, hoy toca el turno de Telegram Desktop.

#+HTML: <center>
[[./images-blog/telegram.jpg]]
#+HTML: </center>

De salida, puede dar la sensación que no se pueda utilizar Telegram Desktop con teclado, pero como veréis en este artículo, si se puede.

** Movernos por la pantalla principal
Por defecto, el cursor está en la cajetilla de búsqueda. *Si escribimos, se escribirá en la cajetilla de búsqueda*.

Para salir de un chat o donde sea que estemos *ESC*.

- Navegar por los chats -> arriba, abajo
- Seleccionar un Chat -> Enter
- Salir del Chat -> *ESC*

Ya nos podemos mover por los chats, entrar, salir,...

** Chats

Estando dentro de un chat...

- Saltar de un Chat al siguiente -> Alt + ↓  o  Alt + ↑
- Enviar un archivo -> Ctrl + O
- Editar último mensaje enviado -> arriba 
- Buscar en el chat -> Ctrl + f
- Desplazarte por el el historial del chat ->  ↓ o ↑
- Desplazarte por el el historial del chat, página a página -> Tecla de Pag sig. o Pag. anterior

** Carpetas
- Carpeta de abajo  -> Ctrl + Shift + ↑
- Carpeta de arriba -> Ctrl + Shift + ↓
- Carpeta 1 -> Ctrl + 1
- Carpeta 2 -> Ctrl + 2
- ...  
** Chats Anclados
- Mensajer Guardados -> Ctrl + 0
- Primer Chat anclado -> Ctrl + 1
- Segundo Chat anclado -> Ctrl + 2
- ...

** Enviar Emoji o Sticker

1) Escribimos *:* seguido del nombre del emoji en inglés.
2) Nos previsualizará emoji en función del nombre que vamos escribiendo, seleccionamos el que deseamos con *ENTER*. Si queremos enviar ese emoji, volveremos a pulsar *ENTER*.
3) Si quieres enviar un *Sticker*, Ahora nos previsualiza *Stickers* disponibles asociados a este *emoji*. Seleccionamos el que deseamos con las flechas y pulsamos *Enter*.

** Listado de Emoji
*** Personas

| :b :bowtie:                      | 😄 :smile:                        | 😆 :laughing:           |
| 😊 :blush:                       | 😃 :smiley:                       | ☺️ :relaxed:             |
| 😏 :smirk:                       | 😍 :heart_eyes:                   | 😘 :kissing_heart:      |
| 😚 :kissing_closed_eyes:         | 😳 :flushed:                      | 😌 :relieved:           |
| 😆 :satisfied:                   | 😁 :grin:                         | 😉 :wink:               |
| 😜:stuck_out_tongue_winking_eye: | 😝 :stuck_out_tongue_closed_eyes: | 😀 :grinning:           |
| 😗 :kissing:                     | 😙 :kissing_smiling_eyes:         | 😛 :stuck_out_tongue:   |
| 😴 :sleeping:                    | 😟 :worried:                      | 😦 :frowning:           |
| 😧 :anguished:                   | 😮 :open_mouth:                   | 😬 :grimacing:          |
| 😕 :confused:                    | 😯 :hushed:                       | 😑 :expressionless:     |
| 😒 :unamused:                    | 😅 :sweat_smile:                  | 😓 :sweat:              |
| 😥 :disappointed_relieved:       | 😩 :weary:                        | 😔 :pensive:            |
| 😞 :disappointed:                | 😖 :confounded:                   | 😨 :fearful:            |
| 😰 :cold_sweat:                  | 😣 :persevere:                    | 😢 :cry:                |
| 😭 :sob:                         | 😂 :joy:                          | 😲 :astonished:         |
| 😱 :scream:                      | :n :neckbeard:                    | 😫 :tired_face:         |
| 😠 :angry:                       | 😡 :rage:                         | 😤 :triumph:            |
| 😪 :sleepy:                      | 😋 :yum:                          | 😷 :mask:               |
| 😎 :sunglasses:                  | 😵 :dizzy_face:                   | 👿 :imp:                |
| 😈 :smiling_imp:                 | 😐 :neutral_face:                 | 😶 :no_mouth:           |
| 😇 :innocent:                    | 👽 :alien:                        | 💛 :yellow_heart:       |
| 💙 :blue_heart:                  | 💜 :purple_heart:                 | ❤️ :heart:               |
| 💚 :green_heart:                 | 💔 :broken_heart:                 | 💓 :heartbeat:          |
| 💗 :heartpulse:                  | 💕 :two_hearts:                   | 💞 :revolving_hearts:   |
| 💘 :cupid:                       | 💖 :sparkling_heart:              | ✨ :sparkles:           |
| ⭐️ :star:                        | 🌟 :star2:                        | 💫 :dizzy:              |
| 💥 :boom:                        | 💥 :collision:                    | 💢 :anger:              |
| ❗️ :exclamation:                 | ❓ :question:                     | ❕ :grey_exclamation:   |
| ❔ :grey_question:               | 💤 :zzz:                          | 💨 :dash:               |
| 💦 :sweat_drops:                 | 🎶 :notes:                        | 🎵 :musical_note:       |
| 🔥 :fire:                        | 💩 :hankey:                       | 💩 :poop:               |
| 💩 :shit:                        | 👍 :+1:                           | 👍 :thumbsup:           |
| 👎 :-1:                          | 👎 :thumbsdown:                   | 👌 :ok_hand:            |
| 👊 :punch:                       | 👊 :facepunch:                    | ✊ :fist:               |
| ✌️ :v:                            | 👋 :wave:                         | ✋ :hand:               |
| ✋ :raised_hand:                 | 👐 :open_hands:                   | ☝️ :point_up:            |
| 👇 :point_down:                  | 👈 :point_left:                   | 👉 :point_right:        |
| 🙌 :raised_hands:                | 🙏 :pray:                         | 👆 :point_up_2:         |
| 👏 :clap:                        | 💪 :muscle:                       | 🤘 :metal:              |
| 🖕 :fu:                          | 🚶 :walking:                      | 🏃 :runner:             |
| 🏃 :running:                     | 👫 :couple:                       | 👪 :family:             |
| 👬 :two_men_holding_hands:       | 👭 :two_women_holding_hands:      | 💃 :dancer:             |
| 👯 :dancers:                     | 🙆 :ok_woman:                     | 🙅 :no_good:            |
| 💁 :information_desk_person:     | 🙋 :raising_hand:                 | 👰 :bride_with_veil:    |
| 🙎 :person_with_pouting_face:    | 🙍 :person_frowning:              | 🙇 :bow:                |
| :couplekiss: :couplekiss:        | 💑 :couple_with_heart:            | 💆 :massage:            |
| 💇 :haircut:                     | 💅 :nail_care:                    | 👦 :boy:                |
| 👧 :girl:                        | 👩 :woman:                        | 👨 :man:                |
| 👶 :baby:                        | 👵 :older_woman:                  | 👴 :older_man:          |
| 👱 :person_with_blond_hair:      | 👲 :man_with_gua_pi_mao:          | 👳 :man_with_turban:    |
| 👷 :construction_worker:         | 👮 :cop:                          | 👼 :angel:              |
| 👸 :princess:                    | 😺 :smiley_cat:                   | 😸 :smile_cat:          |
| 😻 :heart_eyes_cat:              | 😽 :kissing_cat:                  | 😼 :smirk_cat:          |
| 🙀 :scream_cat:                  | 😿 :crying_cat_face:              | 😹 :joy_cat:            |
| 😾 :pouting_cat:                 | 👹 :japanese_ogre:                | 👺 :japanese_goblin:    |
| 🙈 :see_no_evil:                 | 🙉 :hear_no_evil:                 | 🙊 :speak_no_evil:      |
| 💂 :guardsman:                   | 💀 :skull:                        | 🐾 :feet:               |
| 👄 :lips:                        | 💋 :kiss:                         | 💧 :droplet:            |
| 👂 :ear:                         | 👀 :eyes:                         | 👃 :nose:               |
| 👅 :tongue:                      | 💌 :love_letter:                  | 👤 :bust_in_silhouette: |
| 👥 :busts_in_silhouette:         | 💬 :speech_balloon:               | 💭 :thought_balloon:    |
| :f :feelsgood:                   | :f :finnadie:                     | :g :goberserk:          |
| :g :godmode:                     | :h :hurtrealbad:                  | :r :rage1:              |
| :r :rage2:                       | :r :rage3:                        | :r :rage4:              |
| :s :suspect:                     | :t :trollface:                    |                         |

*** Natura

| ☀️ :sunny:                        | ☔️ :umbrella:             | ☁️ :cloud:                               |
| ❄️ :snowflake:                    | ⛄️ :snowman:              | ⚡️ :zap:                       	 |
| 🌀 :cyclone:                     | 🌁 :foggy:                | 🌊 :ocean:                              |
| 🐱 :cat:                         | 🐶 :dog:                  | 🐭 :mouse:                              |
| 🐹 :hamster:                     | 🐰 :rabbit:               | 🐺 :wolf:                               |
| 🐸 :frog:                        | 🐯 :tiger:                | 🐨 :koala:                              |
| 🐻 :bear:                        | 🐷 :pig:                  | 🐽 :pig_nose:                           |
| 🐮 :cow:                         | 🐗 :boar:                 | 🐵 :monkey_face:                        |
| 🐒 :monkey:                      | 🐴 :horse:                | 🐎 :racehorse:                          |
| 🐫 :camel:                       | 🐑 :sheep:                | 🐘 :elephant:                           |
| 🐼 :panda_face:                  | 🐍 :snake:                | 🐦 :bird:                               |
| 🐤 :baby_chick:                  | 🐥 :hatched_chick:        | 🐣 :hatching_chick:                     |
| 🐔 :chicken:                     | 🐧 :penguin:              | 🐢 :turtle:                             |
| 🐛 :bug:                         | 🐝 :honeybee:             | 🐜 :ant:                                |
| 🐞 :beetle:                      | 🐌 :snail:                | 🐙 :octopus:                            |
| 🐠 :tropical_fish:               | 🐟 :fish:                 | 🐳 :whale:                              |
| 🐋 :whale2:                      | 🐬 :dolphin:              | 🐄 :cow2:                               |
| 🐏 :ram:                         | 🐀 :rat:                  | 🐃 :water_buffalo:                      |
| 🐅 :tiger2:                      | 🐇 :rabbit2:              | 🐉 :dragon:                             |
| 🐐 :goat:                        | 🐓 :rooster:              | 🐕 :dog2:                               |
| 🐖 :pig2:                        | 🐁 :mouse2:               | 🐂 :ox:                                 |
| 🐲 :dragon_face:                 | 🐡 :blowfish:             | 🐊 :crocodile:                          |
| 🐪 :dromedary_camel:             | 🐆 :leopard:              | 🐈 :cat2:                               |
| 🐩 :poodle:                      | 🐾 :paw_prints:           | 💐 :bouquet:                            |
| 🌸 :cherry_blossom:              | 🌷 :tulip:                | 🍀 :four_leaf_clover:                   |
| 🌹 :rose:                        | 🌻 :sunflower:            | 🌺 :hibiscus:                           |
| 🍁 :maple_leaf:                  | 🍃 :leaves:               | 🍂 :fallen_leaf:                        |
| 🌿 :herb:                        | 🍄 :mushroom:             | 🌵 :cactus:                             |
| 🌴 :palm_tree:                   | 🌲 :evergreen_tree:       | 🌳 :deciduous_tree:                     |
| 🌰 :chestnut:                    | 🌱 :seedling:             | 🌼 :blossom:                            |
| 🌾 :ear_of_rice:                 | 🐚 :shell:                | 🌐 :globe_with_meridians:               |
| 🌞 :sun_with_face:               | 🌝 :full_moon_with_face:  | 🌚 :new_moon_with_face:                 |
| 🌑 :new_moon:                    | 🌒 :waxing_crescent_moon: | 🌓 :first_quarter_moon:                 |
| 🌔 :waxing_gibbous_moon:         | 🌕 :full_moon:            | 🌖 :waning_gibbous_moon:                |
| 🌗 :last_quarter_moon:           | 🌘 :waning_crescent_moon: | 🌜 :last_quarter_moon_with_face:        |
| 🌛 :first_quarter_moon_with_face | :  🌔 :moon:              | 🌍 :earth_africa:                       |
| 🌎 :earth_americas:              | 🌏 :earth_asia:           | 🌋 :volcano:                            |
| 🌌 :milky_way:                   | ⛅️ :partly_sunny:         | :o :octocat:                   	 |
| :s :squirrel:                    |                           | 	                                |

*** Objetos

| 🎍 :bamboo:                         | 💝 :gift_heart:                 | 🎎 :dolls:                          |
| 🎒 :school_satchel:                 | 🎓 :mortar_board:               | 🎏 :flags:                 	 |
| 🎆 :fireworks:                      | 🎇 :sparkler:                   | 🎐 :wind_chime:            	 |
| 🎑 :rice_scene:                     | 🎃 :jack_o_lantern:             | 👻 :ghost:                 	 |
| 🎅 :santa:                          | 🎄 :christmas_tree:             | 🎁 :gift:                  	 |
| 🔔 :bell:                           | 🔕 :no_bell:                    | 🎋 :tanabata_tree:         	 |
| 🎉 :tada:                           | 🎊 :confetti_ball:              | 🎈 :balloon:               	 |
| 🔮 :crystal_ball:                   | 💿 :cd:                         | 📀 :dvd:                   	 |
| 💾 :floppy_disk:                    | 📷 :camera:                     | 📹 :video_camera:          	 |
| 🎥 :movie_camera:                   | 💻 :computer:                   | 📺 :tv:                    	 |
| 📱 :iphone:                         | ☎️ :phone:                       | ☎️ :telephone:            	   |
| 📞 :telephone_receiver:             | 📟 :pager:                      | 📠 :fax:                   	 |
| 💽 :minidisc:                       | 📼 :vhs:                        | 🔉 :sound:                 	 |
| 🔈 :speaker:                        | 🔇 :mute:                       | 📢 :loudspeaker:           	 |
| 📣 :mega:                           | ⌛️ :hourglass:                  | ⏳ :hourglass_flowing_sand:	 |
| ⏰ :alarm_clock:                    | ⌚️ :watch:                      | 📻 :radio:                 	 |
| 📡 :satellite:                      | ➿ :loop:                       | 🔍 :mag:                   	 |
| 🔎 :mag_right:                      | 🔓 :unlock:                     | 🔒 :lock:                  	 |
| 🔏 :lock_with_ink_pen:              | 🔐 :closed_lock_with_key:       | 🔑 :key:                   	 |
| 💡 :bulb:                           | 🔦 :flashlight:                 | 🔆 :high_brightness:       	 |
| 🔅 :low_brightness:                 | 🔌 :electric_plug:              | 🔋 :battery:               	 |
| 📲 :calling:                        | ✉️ :email:                       | 📫 :mailbox:               	 |
| 📮 :postbox:                        | 🛀 :bath:                       | 🛁 :bathtub:               	 |
| 🚿 :shower:                         | 🚽 :toilet:                     | 🔧 :wrench:                	 |
| 🔩 :nut_and_bolt:                   | 🔨 :hammer:                     | 💺 :seat:                  	 |
| 💰 :moneybag:                       | 💴 :yen:                        | 💵 :dollar:                	 |
| 💷 :pound:                          | 💶 :euro:                       | 💳 :credit_card:           	 |
| 💸 :money_with_wings:               | 📧 :e-mail:                     | 📥 :inbox_tray:            	 |
| 📤 :outbox_tray:                    | ✉️ :envelope:                    | 📨 :incoming_envelope:     	 |
| 📯 :postal_horn:                    | 📪 :mailbox_closed:             | 📬 :mailbox_with_mail:     	 |
| 📭 :mailbox_with_no_mail:           | 🚪 :door:                       | 🚬 :smoking:               	 |
| 💣 :bomb:                           | 🔫 :gun:                        | 🔪 :hocho:                 	 |
| 💊 :pill:                           | 💉 :syringe:                    | 📄 :page_facing_up:        	 |
| 📃 :page_with_curl:                 | 📑 :bookmark_tabs:              | 📊 :bar_chart:             	 |
| 📈 :chart_with_upwards_trend:       | 📉 :chart_with_downwards_trend: | 📜 :scroll:                	 |
| 📋 :clipboard:                      | 📆 :calendar:                   | 📅 :date:                  	 |
| 📇 :card_index:                     | 📁 :file_folder:                | 📂 :open_file_folder:      	 |
| ✂️ :scissors:                        | 📌 :pushpin:                    | 📎 :paperclip:             	 |
| ✒️ :black_nib:                       | ✏️ :pencil2:                     | 📏 :straight_ruler:        	 |
| 📐 :triangular_ruler:               | 📕 :closed_book:                | 📗 :green_book:            	 |
| 📘 :blue_book:                      | 📙 :orange_book:                | 📓 :notebook:              	 |
| 📔 :notebook_with_decorative_cover: | 📒 :ledger:                     | 📚 :books:                 	 |
| 🔖 :bookmark:                       | 📛 :name_badge:                 | 🔬 :microscope:            	 |
| 🔭 :telescope:                      | 📰 :newspaper:                  | 🏈 :football:              	 |
| 🏀 :basketball:                     | ⚽️ :soccer:                     | ⚾️ :baseball:             	  |
| 🎾 :tennis:                         | 🎱 :8ball:                      | 🏉 :rugby_football:        	 |
| 🎳 :bowling:                        | ⛳️ :golf:                       | 🚵 :mountain_bicyclist:    	 |
| 🚴 :bicyclist:                      | 🏇 :horse_racing:               | 🏂 :snowboarder:           	 |
| 🏊 :swimmer:                        | 🏄 :surfer:                     | 🎿 :ski:                   	 |
| ♠️ :spades:                          | ♥️ :hearts:                      | ♣️ :clubs:                	   |
| ♦️ :diamonds:                        | 💎 :gem:                        | 💍 :ring:                  	 |
| 🏆 :trophy:                         | 🎼 :musical_score:              | 🎹 :musical_keyboard:      	 |
| 🎻 :violin:                         | 👾 :space_invader:              | 🎮 :video_game:            	 |
| 🃏 :black_joker:                    | 🎴 :flower_playing_cards:       | 🎲 :game_die:              	 |
| 🎯 :dart:                           | 🀄️ :mahjong:                    | 🎬 :clapper:               	 |
| 📝 :memo:                           | 📝 :pencil:                     | 📖 :book:                  	 |
| 🎨 :art:                            | 🎤 :microphone:                 | 🎧 :headphones:            	 |
| 🎺 :trumpet:                        | 🎷 :saxophone:                  | 🎸 :guitar:                	 |
| 👞 :shoe:                           | 👡 :sandal:                     | 👠 :high_heel:             	 |
| 💄 :lipstick:                       | 👢 :boot:                       | 👕 :shirt:                 	 |
| 👕 :tshirt:                         | 👔 :necktie:                    | 👚 :womans_clothes:        	 |
| 👗 :dress:                          | 🎽 :running_shirt_with_sash:    | 👖 :jeans:                 	 |
| 👘 :kimono:                         | 👙 :bikini:                     | 🎀 :ribbon:                	 |
| 🎩 :tophat:                         | 👑 :crown:                      | 👒 :womans_hat:            	 |
| 👞 :mans_shoe:                      | 🌂 :closed_umbrella:            | 💼 :briefcase:             	 |
| 👜 :handbag:                        | 👝 :pouch:                      | 👛 :purse:                 	 |
| 👓 :eyeglasses:                     | 🎣 :fishing_pole_and_fish:      | ☕️ :coffee:               	  |
| 🍵 :tea:                            | 🍶 :sake:                       | 🍼 :baby_bottle:           	 |
| 🍺 :beer:                           | 🍻 :beers:                      | 🍸 :cocktail:              	 |
| 🍹 :tropical_drink:                 | 🍷 :wine_glass:                 | 🍴 :fork_and_knife:        	 |
| 🍕 :pizza:                          | 🍔 :hamburger:                  | 🍟 :fries:                 	 |
| 🍗 :poultry_leg:                    | 🍖 :meat_on_bone:               | 🍝 :spaghetti:             	 |
| 🍛 :curry:                          | 🍤 :fried_shrimp:               | 🍱 :bento:                 	 |
| 🍣 :sushi:                          | 🍥 :fish_cake:                  | 🍙 :rice_ball:             	 |
| 🍘 :rice_cracker:                   | 🍚 :rice:                       | 🍜 :ramen:                 	 |
| 🍲 :stew:                           | 🍢 :oden:                       | 🍡 :dango:                 	 |
| 🥚 :egg:                            | 🍞 :bread:                      | 🍩 :doughnut:              	 |
| 🍮 :custard:                        | 🍦 :icecream:                   | 🍨 :ice_cream:             	 |
| 🍧 :shaved_ice:                     | 🎂 :birthday:                   | 🍰 :cake:                  	 |
| 🍪 :cookie:                         | 🍫 :chocolate_bar:              | 🍬 :candy:                 	 |
| 🍭 :lollipop:                       | 🍯 :honey_pot:                  | 🍎 :apple:                 	 |
| 🍏 :green_apple:                    | 🍊 :tangerine:                  | 🍋 :lemon:                 	 |
| 🍒 :cherries:                       | 🍇 :grapes:                     | 🍉 :watermelon:            	 |
| 🍓 :strawberry:                     | 🍑 :peach:                      | 🍈 :melon:                 	 |
| 🍌 :banana:                         | 🍐 :pear:                       | 🍍 :pineapple:             	 |
| 🍠 :sweet_potato:                   | 🍆 :eggplant:                   | 🍅 :tomato:                	 |
| 🌽 :corn:                           |                                 | 	                            |
*** Lugares


| 🏠 :house:               | 🏡 :house_with_garden:       | 🏫 :school:                         |
| 🏢 :office:              | 🏣 :post_office:             | 🏥 :hospital:              	 |
| 🏦 :bank:                | 🏪 :convenience_store:       | 🏩 :love_hotel:            	 |
| 🏨 :hotel:               | 💒 :wedding:                 | ⛪️ :church:               	  |
| 🏬 :department_store:    | 🏤 :european_post_office:    | 🌇 :city_sunrise:          	 |
| 🌆 :city_sunset:         | 🏯 :japanese_castle:         | 🏰 :european_castle:       	 |
| ⛺️ :tent:                | 🏭 :factory:                 | 🗼 :tokyo_tower:           	 |
| 🗾 :japan:               | 🗻 :mount_fuji:              | 🌄 :sunrise_over_mountains:	 |
| 🌅 :sunrise:             | 🌠 :stars:                   | 🗽 :statue_of_liberty:     	 |
| 🌉 :bridge_at_night:     | 🎠 :carousel_horse:          | 🌈 :rainbow:               	 |
| 🎡 :ferris_wheel:        | ⛲️ :fountain:                | 🎢 :roller_coaster:        	 |
| 🚢 :ship:                | 🚤 :speedboat:               | ⛵️ :boat:                 	  |
| ⛵️ :sailboat:            | 🚣 :rowboat:                 | ⚓️ :anchor:               	  |
| 🚀 :rocket:              | ✈️ :airplane:                 | 🚁 :helicopter:            	 |
| 🚂 :steam_locomotive:    | 🚊 :tram:                    | 🚞 :mountain_railway:      	 |
| 🚲 :bike:                | 🚡 :aerial_tramway:          | 🚟 :suspension_railway:    	 |
| 🚠 :mountain_cableway:   | 🚜 :tractor:                 | 🚙 :blue_car:              	 |
| 🚘 :oncoming_automobile: | 🚗 :car:                     | 🚗 :red_car:               	 |
| 🚕 :taxi:                | 🚖 :oncoming_taxi:           | 🚛 :articulated_lorry:     	 |
| 🚌 :bus:                 | 🚍 :oncoming_bus:            | 🚨 :rotating_light:        	 |
| 🚓 :police_car:          | 🚔 :oncoming_police_car:     | 🚒 :fire_engine:           	 |
| 🚑 :ambulance:           | 🚐 :minibus:                 | 🚚 :truck:                 	 |
| 🚋 :train:               | 🚉 :station:                 | 🚆 :train2:                	 |
| 🚅 :bullettrain_front:   | 🚄 :bullettrain_side:        | 🚈 :light_rail:            	 |
| 🚝 :monorail:            | 🚃 :railway_car:             | 🚎 :trolleybus:            	 |
| 🎫 :ticket:              | ⛽️ :fuelpump:                | 🚦 :vertical_traffic_light:	 |
| 🚥 :traffic_light:       | ⚠️ :warning:                  | 🚧 :construction:          	 |
| 🔰 :beginner:            | 🏧 :atm:                     | 🎰 :slot_machine:          	 |
| 🚏 :busstop:             | 💈 :barber:                  | ♨️ :hotsprings:           	   |
| 🏁 :checkered_flag:      | 🎌 :crossed_flags:           | 🏮 :izakaya_lantern:       	 |
| 🗿 :moyai:               | 🎪 :circus_tent:             | 🎭 :performing_arts:       	 |
| 📍 :round_pushpin:       | 🚩 :triangular_flag_on_post: | 🇯🇵 :jp:                   	  |
| 🇰🇷 :kr:                  | 🇨🇳 :cn:                      | 🇺🇸 :us:                   	  |
| 🇫🇷 :fr:                  | 🇪🇸 :es:                      | 🇮🇹 :it:                   	  |
| 🇷🇺 :ru:                  | 🇬🇧 :gb:                      | 🇬🇧 :uk:                   	  |
| 🇩🇪 :de:                  |                              | 	                            |
|                          |                              | 	                            |

*** Simbolos

    
| 1️⃣ :one:                              | 2️⃣ :two:                          | 3️⃣ :three:                                                 |
| 4️⃣ :four:                             | 5️⃣ :five:                         | 6️⃣ :six:                      			     |
| 7️⃣ :seven:                            | 8️⃣ :eight:                        | 9️⃣ :nine:                     			     |
| 🔟 :keycap_ten:                      | 🔢 :1234:                        | 0️⃣ :zero:                     		             |
| #️⃣ :hash:                             | 🔣 :symbols:                     | ◀️ :arrow_backward:           			     |
| ⬇️ :arrow_down:                       | ▶️ :arrow_forward:                | ⬅️ :arrow_left:               			     |
| 🔠 :capital_abcd:                    | 🔡 :abcd:                        | 🔤 :abc:                       		           |
| ↙️ :arrow_lower_left:                 | ↘️ :arrow_lower_right:            | ➡️ :arrow_right:              			     |
| ⬆️ :arrow_up:                         | ↖️ :arrow_upper_left:             | ↗️ :arrow_upper_right:        			     |
| ⏬ :arrow_double_down:               | ⏫ :arrow_double_up:             | 🔽 :arrow_down_small:          			   |
| ⤵️ :arrow_heading_down:               | ⤴️ :arrow_heading_up:             | ↩️ :leftwards_arrow_with_hook:			     |
| ↪️ :arrow_right_hook:                 | ↔️ :left_right_arrow:             | ↕️ :arrow_up_down:            			     |
| 🔼 :arrow_up_small:                  | 🔃 :arrows_clockwise:            | 🔄 :arrows_counterclockwise:   			   |
| ⏪ :rewind:                          | ⏩ :fast_forward:                | ℹ️ :information_source:       			     |
| 🆗 :ok:                              | 🔀 :twisted_rightwards_arrows:   | 🔁 :repeat:                    			   |
| 🔂 :repeat_one:                      | 🆕 :new:                         | 🔝 :top:                       			   |
| 🆙 :up:                              | 🆒 :cool:                        | 🆓 :free:                      			   |
| 🆖 :ng:                              | 🎦 :cinema:                      | 🈁 :koko:                      			   |
| 📶 :signal_strength:                 | 🈹 :u5272:                       | 🈴 :u5408:                     			   |
| 🈺 :u55b6:                           | 🈯️ :u6307:                       | 🈷️ :u6708:                    			    |
| 🈶 :u6709:                           | 🈵 :u6e80:                       | 🈚️ :u7121:                    			    |
| 🈸 :u7533:                           | 🈳 :u7a7a:                       | 🈲 :u7981:                     			   |
| 🈂️ :sa:                              | 🚻 :restroom:                    | 🚹 :mens:                      			   |
| 🚺 :womens:                          | 🚼 :baby_symbol:                 | 🚭 :no_smoking:                			   |
| 🅿️ :parking:                          | ♿️ :wheelchair:                  | 🚇 :metro:                     			   |
| 🛄 :baggage_claim:                   | 🉑 :accept:                      | 🚾 :wc:                        			   |
| 🚰 :potable_water:                   | 🚮 :put_litter_in_its_place:     | ㊙️ :secret:                  			     |
| ㊗️ :congratulations:                 | Ⓜ️ :m:                            | 🛂         :passport_control:          		   |
| 🛅 :left_luggage:                    | 🛃 :customs:                     | 🉐 :ideograph_advantage:       			   |
| 🆑 :cl:                              | 🆘 :sos:                         | 🆔 :id:                        			   |
| 🚫 :no_entry_sign:                   | 🔞 :underage:                    | 📵 :no_mobile_phones:          			   |
| 🚯 :do_not_litter:                   | 🚱 :non-potable_water:           | 🚳 :no_bicycles:               			   |
| 🚷 :no_pedestrians:                  | 🚸 :children_crossing:           | ⛔️ :no_entry:                 			    |
| ✳️ :eight_spoked_asterisk:            | ✴️ :eight_pointed_black_star:     | 💟 :heart_decoration:          			   |
| 🆚 :vs:                              | 📳 :vibration_mode:              | 📴 :mobile_phone_off:          			   |
| 💹 :chart:                           | 💱 :currency_exchange:           | ♈️ :aries:                    			    |
| ♉️ :taurus:                          | ♊️ :gemini:                      | ♋️       :cancer:                   		      |
| ♌️ :leo:                             | ♍️ :virgo:                       | ♎️ :libra:                    			    |
| ♏️ :scorpius:                        | ♐️ :sagittarius:                 | ♑️ :capricorn:                			    |
| ♒️ :aquarius:                        | ♓️ :pisces:                      | ⛎   :ophiuchus:                 			 |
| 🔯 :six_pointed_star:                | ❎ :negative_squared_cross_mark: | 🅰️ :a:                        			     |
| 🅱️ :b:                                | 🆎 :ab:                          | 🅾️ :o2:                       			     |
| 💠 :diamond_shape_with_a_dot_inside: | ♻️ :recycle:                      | 🔚 :end:                       			   |
| 🔛 :on:                              | 🔜 :soon:                        | 🕐 :clock1:                    			   |
| 🕜 :clock130:                        | 🕙 :clock10:                     | 🕥 :clock1030:                 			   |
| 🕚 :clock11:                         | 🕦 :clock1130:                   | 🕛 :clock12:                   			   |
| 🕧 :clock1230:                       | 🕑 :clock2:                      | 🕝 :clock230:                  			   |
| 🕒 :clock3:                          | 🕞 :clock330:                    | 🕓 :clock4:                    			   |
| 🕟 :clock430:                        | 🕔 :clock5:                      | 🕠 :clock530:                  			   |
| 🕕 :clock6:                          | 🕡 :clock630:                    | 🕖 :clock7:                    			   |
| 🕢 :clock730:                        | 🕗 :clock8:                      | 🕣 :clock830:                  			   |
| 🕘 :clock9:                          | 🕤 :clock930:                    | 💲 :heavy_dollar_sign:         			   |
| ©️ :copyright:                        | ®️ :registered:                   | ™️ :tm:                       			     |
| ❌ :x:                               | ❗️ :heavy_exclamation_mark:      | ‼️ :bangbang:                 			     |
| ⁉️ :interrobang:                      | ⭕️ :o:                           | ✖️    :heavy_multiplication_x:   			  |
| ➕ :heavy_plus_sign:                 | ➖ :heavy_minus_sign:            | ➗ :heavy_division_sign:       			   |
| 💮 :white_flower:                    | 💯 :100:                         | ✔️ :heavy_check_mark:         			     |
| ☑️ :ballot_box_with_check:            | 🔘 :radio_button:                | 🔗 :link:                      			   |
| ➰ :curly_loop:                      | 〰️ :wavy_dash:                   | 〽️ :part_alternation_mark:   			     |
| 🔱 :trident:                         | :black_square: :black_square:    | :white_square: :white_square: 			    |
| ✅ :white_check_mark:                | 🔲 :black_square_button:         | 🔳 :white_square_button:       			   |
| ⚫️ :black_circle:                    | ⚪️ :white_circle:                | 🔴 :red_circle:                			   |
| 🔵 :large_blue_circle:               | 🔷 :large_blue_diamond:          | 🔶 :large_orange_diamond:      			   |
| 🔹 :small_blue_diamond:              | 🔸 :small_orange_diamond:        | 🔺 :small_red_triangle:        			   |
| 🔻 :small_red_triangle_down:         | :s :shipit:                      | 				                          |


** General

- Minimizar telgram Desktop -> Ctrl + w
- Salir de Telegram Descktop -> Ctrl + q
- Bloquear si tienes contraseña -> Ctrl + l

** Fuente

- https://github.com/telegramdesktop/tdesktop/wiki/Keyboard-Shortcuts
- https://www.webfx.com/tools/emoji-cheat-sheet/
- https://gist.github.com/rxaviers/7360908

* TODO El mejor y más ligero cliente para tu Escritorio de Jellyfin. Jellyfin-cli
:PROPERTIES:
:TITLE: El mejor y más ligero cliente para tu Escritorio de Jellyfin. Jellyfin-cli
:EXPORT_FILE_NAME: el-mejor-y-mas-ligero-cliente-para-tu-escritorio-de-jellyfin-jellyfin-cli
:DESCRIPTION: Para que Jellyfin sea del todo perfecto, sería necesario el poder reproducir el contenido multimedia desde mi Escritorio de un modo instantáneo y súper ligero.
:EXPORT_DATE: 2020-03-09 21:35
:CATEGORY: jellyfin
:TAG: servidor,multimedia
:IMAGE: ./images-blog/jellifin.png
:END:

Para que Jellyfin sea del todo perfecto, sería necesario el poder reproducir el contenido multimedia desde mi Escritorio de un modo instantáneo y súper ligero.

Ya os hablé de una aplicación de Jellyfin desarrollada en Electron, pero Electron no se caracteriza por su ligereza.

#+HTML: <center>
[[./images-blog/jellifin.png]]
#+HTML: </center>


Para mí, la aplicación perfecta sería aquella que hiciera uso de VLC o MPV para reproducir en streaming, del mismo modo que hago con mi Android TV y FireStick.

El desarrollador Griego [[https://github.com/marios8543][marios8543]], ha creado esta joya, *jellyfin-cli*.

Jellyfin-cli es un cliente para terminal escrito en Python con urwid.

Desde nuestra terminal, accedemos a través de los menús de Jellyfin hasta encontrar el contenido multimedia que queremos reproducir. MPV, VLC, o cualquier otro reproductor que permita la reproducción en streaming, se abrirá para reproducirlo.

#+HTML: <center>
[[./images-blog/jellyfin-cli.png]]
#+HTML: </center>

Para mi es ya mi aplicación de escritorio favorita de Jellyfin. 

Vamos a ver como instalarla, veréis que es muy sencillo.

** Instalación 
1) Clonamos el repositorio y accedemos al interior
#+BEGIN_SRC 
git clone https://github.com/marios8543/Jellyfin-CLI.git
#+END_SRC

#+BEGIN_SRC 
cd Jellyfin-CLI
#+END_SRC


2) Ahora vamos a instalar algunas dependencias de python necesarias:
#+BEGIN_SRC 
pip3 install --user jellyfin-cli
#+END_SRC

También podemos instalarlo como sudo. Lo instalaríamos así:

#+BEGIN_SRC 
sudo pip3 install -r requirements.txt
#+END_SRC
** Ejecutando jellyfin-cli
Vamos a ejecutar jellyfin-cli:
#+BEGIN_SRC 
python3 jellyfin-cli
#+END_SRC

Ahora Jellyfin-cli nos pedirá:
1) Url del servidor. En mi caso: http://192.168.1.100:8096
2) Usuario: angel
3) Contraseña: 1234

** Uso
Los atajos de teclado disponibles en esta aplicación, son muy sencillos:
- Buscar: s
- Volver atrás: TAB
- Play / Pause: p
- Salir: q 
** Cambiar el reproductor por defecto
Para cambiar el reproductor por defecto, en mi caso VLC:
#+BEGIN_SRC 
PLAYER_PATH="/usr/bin/vlc"
#+END_SRC

Tengo que deciros que esta opción está en el repositorio de Jellyfin-cli, pero a mi no me ha funcionado.

** Fuentes
- https://github.com/marios8543/Jellyfin-CLI
  
Imágen de Jellyfin-cli del repositorio.
* TODO Escuchando música de mi servidor Jellyfin con jellycli
:PROPERTIES:
:TITLE: Escuchando música de mi servidor Jellyfin con jellycli
:EXPORT_FILE_NAME: escuchando-musica-de-mi-servidor-jellyfin-con-jellycli
:DESCRIPTION: Esta una de esas aplicaciones que me encantan. Parece magia verla funcionar.
:EXPORT_DATE: 2020-03-10 20:20
:CATEGORY: jellyfin
:TAG: música,servidor,raspberry
:IMAGE: ./images-blog/jellifin.png
:END:

Esta una de esas aplicaciones que me encantan. Parece magia verla funcionar.
Y es que Jellycli es una aplicación desarrollada por el finlandés [[https://github.com/tryffel][Tero Vierimaa]], que nos permite el poder escuchar toda la biblioteca musical que tenemos en Jellyfin, en nuestro escritorio y a través de la terminal.

#+HTML: <center>
[[./images-blog/jellifin.png]]
#+HTML: </center>

Jellycli está desarrollada en Go y actualmente tiene las siguientes características:
- Reproducir canciones
- Reproducir álbumes
- Agregar canciones a la cola
- Controla (y ve) el estado de reproducción a través de la integración Dbus
Control desde otros clientes a través de websocket. Actualmente implementado:
- Reproducir / pausar / detener
- Regular volumen
- Siguiente pista
#+HTML: <center>
[[./images-blog/jellycli.png]]
#+HTML: </center>

Acaba de actualizar la aplicación a la versión 0.2.0 y gracias a una consulta/sugerencia que hice, el desarrollador ha implementado el que podamos tener un archivo de configuración y gracias a esto, el poder exportarlo a otra cliente o crear múltiples archivos de configuración para varios servidores.

** Instalar Go 
No voy a extenderme a explicar en este artículo como instalar Go ya que no es el propósito del mismo, pero si quieres instalarlo de un modo rápido y sin complicarte, podemos instalarlo con snap.
#+BEGIN_SRC 
sudo snap install go --classic
#+END_SRC

** Instalar Jellycli
Clonaremos el repositorio desde GitHub y vamos a construir el paquete
*** Con Go instalado en el sistema 

#+BEGIN_SRC 
git clone https://github.com/tryffel/jellycli.git
cd jellycli
go build .
./jellycli
#+END_SRC

*** Con Go instalado mediante snap

#+BEGIN_SRC 
git clone https://github.com/tryffel/jellycli.git
cd jellycli
/snap/bin/go build .
./jellycli
#+END_SRC


** Iniciando Jellycli
Vamos a iniciar la aplicación dentro del directorio, una vez construido el paquete de Jellycli y conectarlo con mi servidor Jellyfin, siguiendo mi ejemplo.

La primera vez que iniciamos, la aplicación solicita:
- El host Jellyfin: http://192.168.1.100:8096
- Nombre de usuario: angel
- Contraseña: 1234
- Número de Biblioteca donde está la música: En mi caso es el 1

** Archivo de Configuración
Una vez iniciada la sesión, se crea una archivo de configuración en la siguiente ruta =~/.config/jellycli/jellycli.yaml=. 

Puedes usar varios servidores con sus diferentes archivos de configuración, ejecutando:

#+BEGIN_SRC 
jellycli --config /home/angel/.config/jellycli/rp4.yaml
#+END_SRC

#+BEGIN_SRC 
jellycli --config /home/angel/.config/jellycli/debian.yaml
#+END_SRC

** Uso
Una vez abierta la aplicación, veremos que tenemos disponible la ayuda pulsando la tecla *F1*. 

Todas las funciones visibles de la aplicación, al lado tienen a que tecla corresponden.

Para movernos por los paneles, utilizaremos la tecla *TAB*, para seleccionar la tecla *ENTER* y para salir de la aplicación *Ctrl+c*.

Subir y bajar por las canciones, artistas,...  podemos utilizar tanto las flechas del teclado, así como los atajos de Vim.

- Subir y bajar -> j,k
- Arriba de la página o Abajo -> g,G
- Página arriba, página abajo -> Ctrl+F , Ctrl+B

** Alias
He creado un alias para no tener que acceder a la carpeta de jellycli cada vez que quiero utilizarlo. Así con un simple *jellycli*, estoy escuchando mi música favorita.

#+BEGIN_SRC 
alias jellycli='/home/angel/jellycli/jellycli'
#+END_SRC
  

** Fuentes
- https://github.com/tryffel/jellycli

* TODO Rclone bidireccional con Rclonesync
:PROPERTIES:
:TITLE: Rclone bidireccional con Rclonesync
:EXPORT_FILE_NAME: rclone-bidireccional-con-rclonesync
:DESCRIPTION:
:EXPORT_DATE: 2020-03-26 20:10
:CATEGORY: rclone
:TAG: sincronización,sync,webdav,dropbox,drive
:IMAGE: ./images-blog/rclone.png
:END:

Rclone Es una herramienta genial que permite copiar y sincronizar archivos de tus nubes públicas o privadas. Pero tiene un pequeño defecto dentro de su perfección, esta sincronización es como rsync, en un único sentido.

Gracias a este script desarrollado en python por [[https://github.com/cjnaz][Chris cjnaz]], solucionamos esta limitación podiento tener un directorio con una réplica exacta del contenido de tu nube en local y totalmente sincronizada de un modo bidireccional.

De manera que si se modifica un archivo tanto en local como en el servidor, estos se sincronizaran instantáneamente teniendo una copia exacta en ambos sitios.
#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

De momento rclonesync ha sido probado con Dropbox, Google Drive, Box.com, OneDrive, Nextcloud, Owncloud, Webdav,... y en todos estos funciona perfectamente.

Vamos a ver las opciones básicas de uso e instalación en el propio sistema.

Si utilizas otros sistema operativo como Windows, si, en Windows también funciona, descarga únicamente el archivo *rclonesync.py* y ejecútalo con python.

** Instalación
He creado [[https://github.com/cjnaz/rclonesync-V2][un Fork del proyecto original]], para que si hay modificaciones en el código original, no haya problemas, ya que esta la he probado tanto en la Raspberry como en procesadores de 64 y 32 bits.

De todas maneras, eres libre de instalar la versión del proyecto original si han habido actualizaciones.

Vamos a instalarlo en el sistema.

#+BEGIN_SRC
sudo curl   -L https://raw.githubusercontent.com/Bash-Projects/rclonesync-V2/master/rclonesync.py   -o /usr/local/bin/rclonesync && sudo chmod +x /usr/local/bin/rclonesync
#+END_SRC

Para no instalarlo en tu propio sistema y ejecutarlo con python:
#+BEGIN_SRC
curl -L https://raw.githubusercontent.com/Bash-Projects/rclonesync-V2/master/rclonesync.py -o rclonesync.py
#+END_SRC
** Funcionamiento
El funcionamiento es muy simple, ejecutamos *rclonesync* ruta origen y ruta destino.

#+BEGIN_SRC
rclonesync [RUTA_ORIGEN] [RUTA_DESTINO]
#+END_SRC

** Iniciando

Solo la primera vez que iniciamos, tenemos que poner como *ruta origen*, el directorio *no que tiene archivos*.

Y *solo la primera vez*, iniciaremos el scritp con la opción =--first-sync=. En la ayuda también se especifica que podemos utilizar la opción =-1=.

*** Dropbox
Ejemplo de cuenta una con dropbox, la he probado y funciona perfecto.
Este seria el ejemplo de mi primera sincronización:
#+BEGIN_SRC
rclonesync /home/angel/dropbox  dropbox: --first-sync --verbose
#+END_SRC

*** Drive
Utilizando Google Drive. Voy a sincronizar una subdirectorio dentro de mi Google Drive llamada sync:

Además, en este caso, estoy utilizando otro archivo de configuración de rclone.
#+BEGIN_SRC
rclonesync  drive:sync /home/angel/drive --config "/home/angel/.config/rclone/otra_configuración.conf" --first-sync --verbose
#+END_SRC

*** Webdav
Esto es una maravilla. Mi servidor de webdav, mediante rclonesync, es el mejor cliente para tener mis archivos orgmode y todo.txt sincronizado en todos mis servidores, pc, etc...
#+BEGIN_SRC
rclonesync  webdav:  /home/angel/webdav --first-sync --verbose
#+END_SRC

** Forzar

Si se supera el 50% de archivos y carpetas para el borrado, tenemos que forzar con la opción =--force=, esta es una opción para evitar el que por error borremos archivos mediante la sincronización.
#+BEGIN_SRC
--force
#+END_SRC

** Sincronización automatizada con cron.
Ahora vamos a tener sincronizado de forma automatizada, nuestra carpeta local con el contenido que tenemos en el servidor. Para ello utilizaremos *cron*. En este ejemplo he decidido que el directorio se sincronice cada 5 minutos.

#+BEGIN_SRC
*/5 * * * * /usr/local/bin/rclonesync /home/angel/todo webdav:todo --verbose >> ~/.config/log_webdav_todo 2>&1
#+END_SRC

Cada 5 minutos, a parte de producirse la sincronización, todo quedará registrado en el archivo =~/.config/log_webdav_todo=. De esta manera puedo comprobar que todo funciona correctamente.

** Excluir archivos o directorios en la sincronización
Mediante la opción =--filters-file=, podremos excluir archivos y directorios.

También podemos =--check-access= para una mejor medida adicional.

Este sería el cron:
#+BEGIN_SRC
*/5 * * * * ~/scripts/rclonesync.py /home/angel/drive/ drive: --check-access --filters-file ~/.rclonesyncwd/Filters  >> ~/.config/log_drive 2>&1
#+END_SRC

** Error en sincronización
Es posible que se produzca un error de sincronización. Para solucionar este problema, rclonesync nos pedirá hacer un =--first-sync=.
** Conclusión
Rclonesync tiene muchísimas más opciones que puedes consultar en la documentación o ejecutando en tu terminal:

#+BEGIN_SRC
rclonesync -h
#+END_SRC

Este artículo solo es una guía de iniciación. No descarto en un futuro profundizar más el resto de opciones.

** Fuentes

- https://github.com/cjnaz/rclonesync-V2
* TODO Creando contenedores con dockerc
:PROPERTIES:
:TITLE: Creando contenedores con dockerc
:EXPORT_FILE_NAME: creando-contenedores-con-dockerc
:DESCRIPTION: El motivo de crear esta aplicación es bash que he desarrollado, es tener en una carpeta archivos de texto plano con la extensión .docker y en su contenido las líneas
:EXPORT_DATE: 2020-03-31 15:48
:CATEGORY: docker
:TAG: app
:IMAGE: ./images-blog/docker.png
:END:

El motivo de crear esta aplicación es bash que he desarrollado, es tener en una carpeta, archivos de texto plano con la extensión .docker y en su contenido, las líneas de terminal para montar el contenedor.

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

La aplicación te permite tanto el crear el archivo para guardar estas líneas, así como poder montar un contenedor o un grupo de contendores, todo de manera automatizada.

Si tienes tu lista de dockers favoritos en una carpeta, instalar de cero una Raspberry Pi, por ejemplo, con un simple =dockerc a= auto instalará todos los dockers que hayamos guardado en esa carpeta.

** Instalación
Si tienes Linux, es tan simple como:
#+BEGIN_SRC
sudo curl -L https://raw.githubusercontent.com/uGeek/dockerc/master/dockerc           -o /usr/bin/dockerc && sudo chmod +x /usr/bin/dockerc
#+END_SRC
** Archivo de Configuración
La primera vez que ejecutemos cualquier comando con dockerc, nos hará dos preguntas:
- En que directorio vamos a guardar nuestros dockers
- Que editor de texto queremos utilizar para editarlos

Tras responder estas preguntas, dockerc creará una archivo de configuración en =~/.config/dockerc/dockerc.conf=.

** Guardar un docker
Para guardar un docker con dockerc, tienes que ejecutar el comando

#+BEGIN_SRC
dockerc n
#+END_SRC

Dockerc te preguntará:
- En que grupo de contenedores quieres guardarlo.
- Nombre del docker

Te abrirá el editor de texto, por si quieres editar alguna opción antes de crearlo y creará un archivo de texto plano con la extensión .docker.

*** Ejemplo
Supongamos que he elegido el directorio =/home/angel/dockerc/=, yo he creado los siguientes grupos de dockers, rpi, amd64 y automontaje.

Las rutas de estos directorios serina:
- =/home/angel/dockerc/rpi=
- =/home/angel/dockerc/amd64/=
- =/home/angel/dockerc/automontaje=

En la carpeta rpi, dejo los archivos de los dockers para Raspberry Pi, en la *amd64*, los dockers para arquitectura 64bits y en automontaje, los dockers que quiero montar en mi Raspberry Pi de forma automatizada.

Un archivo =.docker=, tendría la siguiente estructura:

#+BEGIN_SRC
# Docker Supysonic
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:arm-0.5.0
#+END_SRC

Si le decimos a *dockerc* que este docker es Supysonic y pertenece al grupo de rpi, dockerc creará un archivo de texto plano con este contenido en la ruta =/home/angel/dockerc/rpi/supysonic.docker=

*** Crealo como quieras
No es necesario crearlos con dockerc, cualquier archivo que contenga las líneas de terminal que pondrías en la terminal para montar el docker y estén en el directorio, dockerc los visualizará y podrá montarlos.

La idea es que puedas guardar estos archivos y compartirlos o utilizarlos en otra máquina y poder hacer el automontaje de todos los contenedores de una vez.

** Crear un docker
Para crear un docker que tengamos guardado, es tan simple como escribir en tal terminal:
#+BEGIN_SRC
dockerc
#+END_SRC

Dockerc te preguntará:
- ¿A Que grupo pertenece?. En mi ejemplo =rpi=. Te listará todos los dockers que tienes guardados en esa carpeta
- ¿Que docker quieres crear?. En mi caso voy crear el de Supysonic
- Abre el editor de texto con el archivo =suypysonic.docker=, por si quieres cambiar una opción antes de montarlo, como puertos, volumenes...

Una vez contestado todo, comienza la creación del docker.

** Montar muchos dockers automatizado
Yo utilizo la carpeta automontaje pero podría ser cualquier otra donde tubieras todos tus archivos .docker.

Para automontarlos:

#+BEGIN_SRC
dockerc a
#+END_SRC

Dockerc te preguntará en que grupo o directorio están los .docker que quieres crear. Dockerc comenzará a crear todos los contenedores un tras otro de forma automátizada.

** Contenedores y sus puertos
Dockerc te permite visualizar todos los contenedores que están corriendo y sus puertos. Para verlos:
#+BEGIN_SRC
dockerc c
#+END_SRC

También admite con la opción *ls*.
#+BEGIN_SRC
dockerc ls
#+END_SRC

Veriamos en la terminal:
#+BEGIN_SRC
----------------------------------
CONTAINERS CORRIENDO Y SUS PUERTOS
----------------------------------
bitwarden           3012/tcp, 0.0.0.0:1000->80/tcp
duckdns
ejabberd            0.0.0.0:5222->5222/tcp, 0.0.0.0:5280->5280/tcp, 5269/tcp
jellyfin            0.0.0.0:8096->8096/tcp
mariadb             0.0.0.0:3306->3306/tcp
portainer           0.0.0.0:9000->9000/tcp
supysonic           0.0.0.0:8080->8080/tcp
syncthing           21027/udp, 0.0.0.0:8385->8384/tcp, 0.0.0.0:22001->22000/tcp
tt-rss              443/tcp, 0.0.0.0:81->80/tcp
webdav              0.0.0.0:80->80/tcp
#+END_SRC

** Contenedores creados
Podemos ver todos los contenedores creados con el comando
#+BEGIN_SRC
dockerc c -a
#+END_SRC

o

#+BEGIN_SRC
dockerc ls -a
#+END_SRC

Veriamos en la terminal:
#+BEGIN_SRC
----------------------
CONTAINERS DISPONIBLES
----------------------
bitwarden
duckdns
ejabberd
jellyfin
letsencrypt
mariadb
mumble
musikcube
nginx
ouroboros
portainer
resilio
supysonic
syncthing
tautulli
tt-rss
wallabag
webdav
#+END_SRC

** Imágenes con su fecha de creación
Para seguir las actualizaciones de las imágenes, dockerc ordena estas por fecha. Para visualizar las imágenes
#+BEGIN_SRC
dockerc i
#+END_SRC

La terminal muestra
#+BEGIN_SRC
--------
IMAGENES
--------
CREATED             REPOSITORY:TAG                     SIZE
3 days ago          ugeek/traefik:arm                  63.4MB
4 days ago          bitwardenrs/server:raspberry       140MB
5 days ago          ugeek/mumble-ubuntu:arm            87.3MB
7 days ago          python:alpine                      77.1MB
7 days ago          alpine:latest                      3.81MB
7 days ago          arm32v6/alpine:3.11                4.81MB
7 days ago          ugeek/webdab-apache:arm            84MB
#+END_SRC

** Ayuda
#+BEGIN_SRC
dockerc -h
#+END_SRC

o

#+BEGIN_SRC
dockerc --help
#+END_SRC

#+BEGIN_SRC

Modo de empleo: dockerc [OPCIONES]

dockerc                 -> Menú para crear un contendor guardado
dockerc   a             -> Automontaje de todos los dockers de un grupo
dockerc   n             -> Guarda un nuevo docker
dockerc   i             -> Imagenes listadas por creación
dockerc   c,    ls      -> Dockers que están corriendo y sus puertos
dockerc   c -a ,ls -a   -> Todos los Dockers disponibles
dockerc  -h, --help     -> Ayuda


dockerc v0.8 30/03/2020
Copyright (C) 2020 Angel. uGeek
ugeekpodcast@gmail.com

#+END_SRC

** Conclusión
Esta es una aplicación que he creado para mi, que me ha sido de mucha utilidad. Espero que si tienes la misma necesidad que yo, la disfrutes mucho.



* TODO EteSync. Tareas, Contactos y Calendarios, sincronizadas de extremo a extremo
:PROPERTIES:
:TITLE: EteSync. Tareas, Contactos y Calendarios, sincronizadas de extremo a extremo
:EXPORT_FILE_NAME: etesync-tareas-contactos-y-agendas-sincronizadas-de-extremo-a-extremo
:DESCRIPTION: EteSync es un servicio/aplicaciones similar a CalDAV, pero que permite una sincronización segura, de extremo a extremo para tus contactos, calendarios y tareas.
:EXPORT_DATE: 2020-04-01 19:40
:CATEGORY: tareas
:TAG: caldav,calendario
:IMAGE: ./images-blog/etesync.png
:END:

EteSync es un servicio/aplicaciones similar a CalDAV, pero que permite una sincronización segura, de extremo a extremo para tus contactos, calendarios y tareas.

Se integra a la perfección con sus aplicaciones existentes en dispositivos android y IOS. Guarda un historial completo de tus datos en un diario cifrado pudiendo revisar, reproducir y revertir cualquier cambio que haya realizado en cualquier momento.
#+HTML: <center>
[[./images-blog/etesync.png]]
#+HTML: </center>

Vamos a ver como poder crear el docker y poder utilizarlo en la Raspberry Pi o placa ARM.

** Montar e Iniciar el docker y servicio
Escribe el usuario y contraseña que registraras en tu servidor. Cuando inicies por primera vez el cliente en cualquier de las versiones, movil, web,... Te pedirá que pongas una contraseña, que después podrás cambiar, para el cifrado extremo a extremo.

** Docker ARM y Raspberry Pi
#+BEGIN_SRC
docker run --name etesync -d   -e SUPER_USER="USUARIO"   -e SUPER_PASS="CONTRASEÑA"   -p 3735:3735   -v $HOME/docker/etesync/host:/data    ugeek/etesync:arm
#+END_SRC

** Docker amd64
#+BEGIN_SRC
docker run --name etesync -d -e SUPER_USER="user" -e SUPER_PASS="password" -p 3735:3735 -v $HOME/docker/etesync/host:/data  ugeek/etesync:amd64
#+END_SRC
** Android y IOS
- [[https://play.google.com/store/apps/details?id=com.etesync.syncadapter][Google Play. Android]]
- [[https://play.google.com/store/apps/details?id=com.etesync.syncadapter][F-Droid. Android]]
- [[https://play.google.com/store/apps/details?id=com.etesync.syncadapter][App Store. IOS]]
- [[https://play.google.com/store/apps/details?id=com.etesync.syncadapter][Versión Web]]
** Fuentes
- https://www.etesync.com/
- https://github.com/etesync

* TODO Shaarli. El Delicious del Software Libre
:PROPERTIES:
:TITLE: Shaarli. El Delicious del Software Libre
:EXPORT_FILE_NAME: shaarli-el-delicious-del-software-libre
:DESCRIPTION: Shaarly es un servicio de marcadores personal, minimalista, súper rápido, sin bases de datos.
:EXPORT_DATE: 2020-04-02 11:30 2020-05-23 
:CATEGORY: docker
:TAG: servicio
:IMAGE: ./images-blog/shaarli.png
:END:

Shaarly es un servicio de marcadores personal, minimalista, súper rápido, sin bases de datos.

Es uno de los primeros servicios que instalé cuando me inicié en esto de la Raspberry.
#+HTML: <center>
[[./images-blog/shaarli.png]]
#+HTML: </center>

Shaarli es un servicio minimalista para compartir enlaces que puedes instalar en tu propio servidor. Te permite el tener un Feed, donde tus seguidores pueden seguir tu actividad.

Dispone de aplicación para android y extensiones para Firefox o Google Chrome, de manera que cuando ves algo interesante, puedes compartirlo con Shaarli.

** Conoce Shaarly
En esta [[https://demo.shaarli.org/][url hay una instancia de prueba donde puedes probarlo antes de montar el docker]].
- usuario: demo
- contraseña: demo

** Todo sobre Shaarly
Puedes encontrar toda la información como cambiar temas, etc... [[https://sebsauvage.net/wiki/doku.php?id=php:shaarli][en la Wiki de Shaarli]].

También puedes seguir la documentación en https://shaarli.readthedocs.io.

** Docker ARM
#+BEGIN_SRC 
docker create --name=shaarli -p 80:80 agurato/shaarli-armhf
#+END_SRC

Fork del docker de [[https://hub.docker.com/r/agurato/shaarli-armhf/tags][agurato/shaarli-armhf]]
#+BEGIN_SRC 
docker create --name=shaarli -p 80:80 ugeek/shaarli:arm
#+END_SRC
** Docker amd64
#+BEGIN_SRC
docker run -it --name=shaarli -p 80:80 ugeek/shaarli:amd64
#+END_SRC
** Docker Oficial shaarly/shaarly
#+BEGIN_SRC
docker create --name shaarly -p 80:80 shaarli/shaarli
#+END_SRC

* TODO Radicale. Calendario y Tareas sincronizadas mediante CalDAV y CardDAV
:PROPERTIES:
:TITLE: Radicale. Calendario y Tareas sincronizadas mediante CalDAV y CardDAV
:EXPORT_FILE_NAME: radicale-calendario-y-tareas-sincronizadas-mediante-caldav-y-carddav
:DESCRIPTION: Radicale es un servidor de calendario y libreta de direcciones. Está escrito en Python e implementa los estándares CalDAV y CardDAV.
:EXPORT_DATE: 2020-04-04 17:30
:CATEGORY: tareas
:TAG: calendario,caldav,carddav,raspberry
:IMAGE: ./images-blog/radicale.svg
:END:


Radicale es un servidor de calendario y libreta de direcciones. Está escrito en Python e implementa los estándares CalDAV y CardDAV.
#+HTML: <center>
[[./images-blog/radicale.svg]]
#+HTML: </center>

La configuración recomendada para el uso de producción es servir a Apache en todo el sistema a través de uWSGI con autenticación basada en Apache

Vamos a instalarlo mediante docker en nuestra Raspberry Pi o servidor ARM.

** Docker para ARM y Raspberry
#+BEGIN_SRC
docker create --name radicale -p 5232:5232 -v $HOME/docker/radicale:/data/radicale/collections  ugeek/radicale:arm
#+END_SRC
** Docker para amd64
#+BEGIN_SRC
docker create --name radicale -p 5232:5232 -v $HOME/docker/radicale:/data/radicale/collections  ugeek/radicale:amd64
#+END_SRC
** Crear usuarios
Los usuarios están en el archivos:
#+BEGIN_SRC
docker exec  -it radicale vi /data/radicale/users
#+END_SRC

La estructura del archivo de configuración es:
#+BEGIN_SRC
usuario1:contraseña
usuario2:contraseña
#+END_SRC

En este archivo encontraremos:
#+BEGIN_SRC
admin:$apr1$zuGWuE98$ZqFt7FKv8yROElvQy9.wh1
#+END_SRC

que corresponde a:
- usuario:admin
- contraseña:admin

En la contraseña vemos que hay una combinación de numero, letras, símbolos... Esto es debido a que esta contraseña está cifrada en md5.

Los cifrados mas seguros disponibles para la contraseña son =md5=, =bcrypt=.

También podemos optar por poner la contraseña en texto plano =plain=, pero esto sería inseguro si alguien accede al interior de nuestro servidor.

Para cambiar el tipo de cifrado o ponerlo en texto plano, accederemos al siguiente archivo de configuración:

#+BEGIN_SRC
docker exec  -it radicale vi /etc/radicale/config
#+END_SRC

Voy poner que esté en texto plano:

#+BEGIN_SRC
[auth]
type = htpasswd
htpasswd_filename = /data/radicale/users
htpasswd_encryption = plain
#+END_SRC


Accedemos nuevamente al archivo de configuración
#+BEGIN_SRC
docker exec  -it radicale vi /data/radicale/users
#+END_SRC

Ahora voy a cambiarlo por usuario:angel password:1234 y el usuario:juan password:4321

#+BEGIN_SRC
angel:1234
juan:4321
#+END_SRC

Para que todos esto cambios tengan efecto, tendremos que reiniciar el docker
#+BEGIN_SRC
docker restart radicale
#+END_SRC

** Descarga un Backup
#+BEGIN_SRC
wget -c -r -l 1 -nc --user='[myuser]' --password='[mypassword]' --accept=ics '[url]'
#+END_SRC

** Ayuda
#+BEGIN_SRC
radicale --help
#+END_SRC

** Fuentes
- https://radicale.org
- https://hub.docker.com/u/ugeek


* TODO Instalar Brave en Ubuntu, Debian, Linux Mint
:PROPERTIES:
:TITLE: Instalar Brave en Ubuntu, Debian, Linux Mint
:EXPORT_FILE_NAME: instalar-brave-en-ubuntu-debian-linux-mint
:DESCRIPTION: Brave es el navegador de moda, un navegador web de código abierto basado en Chromium, creado por por el cofundador del Proyecto Mozilla y creador de JavaScript, Brendan Eich.
:EXPORT_DATE: 2020-04-06 17:00
:CATEGORY: navegador
:TAG: brave
:IMAGE: ./images-blog/brave.png
:END:

Brave es el navegador de moda, un navegador web de código abierto basado en Chromium, creado por por el cofundador del Proyecto Mozilla y creador de JavaScript, Brendan Eich.
Brave permite bloquear de publicidad y rastreadores en línea.


#+HTML: <center>
[[./images-blog/brave.png]]
#+HTML: </center>

También dice proteger la privacidad de sus usuarios compartiendo menos datos con sus anunciantes.

Vamos a ver como instalarlo en nuestro pc con Ubuntu, debian, Mint y otras distros


** Instalación Debian, Ubuntu, Linux Mint desde los repositorios de Brave

Para añadir el repositorio de Brave en instalar:
#+BEGIN_SRC
sudo apt install apt-transport-https curl

curl -s https://brave-browser-apt-release.s3.brave.com/brave-core.asc | sudo apt-key --keyring /etc/apt/trusted.gpg.d/brave-browser-release.gpg add -

echo "deb [arch=amd64] https://brave-browser-apt-release.s3.brave.com/ stable main" | sudo tee /etc/apt/sources.list.d/brave-browser-release.list

sudo apt update

sudo apt install brave-browser
#+END_SRC
** Por Snap
Brave también podemos instalarlo con una línea desde snap.
#+BEGIN_SRC
sudo snap install brave
#+END_SRC
** Instalación resto de distros
Si quieres instalar Brave en otras distros

https://brave-browser.readthedocs.io/en/latest/installing-brave.html#linux

** Añade extensiones
Brave permite [[https://chrome.google.com/webstore/category/extensions?hl=es][instalar extensiones disponibles de Chronium]].
** Fuentes
- https://brave.com/

* TODO El htop 2.0 desarrollado en bash. bashtop
:PROPERTIES:
:TITLE: El htop 2.0 desarrollado en bash. bashtop
:EXPORT_FILE_NAME: el-htop-2-0-desarrollado-en-bash-bashtop
:DESCRIPTION: Bashtop es un proyecto con licencia Apache 2.0 desarrollado por [[https://github.com/aristocratos][aristocratos]], que nos permite acceder a toda la información de nuestra cpu, memoria, almacenamiento, red, procesos... de nuestro pc, servidor,...
:EXPORT_DATE: 2020-04-07 14:37
:CATEGORY: bash
:TAG: zsh
:IMAGE: ./images-blog/bashtop.png
:END:


Bashtop es un proyecto con licencia Apache 2.0 desarrollado por [[https://github.com/aristocratos][aristocratos]], que nos permite acceder a toda la información de nuestra cpu, memoria, almacenamiento, red, procesos... de nuestro pc, servidor,... de un modo claro, desde mi punto de vista, de lo que lo haríamos con top o htop.
#+HTML: <center>
[[./images-blog/bashtop.png]]
#+HTML: </center>

Me ha gustado mucho porque puedo ver el consumo en ram, cpu,... en tiempo real y de un modo gráfico y claro de mis dockers.

También el uso es mucho más intuitivo, seleccionando los procesos mediante las *teclas arriba, abajo*. Para seleccionar el proceso deseado, pulsaremos *Enter* y se abrirá una pequeña sección donde muestra estadísticas detalladas para el proceso seleccionado.

Permite la posibilidad de filtrar procesos, pulsando la tecla *f* y escribiendo el nombre del proceso,  entre otras muchas más cosas.

#+HTML: <center>
[[./images-blog/bashtop1.png]]
#+HTML: </center>

También, igual que sucede con htop, podemos matar procesos. Nos pondremos sobre el proceso que queremos matar y pulsaremos la *k*. Antes de detener ese proceso, *bashtop* nos preguntará si así queremos hacerlo.

Para su uso se recomienda bash v4.4 o posterior.

Vamos a ver como instalarlo y utilizarlo

** Instalación
Clonamos el repositorio desde la raíz del HOME.
#+BEGIN_SRC
cd ; git clone https://github.com/aristocratos/bashtop.git
#+END_SRC

Crear alias. Recuerda sustituir el usuario *angel* por el tuyo.

#+BEGIN_SRC
alias bashtop='/home/angel/bashtop/bashtop'
#+END_SRC

Ahora, cada vez que escriba en la terminal =bashtop=, será lanzado.

** Configuración

La primera vez que ejecutemos *bashtop*, nos creará un archivo de configuración en la siguiente ruta: =$HOME/.config/bashtop/bashtop.cfg=.

En este archivo podremos configurar el tiempo de refresco en milisegundos, el orden de los procesos, habilitar la temperatura de la cpu,... y más cosas que podremos encontrar en la documentación del repositorio del desarrollador.


*** Configuración gráfica

Podremos ver y editar de un modo gráfico está configuración, pulsando dentro de *bashtop* la tecla *ESC* y seleccionando *OPTIONS*.

** Ayuda
Para conocer un poco más las opciones de esta aplicación, pulsaremos la tecla *h* para acceder a la ayuda.
#+HTML: <center>
[[./images-blog/bashtop2.png]]
#+HTML: </center>

** Fuentes
Las imágenes son del repositorio del desarrollador
- https://github.com/aristocratos/bashtop

Yo no se vosotros, pero yo [[https://github.com/Bash-Projects/bashtop][he forkeado este magnífico proyecto]].



#+HTML: <center>
[[./images-blog/bashhtop1.png]]
#+HTML: </center>
* TODO Varias cuentas de telegram en un mismo PC
:PROPERTIES:
:TITLE: Varias cuentas de telegram en un mismo PC
:EXPORT_FILE_NAME: varias-cuentas-de-telegram-en-un-mismo-pc
:DESCRIPTION: Telegram ha añadido la clasificación por carpetas en Telegram Desktop, para poder clasificar todos aquellos canales y grupos que tenemos por categorías, pero de momento, no tenemos disponible la multicuenta,
:EXPORT_DATE: 2020-04-08 17:00
:CATEGORY: telegram
:TAG: ubuntu
:IMAGE: ./images-blog/telegram.jpg
:END:


Telegram ha añadido la clasificación por carpetas en Telegram Desktop, para poder clasificar todos aquellos canales y grupos que tenemos por categorías, pero de momento, no tenemos disponible la multicuenta, pudiendo tener nuestra cuenta personal y de trabajo todo en un mismo PC.

#+HTML: <center>
[[./images-blog/telegram.jpg]]
#+HTML: </center>


Vamos a ver como poder hacer esto de un modo sencillo.
** Creamos una carpeta de usuario
Crea una carpeta por cada usuario. Voy a crear mi cuenta personal como =angel_bcn=
#+BEGIN_SRC
mkdir -p ~/telegram-desktop/angel_bcn/
#+END_SRC

y la de trabajo como =trabajo=.
#+BEGIN_SRC
mkdir -p ~/telegram-desktop/trabajo/
#+END_SRC
** Uso
*** Repositorios
Si tienes telegram instalada con los paquetes oficiales.

#+BEGIN_SRC
/usr/bin/telegram-desktop -workdir  ~/telegram-desktop/angel_bcn/ &
#+END_SRC

La cuenta de trabajo seria:
#+BEGIN_SRC
/usr/bin/telegram-desktop -workdir  ~/telegram-desktop/trabajo/ &
#+END_SRC


*** Snap
Si utilizas snap
#+BEGIN_SRC
/snap/bin/telegram-desktop -workdir ~/telegram-desktop/angel_bcn/ &
#+END_SRC

La cuenta de trabajo seria
#+BEGIN_SRC
/snap/bin/telegram-desktop -workdir ~/telegram-desktop/trabajo/ &
#+END_SRC

*** Versión descargada de la wed de Telegram
Si utilizas la versión descargable desde la página pagina de telegram, a mi me gusta descomprimir el archivo en una carpeta en la raíz de $HOME llamada telegram (=~/Telegram=).

Lo ejecutaríamos así:

#+BEGIN_SRC
/home/angel/Telegram/Telegram
#+END_SRC

Para Ejecutar mi cuenta personal:
#+BEGIN_SRC
/home/angel/Telegram/Telegram -workdir ~/telegram-desktop/angel_bcn/ &
#+END_SRC


** Creando alias con screen

Vamos a crear un alias y vamos a utilizar screen con todo lo aprendido. Si no tienes instalado screen, recuerda hacerlo con =sudo apt install screen=.

#+BEGIN_SRC
alias t='screen -dmS telegram-angel_bcn /home/angel/Telegram/Telegram -workdir ~/telegram-desktop/angel_bcn/'
#+END_SRC

Ahora cuando escribo *t* en mi terminal, abre telegram con mi cuenta personal.

Voy ha hacer que cuando escriba *trabajo*, abra la cuenta de mi trabajo:

#+BEGIN_SRC
alias trabajo='screen -dmS telegram_trabajo /home/angel/Telegram/Telegram -workdir ~/telegram-desktop/trabajo/'
#+END_SRC

** Conclusión
Aquí tienes una guía de como crear multicuenta en Telegram. Ahora, como puedes imaginar, crea una carpeta de configuración por cada cuenta, de manera que tendrás cuentas ilimitadas de telegram.

* TODO Zerotier. Funcionamiento e instalación por docker o repositorios
:PROPERTIES:
:TITLE: Zerotier. Funcionamiento e instalación por docker o repositorios
:EXPORT_FILE_NAME: zerotier-funcionamiento-e-instalacion-por-docker-o-repositorios
:DESCRIPTION: Me gusta tener todos mis servicios instalados en mi máquina, pero hay cosas que de momento no pueden ser. Este es el ejemplo de *ZeroTier*, un servicio que he escuchado
:EXPORT_DATE: 2020-04-09 17:00
:CATEGORY: docker
:TAG: vpn,raspberry,servidor
:IMAGE: ./images-blog/zerotier.png
:END:


Me gusta tener todos mis servicios instalados en mi máquina, pero hay cosas que de momento no pueden ser. Este es el ejemplo de *ZeroTier*, un servicio que he escuchado mucho hablar [[https://diario.mosqueteroweb.eu/][MosqueteroWeb]], [[https://naseros.com/][Mc Josan]] y [[https://www.eduardocollado.com][Eduardo Collado]].

La verdad es que no me he puesto manos a la obra para probarlo, por el motivo que explicaba al principio. Pero después de ver el vídeo de Mc Josan, no lo he podido evitar.

¿Tan sencillo es *ZeroTier* como se ve en el vídeo y cuentan?

#+HTML: <center>
[[./images-blog/zerotier.png]]
#+HTML: </center>


*ZeroTier* está hecho para gente "normal" que no tiene ni idea de como funciona una VPN o simplemente, alguien como nosotros, que quiere algo que funcione en 5 minutos y simplemente, que funcione.

El funcionamiento de *ZeroTier* es el siguiente:
- Creas una subred que tendrá el llamado *Network ID*. Un identificador de la Red
- Instalas en todas las máquinas que deseas tener bajo esta nueva subred, *ZeroTier*.
- El servidor de *ZeroTier*, que no está en nuestra máquina, está en sus servidores y es la que nos ha dado el *Network ID*, igual que sucede con servicios como *Syncthing* o *Plex*, conecta todos aquellos clientes que tiene en mismo *Network ID* y estén online, conectados a internet en ese momento.

El servidor central de *ZeroTier*, localiza las ip's de todos los dispositivos que están conectados a internet, gracias a la app de ZeroTier y los conecta creando una red.

Para gestionar nuestras subredes creadas, nos conectaremos a: https://my.zerotier.com/


Está genial, ya que podemos montar un servidor con ciertos servicios y compartirlo con familiares, sin necesidad de montar una VPN y darle todos los privilegios de tener a ese familiar dentro de nuestra red local.

El tráfico va totalmente cifrado de extremo a extremo. Tal como comenta Mc Josan en su vídeo, los servidores de *ZeroTier*, única y exclusivamente, se encargan de localizar y conectar los clientes, no pasan los datos por sus servidores. Si eso es así, la verdad es que este servicio es alucinante.



Otro punto fuerte de *ZeroTier*, es que podemos instalarlo en todos los dispositivos. Windows, Linux, Mac, Android, IOS, Raspberry, placa con arquitectura ARM...

** Pierde el miedo a ZeroTier
Te dejo el vídeo donde Mc Josan explica el funcionamiento de la página de administración.

#+HTML: <center>
#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/ICMJ4rHk1Co" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
#+HTML: </center>

** Instalación desde Respositorios

ZeroTier está disponible en los repositorios de Debian Buster con el nombre *zerotier-one*

Para instalarlo:
#+BEGIN_SRC
sudo apt install zerotier-one
#+END_SRC

** Instalación de la última versión

#+BEGIN_SRC
curl -s https://install.zerotier.com/ | sudo bash
#+END_SRC

** Añadir y Conectarnos a tu Network ID

Tanto la primera vez, como todas aquellas que queremos conectar nuestro dispositivo Linux a ZeroTier, utilizaremos el siguiente comando:
#+BEGIN_SRC
sudo zerotier-cli join tu_Network_ID
#+END_SRC

** Desconectarnos del Network ID

Para que nuestro dispositivo Linux se desconecte de la red que hemos creado con ZeroTier, escribiremos los siguiente en la terminal:
#+BEGIN_SRC
sudo zerotier-cli leave 9f46fc363e6ef102
#+END_SRC

** Docker
*** Docker para Raspberry y ARM
#+BEGIN_SRC
docker run --name zerotier-one --device=/dev/net/tun --net=host   --cap-add=NET_ADMIN --cap-add=SYS_ADMIN   -v $HOME/docker/zerotier-one:/var/lib/zerotier-one ugeek/zerotier:arm
#+END_SRC
*** Docker para amd64
#+BEGIN_SRC
docker run --name zerotier-one --device=/dev/net/tun --net=host   --cap-add=NET_ADMIN --cap-add=SYS_ADMIN   -v $HOME/docker/zerotier-one:/var/lib/zerotier-one ugeek/zerotier:amd64
#+END_SRC

*** Docker para i386
#+BEGIN_SRC
docker run --name zerotier-one --device=/dev/net/tun --net=host   --cap-add=NET_ADMIN --cap-add=SYS_ADMIN   -v $HOME/docker/zerotier-one:/var/lib/zerotier-one ugeek/zerotier:i386
#+END_SRC

*** Añadir y Conectarnos a tu Network ID

#+BEGIN_SRC
docker exec -it zerotier-one bash
#+END_SRC

#+BEGIN_SRC
zerotier-cli join 9f46fc363e6ef102
#+END_SRC

En un único comnado
#+BEGIN_SRC
docker exec -it zerotier-one zerotier-cli join 9f46fc363e6ef102
#+END_SRC

** Información

#+BEGIN_SRC
sudo zerotier-cli info
#+END_SRC

** Fuente

- https://github.com/docker-projects/docker-zerotier
* TODO Creando una página web de tu proyecto en GitHub
:PROPERTIES:
:TITLE: Creando una página web de tu proyecto en GitHub
:EXPORT_FILE_NAME: creando-una-pagina-web-de-tu-proyecto-en-github
:DESCRIPTION: Si tienes un repositorio en GitHub y quieres crear una web relacionada con este proyecto para mostrar toda la información, gracias a las GitHub Pages lo tienes super fácil.
:EXPORT_DATE: 2020-04-15 17:00
:CATEGORY: github
:TAG: web
:IMAGE: ./images-blog/githubpages.png
:END:


Si tienes un repositorio en GitHub y quieres crear una web relacionada con este proyecto para mostrar toda la información, gracias a las GitHub Pages lo tienes super fácil.

Vamos a crear una web que mostrará todo el conenido de nuestro README.md, creando un nuevo archivo =_config.yml= que contendrá la configuración, tema, etc...
#+HTML: <center>
[[./images-blog/githubpages.png]]
#+HTML: </center>

La url de la página tendrá la dirección web =https://tu_usuario.github.io/nombre_repositorio=.

Como comentaba, podríamos personalizar incluso el css de la página cambiando el tema de la misma, pero eso lo dejamos para otro artículo.

Vamos a ver como se crea esta página web

** Crear GitHub Page del proyecto

No vamos a *settings* y buscamos en el apartado *GitHub Pages*.

Seleccionamos la rama *master* y más abajo pulsamos *Choose a theme* para elegir el tema. En mi caso seleccionaré el tema *state*.

Esto creará un archivo en la raíz llamado *_config.yml* en la raíz del repositorio, donde incluye:
#+BEGIN_SRC
theme: jekyll-theme-slate
#+END_SRC

** Archivo de Configuración _config.yml

Ahora en nuestro archivo de configuración, podemos añadir más información, como...
#+BEGIN_SRC
theme: jekyll-theme-slate
title: Titulo
description: <br>Descripción<br><br>
lang: es
google_analytics: UA-131585940-1
#+END_SRC

** Crear la página

Para crear la web principal, tan sencillo como crear un archivo *index.md* en la raíz del directorio y GitHub lo convertirá el html por arte de magia, gracias a jekyll.

** Script

Siguiendo los pasos anteriores, vamos ha hacer un script para generar de forma automática la web.

#+BEGIN_SRC
#!/bin/bash
#
#
#
#

cp README.md > index.md

echo "theme: jekyll-theme-slate
google_analytics: UA-131585940-1
lang: es" > _config.yml
#+END_SRC

** Fuentes

- https://github.com/pages-themes/slate

* TODO Instalar Ubuntu 20.04 en una Raspberry o Servidor ARM y Que hacer después de instalarlo
:PROPERTIES:
:TITLE: Instalar Ubuntu 20.04 en una Raspberry o Servidor ARM y Que hacer después de instalarlo
:EXPORT_FILE_NAME: instalar-ubuntu-20-04-en-una-raspberry-o-servidor-arm-y-que-hacer-despues-de-instalarlo
:DESCRIPTION: Ubuntu da un golpe de efecto y sorprende no solo para escritorio con su versión 20.04, sino que también con la versión ARM y para Raspberry.
:EXPORT_DATE: 2020-04-26 16:12
:CATEGORY: ubuntu
:TAG: raspberry,server
:IMAGE: ./images-blog/ubuntu.png
:END:


Ubuntu da un golpe de efecto y sorprende no solo para escritorio con su versión 20.04, sino que también con la versión ARM y para Raspberry.

Esta versión LTS nos da soporte hasta Abril del 2025 y no solo nos proporciona una versión de 32bits, sino que también la versión de 64bits.
#+HTML: <center>
[[./images-blog/ubuntu.png]]
#+HTML: </center>

¿Porque deberíamos probar Ubuntu?. Aquí te daré muchos de los motivos, como por ejemplo tener una versión de 64bits para Raspberry, paquetes muchos más actualizados que Raspbian Buster, Wireguard de un modo estable,...

Pero no te adelanto más. Voy a explicar un poco mi experiencia instalando Ubuntu 20.04 Server en mi Raspberry 3.

Ah! La misma SD la he puesto en mi Raspberry 4 y reconoce sin problemas los 4Gb de RAM. Así que todo un Win para Ubuntu!!! Una alternativa muy real a Raspbian.

** Grabando la SD o USB

Podemos descargar la imagen de Ubuntu para Raspberry en https://ubuntu.com/download/raspberry-pi, pero yo la versión que he descargado, [[http://cdimage.ubuntu.com/ubuntu-server/daily-preinstalled/current/HEADER.html][es la versión de Ubuntu Server]].

Para grabar la imagen, vamos a utilizar [[https://www.balena.io/etcher/][Etcher]].

Podemos instalar el AppImage o el método que desees y grabarlo de un modo súper sencillo, sin tener que pensar mucho.

En mi caso he utilizado AppImage. Descargo el archivo .zip, lo descomprimo, entro como usuario root y ejecuto:

#+BEGIN_SRC 
 ./balenaEtcher-1.5.81-x64.AppImage 
#+END_SRC

Si lo deseas, también puedes utilizar el comando dd como explicaba en el artículo [[https://ugeek.github.io/blog/post/2019-10-29-grabar-raspbian-ubuntu-debian-en-un-pendrive-o-sd.html][Grabar Raspbian, Ubuntu, Debian,… en un Pendrive o SD desde la Terminal]].
** Iniciamos Ubuntu
Yo he conectado mi raspberry a un monitor, cable de ethernet y teclado, a ver que sucede...

Conecto mi transformador USB. El inicio ha tardado un poquito, ya que es el primer arranque.

Se inicia ubuntu y me pide el usuario y contraseña. El usuario y contraseña por defecto son:
- usuario: *ubuntu*
- contraseña: *ubuntu*

Una vez iniciado, *ubuntu* nos pedirá el cambiar la contraseña. Primero pondremos la contraseña antigua, en este caso la que está por defecto *ubuntu* y escribiremos 2 veces nuestra nueva contraseña.

Ya podemos utilizar *ubuntu*!!!

Ahora podemos hacer un:
#+BEGIN_SRC
sudo apt update && sudo apt upgrade && sudo apt dist-upgrade
#+END_SRC

Así tendremos nuestro sistema operativo actualizado.

** Conocer mi ip
Voy a ver que ip ha asignado mi router a esta raspberry con ubuntu:
#+BEGIN_SRC
ip a
#+END_SRC

** Conectarme por SSH
Al iniciarse la primera vez, ubuntu ha instalado ssh, de manera que ahora desde un pc remoto puedo conectarme a mi raspberry.

Conozco la ip gracias al paso anterior. Si mi ip fuera 192.168.1.100, me conectaría de la siguiente manera

#+BEGIN_SRC
ssh ubuntu@192.168.1.100
#+END_SRC

*FUNCIONA!!!*

Cuando te conectas via ssh, te dice la memoria, espacio de tu sd, temperatura, swap,... La verdad es que está muy bien.

Ahora no sucederá porque acabamos de actualizar, pero más adelante también te informa si hay un paquete pendiente para actualizar. 

Para que nos muestre que paquetes son:
#+BEGIN_SRC
apt list --upgradable
#+END_SRC

** Crear contraseña al usuario root y cambiamos el nombre de usuario
Es probable que también quieras cambiar el nombre de usuario y eliminar el de *ubuntu* por defecto.

Para hacer esto, vamos tener que entrar como root.

#+BEGIN_SRC
sudo passwd root
#+END_SRC

Nos pedirá que introduzcamos 2 veces la contraseña.

Iniciamos como root
#+BEGIN_SRC
su root
#+END_SRC

Ahora sigue los pasos para cambiar el usuario *ubuntu* por el usuario que tu desees [[https://ugeek.github.io/blog/post/2019-02-01-cambiar--mover-ruta-y-contrasena-de-usuario-en-tu-raspberry-pi.html][siguiendo el tutorial que os dejé]].

** Snap

Se supone que trae snap por defecto instalado, veamos...
#+BEGIN_SRC
sudo snap --version
#+END_SRC

*FUNCIONA!!!*

Esto quiere decir que de un modo rápido y sencillo, podríamos  instalar servicios como Nextcloud, RocketChat,...

*** Nextcloud
#+BEGIN_SRC
sudo snap install nextcloud
#+END_SRC

*** RocketChat

#+BEGIN_SRC
sudo snap install rocketchat-server
#+END_SRC

*** Plex
#+BEGIN_SRC
sudo snap install plexmediaserver
#+END_SRC

*** Subsonic
#+BEGIN_SRC
sudo snap install subsonic-arubislander
#+END_SRC

*** OpenHub
#+BEGIN_SRC
sudo snap install openhab
#+END_SRC

*** Homebridge
#+BEGIN_SRC
sudo snap install homebridge
#+END_SRC

*** OpenVPN
#+BEGIN_SRC
sudo snap install easy-openvpn-server --candidate
#+END_SRC

*** Servidor de Minecraft
#+BEGIN_SRC
sudo snap install mc-server-installer
#+END_SRC


** Desisnstalar Snap
Snap viene instalado por defecto. Aún así si odias *snap* y no lo quieres, puedes desinstalarlo.

#+BEGIN_SRC
sudo apt purge snapd
#+END_SRC

** Instalar Docker
Vamos a instalar docker
*** Instalación
Lo instalaremos desde los repositorios de Ubuntu. Súper fácil.
#+BEGIN_SRC
sudo apt install docker.io
#+END_SRC

*** Iniciar docker al iniciar el sistema
Creamos el servicio para que inicie docker al iniciar el sistema
#+BEGIN_SRC
sudo systemctl enable --now docker
#+END_SRC

*** Darle privilegios de administración de docker a un usuario
En mi caso, mi usuario es *angel*. Pon tu el tuyo.

#+BEGIN_SRC
sudo usermod -aG docker angel
#+END_SRC

*** Ver si todo esta ok
Vamos a ver que versión de docker hay instalada y si se ha instalado
#+BEGIN_SRC
docker --version
#+END_SRC

*** Instalar docker compose
#+BEGIN_SRC 
sudo apt install docker-compose
#+END_SRC
*** Ver versión de docker compose
#+BEGIN_SRC 
docker-compose version
#+END_SRC

** Instalando Wireguard
Se acabó wireguard en testing. Ubuntu 20.04 trae el kernel de Linux 5.4 y aunque no está disponible por defecto en este kernel de Linux, Ubuntu lo ha añadido para esta LTS y está disponible en sus repositorios.

#+BEGIN_SRC
sudo apt install wireguard
#+END_SRC

*FUNCIONA!!!* Ahora si es facil tener Wireguard en una Raspberry.

Para configurarlo, [[https://ugeek.github.io/blog/post/2020-02-11-wireguard-en-2-minutos-con-wgc.html][te recomiendo el script que hice para crear la configuración del servidor y clientes]].


** Instalar escritorio
Si lo que deseas es tener un escritorio en tu ubuntu
#+BEGIN_SRC
sudo apt update && sudo apt install ubuntu-desktop
#+END_SRC

Ten en cuenta las limitaciones de tu Raspberry, [[https://ubuntu.com/download/desktop][consulta la web oficial]].

** Temperatura Raspberry con Ubuntu
Ubuntu puede mostrar a que temperatura está nuestra Raspberry, pero es diferente a Raspbian.

Para conocer la temperatura:
#+BEGIN_SRC
cat /sys/class/thermal/thermal_zone0/temp
#+END_SRC

Se me ha ocurrido este comando que puedes añadirte a un alias, para que sea más clara la medición
#+BEGIN_SRC
echo "$(cat /sys/class/thermal/thermal_zone0/temp | cut -c 1,2),$(cat /sys/class/thermal/thermal_zone0/temp | cut -c 3,4)º"
#+END_SRC

** Conclusión
Ubuntu por primera vez, nos proporciona un Sistema Operativo 100% usable como alternativa real a Raspbian. Es una versión que por su sencillez y paquetes totalmente a la última, me ha encantado. Voy a testearlo más en profundidad y te recomiendo que tu también lo hagas.


* TODO Gonic. El mejor y más ligero servidor de música con api Subsonic
:PROPERTIES:
:TITLE: Gonic. El mejor y más ligero servidor de música con api Subsonic
:EXPORT_FILE_NAME: gonic-el-mejor-y-mas-ligero-servidor-de-musica-con-api-subsonic
:DESCRIPTION: El desarrollador [[https://github.com/sentriz][Senan Kelly]], ha creado Gonic, un servidor ultra rápido y ligero (En mi Raspberry Pi consume solo 17-19 Mb de ram) que mejora todavía más la experiencia en
:EXPORT_DATE: 2020-05-06 18:15 2021-02-04
:CATEGORY: subsonic
:TAG: música,raspberry
:IMAGE: ./images-blog/gonic.png
:END:

El desarrollador [[https://github.com/sentriz][Senan Kelly]], ha creado Gonic, un servidor ultra rápido y ligero (En mi Raspberry Pi consume solo 12-19 Mb de ram) que mejora todavía más la experiencia en dispositivos como una Raspberry Pi.
#+HTML: <center>
[[./images-blog/gonic.png]]
#+HTML: </center>


Las características de este servidor son:
- Navegación por carpeta (manteniendo intacto su árbol completo)
- navegación por etiquetas (usando taglib - soporta mp3, opus, flac, ape, m4a, wav, etc.)
- Transcodificación y almacenamiento en caché de audio sobre la marcha (requiere ffmpeg ) (gracias spijet )
- escaneo bastante rápido (El desarrollador con su biblioteca de ~ 27k pistas, el escaneo inicial duró unos 10 m y unos 5 s después de forma incremental)
- múltiples usuarios, cada uno con sus propias preferencias de transcodificación, listas de reproducción, pistas principales, artistas principales, etc.
- last.fm scrobbling
- similitudes de artistas y biografías de la api last.fm
- Una interfaz web para la configuración (configurar last.fm, administrar usuarios, iniciar escaneos, etc.)
- soporte para la etiqueta del artista del álbum , para no saturar su lista de artistas con apariencias de álbumes compilados
- escrito en go , tan ligero y adecuado para una Raspberry pi, etc.
- nueva autenticación de token
- probado en dsub , jamstash , música sublime y ondas de sonido

Que no tiene:
Tenemos que tener en cuenta un pequeño detalle, para que aparezcan las portadas de nuestras discos en los clientes, tenemos que dejar en la carpeta donde tenemos los archivos mp3, flac,... un archivo *jpg* o *png* con el nombre *folder*. Ejemplo. *folder.jpg*. Gonic entenderá que es una portada y la enviará al cliente para que sea visualizada.

De momento no integra el poder poner una estrella o puntuación a una canción.

Por lo demás, es un servidor alucinante y que sincroniza a la perfección y de un modo muy rápido.

** Docker para Raspberry Pi, ARM
La imagen, tan solo tiene 27.68 MB
#+BEGIN_SRC
docker create \
  --name=gonic \
  -p 88:80 \
  -v $HOME/media/musica:/music:ro \
  -v $HOME/docker/gonic/data:/data \
  -v $HOME/docker/gonic/cache:/cache \
  -v $HOME/docker/gonic/podcasts:/podcasts \     
  ugeek/gonic:arm
#+END_SRC

- /data -> base de datos de gonic, etc...
- /music -> tu música
- /podcasts -> tus podcasts
- /cache -> trasncodificación

** Docker-compose para Raspberry Pi, ARM

#+BEGIN_SRC 
version: "3"
services:
  gonic_web:
    image: ugeek/gonic:arm
    container_name: gonic
    ports:
      - 88:80
    volumes:
      - $HOME/docker/gonic/musica:/music:ro
      - $HOME/docker/gonic/podcasts:/podcasts
      - $HOME/docker/gonic/data:/data
      - $HOME/docker/gonic/cache:/cache
#+END_SRC



** Docker oficial para amd64

#+BEGIN_SRC
docker create \
  --name=gonic \
  -p 88:80 \
  -v $HOME/media/musica:/music:ro \
  -v $HOME/docker/gonic/data:/data  \
  -v $HOME/docker/gonic/cache:/cache \
  -v $HOME/docker/gonic/podcasts:/podcasts \
  sentriz/gonic:latest
#+END_SRC

** Administración de Gonic

En el montaje del docker, del paso anterior, he tomado de ejemplo el puerto 88. Para acceder a la página de administración, tendríamos que conectarnos a la ip de nuestro servidor puerto 88. http://ip:88

** Crear listas en m3u8
*** Que es una lista m3u8

Los archivos M3U8 son listas de reproducción como los m3u, con la diferencia que los archivos m3u8 utilizan el estándar de codificación de caracteres UTF-8. Esto significa que las listas pueden contener nombres escritos en distintos idiomas y caracteres.

El archivo de texto sin formato contiene información sobre la ubicación de las canciones en la lista de reproducción.

Un ejemplo de archivo m3u8 sería:

#+BEGIN_SRC
/music/The Rolling Stones/The Rolling Stones - (I Can't Get No) Satisfaction.mp3
/music/The Rolling Stones/The Rolling Stones - Sympathy for the Devil.mp3
/music/./track
#+END_SRC

*** Listar toda tu música
Para listar toda la música que tenemos, nos situariamos en la raíz del docker y ejecutaríamos el comando find:

#+BEGIN_SRC
find /music/ > all_music.list
#+END_SRC

*** Crear Listas

Entramos dentro del contenedor

#+BEGIN_SRC
docker exec  -it gonic sh
#+END_SRC

Ahora corremos *find* para listar todas las canciones de un directorio. En este ejemplo voy listar todas las canciones *mp3* del directorio The Rolling Stones.

#+BEGIN_SRC
find /music/"The Rolling Stones" | grep mp3
#+END_SRC

Voy a crear mi lista en formato *m3u8* de las canciones en formato *flac* de este directorio
#+BEGIN_SRC
find /music/"The Rolling Stones" | grep flac > lista.m3u8
#+END_SRC

** Desde la Terminal
Accedemos al interior del docker
#+BEGIN_SRC
docker exec  -it gonic sh
#+END_SRC

Ejecutamos para ver la ayuda
#+BEGIN_SRC
gonic -h
#+END_SRC

#+BEGIN_SRC
Usage of gonic:
-cache-path string
path to cache (default "/tmp/gonic_cache")
-config-path string
path to config (optional)
-db-path string
path to database (optional) (default "gonic.db")
-listen-addr string
listen address (optional) (default "0.0.0.0:4747")
-music-path string
path to music
-proxy-prefix string
url path prefix to use if behind proxy. eg '/gonic' (optional)
-scan-interval int
interval (in minutes) to automatically scan music (optional)
-version
show gonic version

#+END_SRC

Con los comandos de terminal, podemos hacer que se hagan sincronizaciones de nuestra biblioteca añadiendo cada cuantos minutos queremos que se produzca.

Para más información, os recomiendo visitar el repositorio del proyecto.

** Conclusión

La ligereza de Gonic, bajos recursos y la creación de listados, hace que este servidor sea ideal, sobretodo para servidores como una Raspberry Pi.

** Fuente
- https://github.com/sentriz/gonic
* TODO Servidor de ebooks en Ubuntu, Debian, Raspbian,... con Calibre
:PROPERTIES:
:TITLE: Servidor de ebooks en Ubuntu, Debian, Raspbian,... con Calibre
:EXPORT_FILE_NAME: servidor-de-ebooks-con-calibre
:DESCRIPTION: Tener un servidor de ebooks en nuestro servidor, Raspberry,... es súper fácil. Además, teniendo en cuenta que calibre consume muchos recursos, esta versión la verdad es que está bastante bien
:EXPORT_DATE: 2020-05-07 20:51
:CATEGORY: libros
:TAG: raspberry,servidor
:IMAGE: ./images-blog/calibre.png
:END:

Tener un servidor de ebooks en nuestro servidor, Raspberry,... es súper fácil. Además, teniendo en cuenta que calibre consume muchos recursos, esta versión la verdad es que está bastante bien optimizada, consumiendo pocos recursos.

Va a crear una página web simple, que permite búsqueda por autor, título, formato, etc... Una buena base de datos de nuestra biblioteca.

#+HTML: <center>
[[./images-blog/calibre.png]]
#+HTML: </center>

El objetivo va a ser crear una carpeta donde pondremos todos los libros sin ordenar, ejecutaremos un comando para crear la base de datos de calibre y además, calibre parará todos los libros a la segunda carpeta, donde los guardará por autor, libro,...

** Instalación
Muy sencillo, desde los repositorios
#+BEGIN_SRC
sudo apt install calibre xvfb
#+END_SRC

** Creando carpetas
Crearemos un directorio llamado *Libros* y *add*.

#+BEGIN_SRC
mkdir -p /home/pi/add/ ; mkdir -p /home/pi/Libros/
#+END_SRC

** Iniciando
Vamos a crear la base de datos e importar los libros de la carpeta *add* a *Libros*.

Dejaremos todos los libros que queramos añadir a nuestra biblioteca en la carpeta *add* y ejecutaremos este comando.

Sustituye el usuario pi por tu usuario y cambia la ruta de tus libros si así lo deseas.

#+BEGIN_SRC
xvfb-run calibredb add /home/pi/add/* --library-path /home/pi/Libros/
#+END_SRC

** Corriendo el servidor web
Para ver Calibre en su versión web, ejecutaremos el servidor, en este ejemplo por el puerto 8080.

#+BEGIN_SRC
calibre-server "/home/pi/Libros/" --port 8080
#+END_SRC

Para conectarnos: http://tu_ip:8080

Para detener el servidor, hazlo con Ctrl-c o cerrando la terminal.

** Crea el servicio con Systemd
Para que el servicio siempre esté corriendo y se inicie al iniciar el sistema operativo, vamos a crear el servicio.

#+BEGIN_SRC
sudo nano /etc/systemd/system/calibre-server.service
#+END_SRC

Añadimos:

#+BEGIN_SRC
[Unit]
Description=Calibre Content Server
After=network.target

[Service]
Type=simple
User=pi
Group=pi
ExecStart=/usr/bin/calibre-server "/home/pi/Libros/" --port 8080

[Install]
WantedBy=default.target
#+END_SRC

*Recuerda cambiar pi por tu usuario*.

Inicia el servicio con:

#+BEGIN_SRC
sudo systemctl start calibre-server.service
#+END_SRC


Si quieres iniciarlo al iniciar tu Raspberry o Servidor

#+BEGIN_SRC
sudo systemctl enable calibre-server.service
#+END_SRC


Para detenerlo

#+BEGIN_SRC
sudo systemctl stop calibre-server.service
#+END_SRC


* TODO ZRAM. Doblando la RAM y no utilizando - quemando la SD de mi Raspberry
:PROPERTIES:
:TITLE: ZRAM. Doblando la RAM y no utilizando - quemando la SD de mi Raspberry
:EXPORT_FILE_NAME: zram-ampliando-la-ram-y-no-utilizando--quemando-la-sd-de-mi-raspberry
:DESCRIPTION: Este método no solo sirve para la Raspberry, pero es ideal para ella, ya que en el caso de mi Raspberry 3, solo tiene 1Gb de RAM y para la
:EXPORT_DATE: 2020-05-09 18:42
:CATEGORY: raspberry
:TAG: ram
:IMAGE: ./images-blog/ram.png
:END:

Este método no solo sirve para la Raspberry, pero es ideal para ella, ya que en el caso de mi Raspberry 3, solo tiene 1Gb de RAM y para la nueva versión de Ubuntu, sumado a todo lo que quiero correr en ella, se queda un poco corta.

Además, el punto fuerte es no tener que quemar mi SD a base de lecturas y escrituras con la memoria Swap.

#+HTML: <center>
[[./images-blog/ram.png]]
#+HTML: </center>

Desde la versión 3.14, ZRAM viene incluida en el kernel de Linux. ZRAM comprime los datos de la Swap y los almacena en la RAM, no utilizando la tarjeta SD de la Raspberry o Disco Duro de un PC, ganando más velocidad.

Por contra, haremos trabajar más a la CPU comprimiendo los datos.

Vamos a utilizar el script de [[https://github.com/novaspirit/rpi_zram][Novaspirit]] disponible en GitHub, para hacerlo de un modo rápido y seguro.

** Descargamos el Scrirpt
#+BEGIN_SRC
sudo wget -O /usr/bin/zram.sh https://raw.githubusercontent.com/Bash-Projects/rpi_zram/master/zram.sh
#+END_SRC

Damos permisos de ejecución
#+BEGIN_SRC
sudo chmod +x /usr/bin/zram.sh
#+END_SRC

Creamos un script para iniciar zram. Recuerda que el usuario que estoy utilizando es *angel*, sustitúyelo por el tuyo.

Voy a meter el script en la carpeta scripts
#+BEGIN_SRC 
mkdir ~/scripts
#+END_SRC

Creo y abro el archivo con nano
#+BEGIN_SRC 
nano /home/angel/scripts/zram.sh
#+END_SRC

Copio el siguiente contenido
#+BEGIN_SRC
#!/bin/bash
/usr/bin/zram.sh &
#+END_SRC

** Montamos zram con cron
#+BEGIN_SRC 
sudo crontab -e
#+END_SRC

Sustituye nuevamente *angel* por tu usuario.

#+BEGIN_SRC
@reboot ( sleep 50 ; sudo /home/angel/scripts/zram.sh )
#+END_SRC
50 segundos tras el inicio del sistema, se ejecutará el script de zram.sh.


Reinicia
#+BEGIN_SRC
sudo reboot now
#+END_SRC

** Comprobando la memoria
Vamos a ver si ya se nos ha ampliado la memoria y estamos utilizando zram.

#+BEGIN_SRC
free -h
#+END_SRC

Como podemos comprobar, hemos doblado el tamaño de RAM. Ahora la Swap, tiene el mismo tamaño que la memoria RAM.

#+BEGIN_SRC
swapon -s
#+END_SRC

Mediante este comando, podemos ver como consta de cuatro bloques iguales (en el caso de la Raspberry 3), uno por cada núcleo de la CPU.

Un modo más gráfico es utilizar
#+BEGIN_SRC
htop
#+END_SRC

** Fuentes
- https://github.com/Bash-Projects/rpi_zram/blob/master/README.md
- https://acastillog.es/20180316.php

* TODO Gestionando mis tareas en la terminal con topydo
:PROPERTIES:
:TITLE: Gestionando mis tareas en la terminal con topydo
:EXPORT_FILE_NAME: gestionando-mis-tareas-en-la-terminal-con-topydo
:DESCRIPTION: Si te gusta el todo.txt y utilizas la terminal, topydo es tu aplicación. Topydo, como su nombre indica, es una aplicación desarrollada en python para gestionar o añadir tareas utilizando el método todo.txt, que mejora la experiencia respecto al script original todotxt-cli de Gina Trapani
:EXPORT_DATE: 2020-05-22 20:10
:CATEGORY: todo.txt
:TAG: tareas,terminal
:IMAGE: ./images-blog/topydo.png
:END:



Si te gusta el todo.txt y utilizas la terminal, topydo es tu aplicación. Topydo, como su nombre indica, es una aplicación desarrollada en python para gestionar o añadir tareas utilizando el método todo.txt, que mejora la experiencia respecto al script original *todotxt-cli* de Gina Trapani.

Las opciones de uso son muy parecidas y en algunos casos, más simples. Una de las mejoras, es la visualización de los listados de proyectos, contextos, prioridades,... son más visibles, ya cada uno se muestran con colores diferentes.

Lo más espectacular, son dos modos que podemos utilizar de topydo.

Prompt, te permite gestionar tus tareas, estando dentro de la aplicación, sin necesidad de estar todo el rato introduciendo el comando =topydo=.
#+HTML: <center>
[[./images-blog/topydo.png]]
#+HTML: </center>

=Column=, es otro modo que permite mostrarnos todas nuestras tareas en columnas, fusionando si lo deseas el método kanban con el todo.txt, o mostrar columnas con tus contextos, proyectos, prioridades,....

La verdad es que he profundizado muchísimo con esta aplicación y he disfrutado mucho. Voy a explicaros un poco de los tres modos.

Si buscas algo más concreto, [[https://ugeek.github.io/blog/varios/topydo.html][he clonado el Tiki Wiki de su documentación]], para que puedas consultarla cuando lo desees. Actualmente, su página principal que contenía esta documentación, ya no esta disponible.

Crearé en breve una nueva sección dentro del Blog de uGeek para cosas como estas. Documentaciones, atajos de teclado,...


** Instalación de topydo
Si tienes instalado python3 y pip3, el sistema de gestión de paquetes de python, es tan simple como:
#+BEGIN_SRC
sudo pip3 install topydo
#+END_SRC

** Configuración

Podemos configurar topydo con uno o más archivos de configuración de estilo ini. topydo busca los siguientes archivos de configuración en este orden:

#+BEGIN_SRC
/etc/topydo.conf
$HOME/.config/topydo/config
$HOME/.topydo
.topydo (en el directorio de trabajo actual)
topydo.conf (en el directorio de trabajo actual)
topydo.ini (en el directorio de trabajo actual) (para soporte mejorado en Windows)
#+END_SRC

Para especificar un archivo de configuración alternativo, utilizaremos la opción -c.

Los valores en archivos de configuración posteriores, anulan los valores anteriores.

*** Alias

Mediante el archivo de configuración, podremos crear nuestros propios alias para invocar a topydo con comandos personalizados. Esta funcionalidad es similar a los alias en un shell de Unix (bash, zsh, etc.).

Vamos a crear el archivo de configuración =$HOME/.config/topydo/config= y añadir unos alias de ejemplo:

#+BEGIN_SRC
[aliases]
# Muestra la primera linea de la lista
next = ls -n 1

# Muestra mi lista de trabajo, con la opción lst
lst = ls @trabajo

# abreviando comando. Pulsando l, en lugar de ls o q para salir
e = edit {}
l = ls {}
q = exit

# Poner una estrella a una tarea. Opción no standar de todo.txt
star = tag {} star 1
unstar = tag {} star
#+END_SRC

Ahora para listar mis tareas, podría hacerlo con este comnado
#+BEGIN_SRC
topydo l
#+END_SRC


*** Crea el alias en tu sistema operativo
Recuerda que para no tener que estar utilizando todo el rato el comando *topydo*, podemos crea un alias para sustituirlo, por ejemplo, por la letra *t*.

Así, tal como explicaba antes, listar nuestras tareas sería tan simple como:
#+BEGIN_SRC
t l
#+END_SRC

** topydo. Uso Básico
topydo es mucho más simple que todotxt-cli, ya que no necesitamos crear previamente un archivo de configuración.

Simplemente entramos en el directorio donde está el archivo todo.txt y ejecutando el comando =topydo=, ya podemos gestionar nuestra lista de tareas de nuestro archivo todo.txt.

*** Indicando la ruta del archivo todo.txt y done.txt
Si no accedemos al directorio, tenemos que indicar la ruta del archivo todo.txt o done.txt.
#+BEGIN_SRC
topydo -t ~/todo/todo.txt -d ~/todo/done.txt
#+END_SRC

Si utilizamos la versión prompt, podríamos lanzarlo con:
#+BEGIN_SRC
topydo -t ~/todo/todo.txt prompt
#+END_SRC
*** Añadir tarea
#+BEGIN_SRC
topydo add "grabar podcast de topydo +podcast"
#+END_SRC

Para que sea más simple y rápido, a diferencia de todotxt-cli, topydo nos permite añadir la tarea sin necesidad de utilizar comillas
#+BEGIN_SRC
topydo add grabar podcast de topydo +podcast
#+END_SRC

*** Listar tareas

#+BEGIN_SRC
todopy ls
#+END_SRC

*** Filtrar
Tan sencillo como escribir el comando seguido de la palabra a filtrar:
#+BEGIN_SRC
topydo palabra
#+END_SRC

** Modo prompt

El modo de solicitud es bastante similar a la interfaz de línea de comandos, excepto que los subcomandos se reconocen inmediatamente, no es necesario escribir *topydo* cada vez.

Los cambios en la lista de tareas pendientes, se guardan inmediatamente después de cada comando.

Este modo es adecuado si invocamos la CLI de topydo con bastante frecuencia.
** Instalación modo prompt
El modo de prompt requiere una dependencia adicional prompt_toolkitque así que vamos a instalarla primero.

#+BEGIN_SRC
sudo pip3 install "topydo[prompt]"
#+END_SRC

** Uso modo prompt
Iniciamos con:
#+BEGIN_SRC
topydo prompt
#+END_SRC
Y aparecerá en la terminal:
#+BEGIN_SRC
topydo>
#+END_SRC
Ahora puedes introducir comandos sin necesidad de escribir todo el rato topydo.

*** Salir del modo prompt
Para salir, escribe el comando *exit*.
*** Listar
**** Listar todas las tareas

#+BEGIN_SRC
ls
#+END_SRC

**** Listar Proyectos

Escribiendo ls + TAB, nos mostrará todas las opciones de ls.

#+BEGIN_SRC
lsproj

lspr
#+END_SRC

**** Listar contextos

#+BEGIN_SRC
lscon
#+END_SRC

*** Filtrar
Simplemente escribimos la palabra a filtrar y pulsamos *enter*. Topydo nos mostrará las tareas que coincidan con esa palabra.

*** Limpiar terminal
Igual que hacemos habitualmente en nuestra terminal, utilizaremos el atajo *Ctrl+l*.

*** Añadir una tarea
Escribimos add seguido de la tarea
#+BEGIN_SRC
add tarea
#+END_SRC

*** Autocompletar

Los siguientes elementos se autocompletan automáticamente al presionar *TAB*:

- Comandos, Subcomandos y alias
- Proyectos (presione Tab después +)
- Contextos (presione Tab después @)
- Fechas (presione Tab después de due:o t:, o las etiquetas correspondientes que se configuraron )

*Con las flechas arriba y abajo, podemos seleccionar el histórico de comandos previamente introducidos*.

Con *TAB* autocompleta lo que estamos escribiendo.
Ejemplo.
#+BEGIN_SRC
add tarea @c
#+END_SRC

Si pulsamos ahora *TAB*, en mi caso autoescribirá el contexto *@casa*

El proceso para crear una tarea utilizando el autocompletado, sería:
1) add
2) Escribimos de un modo natural la tarea
3) @ y pulsamos TAB o + y pulsamos TAB

#+BEGIN_SRC
add @podcast hablar en el podcast de topydo
#+END_SRC

*** Añadir una prioridad a una tarea
Añadir prioridad *A* a la tarea 56.
#+BEGIN_SRC
pri 56 A
#+END_SRC

También podemos utilizar *a* minúscula, no es obligatorio escribir *A*.

*** Añadir fecha
Escribe *due:* o *t:* y pulsa *TAB*. Te mostrará unas fechas por defecto.

*** Posponer fecha
Posponer un dia la tarea 16
#+BEGIN_SRC
postpone 16 1d
#+END_SRC
También podemos posponer semanas, meses, años...
- w -> semana
- m -> mes
- y -> año

*** Editar
Si escribimos *edit*, nos abrirá todo el archivo todo.txt para editarlo.
Si escribimos *edit 20*, editaremos solo la tarea 20.

*** Borrar una tarea
Para borrar una tarea, es tan simple como:
#+BEGIN_SRC
del 45
#+END_SRC
Borrando la tarea 45

*** Revertir cambios
Es posible que hayas guardado una tarea y te hayas equevocado. Para revertir, utilizaremos el comando revert
#+BEGIN_SRC
revert
#+END_SRC

Te preguntaras, ¿como hace esto?. Topydo guarda un bakup de tu todo.txt en el mismo directorio que tienes el archivo llamado *.todo.bak*.

*** Destacar tareas con estrellas
Esto es algo que no está en la sintaxis oficial de todo.txt.

Podemos destacar tareas con un número de estrellas según la importancia.

La sintaxis sería:

#+BEGIN_SRC
(B) 2020-04-27 esta tarea tiene una estrella star:1
#+END_SRC

Tenemos que añadir un alias

Alias
#+BEGIN_SRC
# starring and unstarring
# `star 42` substitutes to `tag 42 star 1`
star = tag {} star 1
unstar = tag {} star
#+END_SRC

Para visualizar el autocompletado, escribimos =s + TAB= , start 1.
start 2

**** Añadiendo estrellas
A la tarea 42, le pongo una estralla
#+BEGIN_SRC
star 42 1
#+END_SRC
*** Añadir más texto a una tarea con appen
Para añadir más texto utilizando appen:
#+BEGIN_SRC
appen 47 texto a añadir
#+END_SRC
*** Tarea realizada
Para marcar una tarea como realizada, utilizamos *do* seguido del número de tarea. Automáticamente esta tarea, irá al archivo *done.txt*.



Para finalizar varias tareas, utilizamos *do* seguido de todos los números de tareas
#+BEGIN_SRC
do 5 10 30
#+END_SRC
Finalizando las tareas 5, 10, 30

*** Resumen de Comandos disponibles

Escribiendo *help*, nos mostrará la ayuda con todos los comandos disponibles.

#+BEGIN_SRC
add
append (app)
del (rm)
dep
depri
do
edit
ls
listcon (lscon)
listprojects (lsprj)
postpone
pri
revert
sort
tag

Run `topydo help <subcommand>` for command-specific help.

#+END_SRC
** Columnas
*** Instalación con columnas
#+BEGIN_SRC
sudo pip3 install 'topydo[columns]'
#+END_SRC
*** Iniciar
Situándonos en el directorio donde tenemos nuestro archivo todo.txt.
#+BEGIN_SRC
topydo columns
#+END_SRC
Si no es así, tendremos que especificar la ruta, tal como explicaba al principio del artículo.

*** Uso
Para introducir un comando, utilizaremos *:*, como en vim.
Con *:help*, tendremos la ayuda.
- Ayuda -> :help
- Salir -> :quit o :exit

*** Acciones de Columnas. Añadir, borrar,... Columnas

Para añadir una nueva columna , pulsa la tecla *A*.

| Atajo	  | Acción	        | Descripción                                               |
|----------------+-----------------------+-----------------------------------------------------------|
| A	      | append_column	 | Agregar / agregar columna (a la derecha)                  |
| I	      | insert_column	 | Insertar nueva columna antes de la columna actual         |
| E	      | edit_column	   | Editar la definición de columna actual                    |
| D	      | delete_column	 | Eliminar la columna actual                                |
| Y	      | copy_column	   | Copie ( y ank) la columna actual                          |
| L	      | swap_left	     | Cambiar la columna actual con la columna vecina izquierda |
| R	      | swap_right	    | Cambiar la columna actual con la columna vecina derecha   |
| Ctrl-a	 | mark_all	      | Marca todos los elementos en la columna actual            |

*** Navegación

| Atajo	     | Acción	       | Descripción                                                        |
|-------------------+----------------------+--------------------------------------------------------------------|
| j o ↓	     | up	           | Mueve un elemento hacia abajo                                      |
| k o ↑	     | down	         | Mueve un elemento hacia arriba                                     |
| l o →	     | next_column	  | Ir a la siguiente columna                                          |
| h o ←	     | prev_column	  | Ir a la columna anterior                                           |
| gg o Home         | 	home	 | Mover hacia arriba                                                 |
| G o End	   | end	          | Mover al fondo                                                     |
| 0	         | first_column	 | Moverse a la primera columna                                       |
| $	         | last_column	  | Moverse a la última columna                                        |
| :		 |                      | Enfoca la línea de comandos para ejecutar comandos personalizados. |

*** Acciones de elementos de todo

| Atajo	         | Acción              | 	   Descripción                                                                |
|-----------------------+---------------------+---------------------------------------------------------------------------------------|
| d	             | cmd del {}	  | Se ejecuta delen elementos resaltados                                                 |
| e	             | cmd edit {}	 | Se ejecuta editen elementos resaltados                                                |
| m	             | mark	        | Marcar elemento actual (para realizar acciones en varios elementos simultáneamente)   |
| pp< período >	 | postpone	    | Se ejecuta postponeen los elementos resaltados con el período dado .                  |
| pr< prioridad >       | pri	         | Se ejecuta prien los elementos resaltados con la prioridad dada.                      |
| ps< período >	 | postpone_s	  | Se ejecuta postponeen modo estricto en los elementos resaltados con el período dado . |
| u	             | cmd revert	  | Ejecuta revert                                                                        |
| x	             | cmd do {}	   | Se ejecuta doen elementos resaltados                                                  |

*** Configuración Columnas

Vamos a crear el archivo de configuración para poder ver diferentes columnas preestablecidas por mi.

#+BEGIN_SRC
nano $HOME/.config/topydo/config
#+END_SRC

Añadimos, por ejemplo

#+BEGIN_SRC
[Current]
title = Current
sortexpr = desc:importance
groupexpr = project
show_all = 0

[Overdue]
title = Overdue
filterexpr = due:<today
sortexpr = desc:due
show_all = 1

[Starred]
title = Starred
filterexpr = star:1
show_all = 1
#+END_SRC

Iniciaremos con mi configuración, ejecutando el siguiente comando
#+BEGIN_SRC
topydo columns -l $HOME/.config/topydo/config
#+END_SRC

*** Otros atajos de línea de comando

La línea de comandos, activada al presionar *:*, admite las siguientes teclas:

- Ctrl-a	-> Ir al principio
- Ctrl-e	-> Muévete hasta el final
- Ctrl-u	-> Eliminar del cursor al principio
- Ctrl-k	-> Eliminar desde el cursor hasta el final

** Android
Gracias a Termux, también podremos utilizar topydo en Android.

Voy a explicar un poco el proceso

1) Instalaremos Termux desde Google Play o F-Droid
2) Instalamos Python3 =apt-get install python=
3) Instalamos topydo =pip3 install topydo=
4) Crearemos unos alias para que nos se más sencillo:

#+BEGIN_SRC
vi $HOME/.bashrc
#+END_SRC

Añadiremos el siguiente contenido
#+BEGIN_SRC
alias topydo=$HOME/.local/bin/topydo
alias do="topydo do"
alias add="topydo add"

# -N and %S make sure that the list fits on the screen properly
alias t="topydo ls -N -F '%I %S' "
#+END_SRC

Asegurate tener source =$HOME/.bashrc= en tu =$HOME/.bash_profile=.

** Fuentes
- https://github.com/bram85/topydo/
- https://c306.net/t/topydo-docs/
- https://ugeek.github.io/blog/varios/topydo.html

* TODO screen. Comandos básicos
:PROPERTIES:
:TITLE: screen. Comandos básicos
:EXPORT_FILE_NAME: 2020-05-23-screen-comandos-basicos
:DESCRIPTION: Screen nos permite tener múltiples terminales abiertas en una sesión o llevar a segundo plano un proceso inacabado, que cerrando la terminal, se detendría.
:EXPORT_DATE: 2020-05-23 18:15
:CATEGORY: bash
:TAG: screen
:IMAGE: ./images-blog/bash.png
:END:

Screen nos permite tener múltiples terminales abiertas en una sesión o llevar a segundo plano un proceso inacabado, que cerrando la terminal, se detendría.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Voy dejaros los comandos básicos para hacer uso de screen.


** Instalación
Podemos encontrarlo en cualquier distro en sus repositorios
#+BEGIN_SRC
sudo apt install screen
#+END_SRC

** Iniciar screen
Para iniciar screen y crear una nueva sesión:
#+BEGIN_SRC
screen
#+END_SRC
** Iniciar y poner nombre a la sesión 
Para iniciar screen y poner un nombre a la sesión, utilizaremos la opción *-S*.
#+BEGIN_SRC
screen -S nombre_de_sesión
#+END_SRC

** Salir de screen y dejar sesión en segundo plano:
#+BEGIN_SRC
Ctrl+a d
#+END_SRC

** Listar sesiones screen

#+BEGIN_SRC
screen -ls
#+END_SRC

Vemos los id (número) de cada screen. Para entrar en esa sesión, lo haríamos indicando su id:

#+BEGIN_SRC
screen -r id
#+END_SRC
** Cerrar sesión screen, estando dentro

#+BEGIN_SRC
exit
#+END_SRC

** Cerrar sesión desde fuera
Si la sesión tiene nombre, podríamos cerrarla desde fuera de screen así:
#+BEGIN_SRC
screen -XS nombre_de_sesión quit
#+END_SRC


 
* TODO Backup de tu Shaarli
:PROPERTIES:
:TITLE: Backup de tu Shaarli
:EXPORT_FILE_NAME: backup-de-tu-shaarli
:DESCRIPTION: Para hacer un backup de los enlaces que tenemos en shaarli, es muy sencillo.
:EXPORT_DATE: 2020-05-24 17:30
:CATEGORY: docker
:TAG: shaarli,rss,feed
:IMAGE: ./images-blog/shaarli.png
:END:

Para hacer un backup de los enlaces que tenemos en shaarli, es muy sencillo.

#+HTML: <center>
[[./images-blog/shaarli.png]]
#+HTML: </center>


** Backup de tus enlaces en Shaarli
Vamos ha hacer un *cat* del *datastore.php* y lo vamos a exportar fuera. En mi caso, voy a guardarlo en la carpeta de configuración del contenedor de shaarli

#+BEGIN_SRC
docker exec -t shaarli cat /var/www/shaarli/data/datastore.php > ~/docker/shaarli/$(date +%Y-%m-%d_%H%M)-shaarli.php
#+END_SRC

Después, si montamos shaarli en otro lugar, solo tendremos que importar datastore.php, que además, vamos a añadir la fecha del backup.

Recomiendo utilizar cron. Así nos despreocupamos y siempre tendremos nuestro backup.

** Fuente
- https://shaarli.readthedocs.io/en/latest/guides/backup-restore-import-export/
* TODO FreshRSS. Mi servidor de RSS
:PROPERTIES:
:TITLE: FreshRSS. Mi servidor de RSS
:EXPORT_FILE_NAME: freshrss-mi-servidor-de-rss
:DESCRIPTION: Hace algo más de tres años, [[Bon dia Nuria][os hablé en el podcast de mi experiencia con Freshrss]]. Entonces, no había una buena aplicación para Android. Hoy eso ha cambiado.
:EXPORT_DATE: 2020-05-25 18:25
:CATEGORY: rss
:TAG: feed
:IMAGE: ./images-blog/freshrss.png
:END:

Hace algo más de tres años, [[Bon dia Nuria][os hablé en el podcast de mi experiencia con Freshrss]]. Entonces, no había una buena aplicación para Android. Hoy eso ha cambiado.

Voy a darle una nueva oportunidad, ya que basándome en sensaciones, es mucho más rápido en el momento de sincronizar con la aplicación mobile. Las aplicaciones de Android de terceros, pese a no ser algunas de Software Libre, son mucho mejores que la versión de Tiny Tiny RSS y la navegación vía web, es muchísimo mejor y se adapta perfectamente a cualquier tamaño de pantalla, pudiendo utilizarla en cualquier dispositivo.

#+HTML: <center>
[[./images-blog/freshrss.png]]
#+HTML: </center>

Si quieres profundizar, FreshRSS permite personalizar el periodo de actualización de cada Feed, grupo de Feed's, compartir con muchos servicios como Pocket, Wallabag, Shaarli,... Te informa de los Feeds que están en desuso, esta llena de estadísticas sobre nuestro Feeds favoritos,...

Vamos, que está muy completito.

Ahora todo es mucho más fácil de instalar, gracias al docker oficial y el de la comunidad LinuxServer.io.

Vamos a Instalarlo!!!

** Docker Oficial ARM
Podemos encontrarlo en el [[https://hub.docker.com/r/freshrss/freshrss][DockerHub]].

#+BEGIN_SRC
docker create \
 --name=freshrss  \
 -e TZ=Europe/Mardrid  \
 -v $HOME/docker/freshrss/data:/var/www/FreshRSS/data  \
 -v $HOME/docker/freshrss/extensions:/var/www/FreshRSS/extensions  \
 -p 80:80 \
 freshrss/freshrss:arm
#+END_SRC

** Docker Oficial amd64
Así creamos el docker para arquitectura amd64.
#+BEGIN_SRC
docker create  \
 -e TZ=Europe/Mardrid  \
 -v $HOME/docker/freshrss/data:/var/www/FreshRSS/data  \
 -v $HOME/docker/freshrss/extensions:/var/www/FreshRSS/extensions  \
 -p 80:80 \
 freshrss/freshrss
#+END_SRC

*** Actualizar FreshRSS con cron

Actualizar manualmente FreshRSS
#+BEGIN_SRC
docker exec --user www-data freshrss php ./app/actualize_script.php
#+END_SRC

Actualizar manualmente FreshRSS, guardando un log
#+BEGIN_SRC
docker exec --user www-data freshrss php ./app/actualize_script.php > ~/docker/freshrss/FreshRSS.log 2>&1
#+END_SRC

Automatizándolo con cron en nuestro sistema operativo.
Este método, cada 20 minutos, se actualizaran nuestro Feeds.
#+BEGIN_SRC
*/20 * * * * docker exec freshrss php ./app/actualize_script.php > ~/docker/freshrss/FreshRSS.log 2>&1
#+END_SRC

** Docker amd64, ARM, LinuxServer
El docker de Linux Server, sirve para  arquitecturas ARM, amd64 y en este caso, FreshRSS se actualiza sin necesidad de hacerlo mediante cron.
#+BEGIN_SRC
docker create \
 --name=freshrss  \
 -e PUID=1000  \
 -e PGID=1000  \
 -e TZ=Europe/Madrid  \
 -p 80:80  \
 -v $HOME/docker/freshrss:/config  \
 linuxserver/freshrss
#+END_SRC

** Crea una contraseña para la api y conéctate a tu aplicación móvil

Si nos conectamos a esta url, veremos que por defecto no tenemos habilitada la api =http://url:puerto/api/=

Para habilitarla, iremos en el menú de configuración al apartado *Identificación* y seleccionaremos *Concederle acceso a la API (necesario para apps de móvil)*

Una vez hemos habilitado la api, ahora vamos al apartado *Perfil* y en la parte inferior, donde pone *API management*, pondremos una contraseña a la Api.


Al iniciar la sesión en tu movil o cualquier aplicación que utiliza la api, introduciremos nuestra *url del servidor*, *usuario* y *contraseña de la api*.

Ya tenemos acceso a Freshrss!!!

** Aplicaciones Android

- [[https://play.google.com/store/apps/details?id=com.seazon.feedme][FeedMe (RSS Reader | Podcast)]] *Esta utilizo*
- [[https://play.google.com/store/apps/details?id=com.isaiasmatewos.readably][Readably]]
- [[https://play.google.com/store/apps/details?id=com.readrops.app][Readrops]] *Software Libre* [[https://github.com/readrops/Readrops/issues][GitHub]]
- [[https://f-droid.org/es/packages/fr.chenry.android.freshrss/][FreshRss]] *Software Libre* [[https://git.feneas.org/christophehenry/freshrss-android][GitLab]]

** Fuentes
- https://github.com/FreshRSS/FreshRSS/tree/master/Docker
 
* TODO Copiar directorios o archivos de un Docker a Local o viceversa
:PROPERTIES:
:TITLE: Copiar directorios o archivos de un Docker a Local o viceversa
:EXPORT_FILE_NAME: copiar-directorios-o-archivos-de-un-docker-a-local-o-viceversa
:DESCRIPTION:
:EXPORT_DATE: 2020-05-27 17:30
:CATEGORY: docker
:TAG: servidor
:IMAGE: ./images-blog/docker.png
:END:


Después de hacer el artículo de como hacer un Backup del docker Shaarli, busqué un poco de información para averiguar de que modo podemos copiar archivos del interior del contenedor y guardarlos en la máquina local y viceversa.

Como podéis ver en este artículo, algo que de salida puede parecer muy complicado, es súper fácil.
#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>


Aunque es importante el tener montado *volumenes*, que sería esa carpeta de intercambio entre tu Docker y tu máquina local, con este método, si no has montado estos volumenes, si te permite intercambiar archivos o directorios con tus dockers.

** Del Contenedor a Local

#+BEGIN_SRC
docker cp NOMBRE_CONTENEDOR:RUTA_DEL_CONTENEDOR RUTA_LOCAL
#+END_SRC

** De Local al Contenedor
#+BEGIN_SRC
docker cp RUTA_LOCAL NOMBRE_CONTENEDOR:RUTA_DEL_CONTENEDOR
#+END_SRC

- https://riptutorial.com/es/docker/example/6587/copiando-archivo-desde---a-contenedores

* TODO Mumble. El docker del servidor de VoIP de Software Libre
:PROPERTIES:
:TITLE: Mumble. El docker del servidor de VoIP de Software Libre.
:EXPORT_FILE_NAME: mumble-el-docker-del-servidor-de-voip-de-software-libre
:DESCRIPTION: No es la primera vez que os hablo de Mumble. Hace unos 9 meses cree una imagen para docker con la intención de instalar rápido sin problemas el servicio para
:EXPORT_DATE: 2020-06-01 19:45
:CATEGORY: docker
:TAG: voip
:IMAGE: ./images-blog/mumble.png
:END:

No es la primera vez que os hablo de Mumble. Hace unos 9 meses cree una imagen para docker con la intención de instalar rápido sin problemas el servicio para arquitectura arm y amd64.

Este contenedor parte de un Alpine Linux, así que es una imagen muy pequeña, tan solo ocupa 11.47Mb la versión para arm y 19.91Mb la de amd64.

#+HTML: <center>
[[./images-blog/mumble.png]]
#+HTML: </center>

Vamos a ver como instalarlo y configurarlo

** ARM, Raspberry Pi

#+BEGIN_SRC sh
docker run -d --name mumble -p 64738:64738  -p 64738:64738/udp ugeek/mumble:arm
#+END_SRC

docker-compose

#+BEGIN_SRC sh
version: '2'
services:
  mumble:
    container_name: mumble
    image: ugeek/mumble:arm
    ports:
      - 64738:64738/udp
      - 64738:64738
#+END_SRC

** amd64
#+BEGIN_SRC sh
docker run -d --name mumble -p 64738:64738  -p 64738:64738/udp ugeek/mumble:amd64
#+END_SRC

** Configuración
Para configurar el servicio, vamos a entrar dentro del contenedor
#+BEGIN_SRC
docker exec -i -t --user root mumble sh
#+END_SRC

Ahora vamos a poner una contraseña, para que solo aquellos que nosotros autoricemos, tengan acceso al servicio.

Utilizaremos vi para editar el archivo de configuración, ya que viene instalado por defecto
#+BEGIN_SRC
vi /config/mumble-server.ini
#+END_SRC

Buscaremos donde ponga:
#+BEGIN_SRC
# Password to join server.
serverpassword=contraseña
#+END_SRC

Y sustituimos *contraseña*, por la contraseña.

Restaura el contenedor
#+BEGIN_SRC
docker restart mumble
#+END_SRC

Ya puedes disfrutar de tu nuevo servicio de VoIP
* TODO Instalando docker-compose
:PROPERTIES:
:TITLE: Instalando docker-compose
:EXPORT_FILE_NAME: instalando-docker-compose
:DESCRIPTION: Docker-compose está en los repositorios oficiales de muchas distros, pero casi con toda seguridad, la versión que encontraremos en esta no será última y esto, dependiendo de la versión de
:EXPORT_DATE: 2020-06-04 20:05
:CATEGORY: docker
:TAG: docker-compose
:IMAGE: ./images-blog/docker.png
:END:


Docker-compose está en los repositorios oficiales de muchas distros, pero casi con toda seguridad, la versión que encontraremos en esta no será última y esto, dependiendo de la versión de docker-compose que queramos levantar, puede dar errores. Para evitar esto, lo ideal es tener la ultima versión.
#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

Vamos a instalar docker-compose a la última de un modo súper fácil en ubuntu, debian, Raspberry Pi OS,...

** Instalando
Si no tienes instalado pip, deberás instalarlo
#+BEGIN_SRC
sudo apt install python3-pip
#+END_SRC

Ahora vamos a instalar docker-compose
#+BEGIN_SRC
sudo pip3 install docker-compose
#+END_SRC
- [[https://pypi.org/project/docker-compose/][Fuente]]

** Versión
Vamos a verificar la versión de docker-compose
#+BEGIN_SRC
docker-compose -v
#+END_SRC
** Levantar un docker con docker-compose
Ahora cuando tenga un archivo *docker-compose.yml*, lo levantaré con:
#+BEGIN_SRC
docker-compose up -d
#+END_SRC


* TODO Instalar Node.js 12. Versión estable
:PROPERTIES:
:TITLE: Instalar Node.js 12. Versión estable
:EXPORT_FILE_NAME: instalar-node-js-12-version-estable
:DESCRIPTION: Necesitaba actualizar Node.js a partir de la versión 10 para poder utilizar joplin-cli.
:EXPORT_DATE: 2020-06-07 18:15
:CATEGORY: node
:TAG: joplin
:IMAGE: ./images-blog/node.png
:END:

Necesitaba actualizar Node.js a partir de la versión 10 para poder utilizar joplin-cli.

Utilizando el mismo script, podemos instalar la versión estable, hoy la versión 12 o la versión inestable, versión 14.
#+HTML: <center>
[[./images-blog/node.png]]
#+HTML: </center>

Si quieres cambiar la versión, solo tienes que cambiar el número *12*, por el número de versión que desees.

Vamos a actualizar la versión que tenemos en los repositorios a la versión *12.18*, que es la versión estable el día que estoy escribiendo este artículo.

*** Instalación

Instalamos curl si no lo tenemos instalado

#+BEGIN_SRC
sudo apt install curl
#+END_SRC

Descargamos y ejecutamos este script
#+BEGIN_SRC
curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
#+END_SRC

Instalamos nodejs
#+BEGIN_SRC
sudo apt install nodejs
#+END_SRC

Comprobar la versión
#+BEGIN_SRC
node -v
#+END_SRC

* TODO Sincronización con Rclone via SSH y SFTP
:PROPERTIES:
:TITLE: Sincronización con Rclone via SSH y SFTP
:EXPORT_FILE_NAME: sincronizacion-con-rclone-via-ssh-sftp
:DESCRIPTION: Estamos acostumbrados a conectarnos nubes públicas y privadas con rclone. Hoy vamos a conectarnos a un VPS o servidor remoto via SSH con SFTP.
:EXPORT_DATE: 2020-06-08 17:50
:CATEGORY: rclone
:TAG: ssh
:IMAGE: ./images-blog/rclone.png
:END:
Estamos acostumbrados a conectarnos nubes públicas y privadas con rclone. Hoy vamos a conectarnos a un VPS o servidor remoto via SSH con SFTP.

#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

** Archivo de configuración
Actualmente me conecto vía SSH sin necesidad de poner la contraseña, ya que en el servidor he añadido mi *id_rsa* pública.

Vamos a aprovechar esta llave pública para acceder con rclone.

Vamos a añadir en el archivo de configuración de *rclone.conf* en =/home/angel/.config/rclone/rclone.conf=

#+BEGIN_SRC
[servidor]
type = sftp
host = 192.168.1.100
user = ubuntu
port = 22
key_file = /home/angel/.ssh/id_rsa
#+END_SRC
Ahora vamos a probar listar los directorios de $HOME del servidor, para comprobar que todo funciona correctamente

#+BEGIN_SRC
rclone lsd servidor:/home/ubuntu/
#+END_SRC
* TODO Joplin Desktop, Joplin para Terminal y WebClipper
:PROPERTIES:
:TITLE: Joplin Desktop, Joplin para Terminal y WebClipper
:EXPORT_FILE_NAME: joplin-desktop-joplin-para-terminal-y-webclipper
:DESCRIPTION: Joplin junto al orgmode, se está convirtiendo en una aplicación imprescindible para mi. Me permite tener sincronizadas mis notas en todos mis dispositivos, gracias a mi servidor webdav.
:EXPORT_DATE: 2020-06-13 19:30 2021-02-02
:CATEGORY: joplin
:TAG: notas,terminal
:IMAGE: ./images-blog/joplin.png
:END:

Joplin junto al orgmode, se está convirtiendo en una aplicación imprescindible para mi. Me permite tener sincronizadas mis notas en todos mis dispositivos, gracias a mi servidor webdav.
#+HTML: <center height="250" width="250">
[[./images-blog/joplin.png]]
#+HTML: </center>

Voy a explicaros la instalación de algunos de sus clientes y conocer el funcionamiento de la versión de terminal.
** AppImage
Para instalar la versión de escritorio con AppImage.

- Podemos descargar la versión de escritorio [[https://github.com/laurent22/joplin/releases][desde su repositorio en GitHub]]
- Damos permisos de ejecución al archivo descargado =sudo chmod +x ./*.AppImage=
- Lanzamos el AppImage

En debian Buster, me da un problema al ejecurar el AppImage, ya que me dice que el sandbox no está bien configurado. Para poder arrancarlo utilizo:
#+begin_src
./Joplin-1.0.218.AppImage --no-sandbox
#+end_src

Para configurar correctamente el sandbox, ejecutaremos:

#+begin_src
sudo sysctl kernel.unprivileged_userns_clone=1
#+end_src

- [[https://github.com/ramboxapp/community-edition/issues/2481][Fuente]]

** Snap
Si tienes snap en tu sistema, es tan sencillo como:
#+BEGIN_SRC
sudo snap install joplin-james-carroll
#+END_SRC
- https://snapcraft.io/joplin-james-carroll
- https://joplinapp.org/#terminal-application

** WebClipper
Por si solo, el plugin no funciona. Necesita tener abierta la versión desktop de joplin, ya que esta utiliza el puerto *41184* para enviar el contenido del navegador.

Para habilitar que WebClipper y envíe el contenido de una web a joplin desktop, tenemos que ir *Herramientas/Opciones/Web Clipper* y habilitar el servicio.

Después, como no, tenemos que instalar la extensión para Firefox o Google Chrome.

** Control de versiones
Joplin ya permite el control de versiones de una nota. Esto quiere decir que podemos volver atrás en el tiempo, a una edición anterior. Esta opción actualmente solo está disponible en la versión desktop pulsando sobre la "i" de información de la nota o tarea.
** SubLibretas
También podemos crear sublibretas. Esta opción también a día de hoy, es exclusiva en la versión desktop. EL desarrollador ya ha comunicado que en breve estará en la versión mobile.

** Joplin para Terminal
Vamos a instalar la versión para utilizar Joplin desde la terminal.

*** Instalar una dependencia necesaria

#+BEGIN_SRC 
sudo apt install libsecret-1-dev
#+END_SRC


*** Descarga y actualiza Node / NPM 
#+BEGIN_SRC 
curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash
sudo apt install -y nodejs
#+END_SRC


*** Instalando Joplin-cli



Podemos instalar la versión de terminal en nuestro pc con arquitectura amd64 o en nuestra Raspberry Pi con arquitectura ARM.

#+BEGIN_SRC
NPM_CONFIG_PREFIX=~/.joplin-bin npm install -g joplin
#+END_SRC

Creamos un enlace, así en la terminal, con solo escribir joplin, nos abrirá joplin-cli.
#+BEGIN_SRC
sudo ln -s ~/.joplin-bin/bin/joplin /usr/bin/joplin
#+END_SRC

Resumido en un solo comando, para que copies y pegues en la terminal:

#+BEGIN_SRC 
NPM_CONFIG_PREFIX=~/.joplin-bin npm install -g joplin
sudo ln -s ~/.joplin-bin/bin/joplin /usr/bin/joplin
#+END_SRC

Ahora escribiendo **joplin** en tu terminal, se debería abrir.


*** Carpeta de configuración
Los archivos de configuración, pueden estar en la carpeta
#+BEGIN_SRC
~/.config/joplin
#+END_SRC

Carpeta donde están las imágenes
#+begin_src
~/.config/joplin/resources
#+end_src

*** Uso


La app de terminal es muy intuitiva. Aparecerán tres grandes columnas, con las libretas, notas y contenido de estas. Utilizaremos la tecla *TAB* para saltar de una columna a otra.

Para introducir un comando, tendremos que escribir *:* seguido del comando.

También permite el autocompletado mediante *TAB*. De manera que si escribimos /:sy/ y pulsamos *TAB*, auto escribirá *:sync*.

Para salir de la aplicación, lo haremos escribiendo =:exit= o pulsando *Ctrl+d*.

*** Algunos comandos útiles

#+BEGIN_SRC
:mknote "Título de Nota"   # Crear nota
:mn     "Título de Nota"   # Crear nota
:mktodo "Título de tarea"  # Crear tarea -> Pulsa la tecla *space*, para marcar la tarea como realizada
:mt     "Título de tarea"  # Crear tarea
:mkbook "Nombre Libreta"   # Crear una libreta
:mb     "Nombre Libreta"   # Crear una libreta
:ren $n "Nuevo nombre"     # Renombrar la nota en la que estás situado, con el nombre "Nuevo nombre"
:mv  $n "Tareas"           # Mover la nota en la que estás situado, a la libreta "Tareas"
:yn       cp $n
:dn       mv $n ""
:search                    # Buscar
:mv TAB                    # Mover una nota. Si pulsas TAB, nos aparecera todas las notas a seleccionar
:sync                      # Sincronizar con el servidor
:status                    # Ver estado. Número de notas, libretas,...
:config editor "nano"      # Cambiar editor por defecto
:help                      # Ayuda
:help all                  # Ayuda más completa
:help keymap               # Atajos
:help shortcuts
#+END_SRC

*** Atajos
#+begin_src
tm        # Ver metadata de una nota
tc        # Entrar y salir al modo consola
Enter     # Encima de una nota, editarla
suprimir  # Da la opción a borrar una nota, tarea, libreta
Backspace # Da la opción a borrar una nota, tarea, libreta
/         # Buscar
TAB       # Saltar entre columnas y autoescritura
Ctrl+d    # Salir
#+end_src

*** Personalizar atajos
Crea el siguiente archivo, si no lo tienes creado
#+begin_src
nano ~/.config/joplin/keymap.json
#+end_src

Añade el siguiente contenido
#+begin_src
[
{ "keys": [":"], "type": "function", "command": "enter_command_line_mode" },
{ "keys": ["TAB"], "type": "function", "command": "focus_next" },
{ "keys": ["SHIFT_TAB"], "type": "function", "command": "focus_previous" },
{ "keys": ["UP"], "type": "function", "command": "move_up" },
{ "keys": ["DOWN"], "type": "function", "command": "move_down" },
{ "keys": ["PAGE_UP"], "type": "function", "command": "page_up" },
{ "keys": ["PAGE_DOWN"], "type": "function", "command": "page_down" },
{ "keys": ["ENTER"], "type": "function", "command": "activate" },
{ "keys": ["DELETE", "BACKSPACE"], "type": "function", "command": "delete" },
{ "keys": [" "], "command": "todo toggle $n" },
{ "keys": ["tc"], "type": "function", "command": "toggle_console" },
{ "keys": ["tm"], "type": "function", "command": "toggle_metadata" },
{ "keys": ["/"], "type": "prompt", "command": "search """, "cursorPosition": -2 },
{ "keys": ["mn"], "type": "prompt", "command": "mknote """, "cursorPosition": -2 },
{ "keys": ["mt"], "type": "prompt", "command": "mktodo """, "cursorPosition": -2 },
{ "keys": ["mb"], "type": "prompt", "command": "mkbook """, "cursorPosition": -2 },
{ "keys": ["yn"], "type": "prompt", "command": "cp $n """, "cursorPosition": -2 },
{ "keys": ["dn"], "type": "prompt", "command": "mv $n """, "cursorPosition": -2 }
]
#+end_src

Sustituye o personaliza a tu gusto

*** Configuración para Webdav, Nexcloud, OwnCloud

Nubes disponibles:
2: File system
3: OneDrive
5: Nextcloud
6: WebDAV
7: Dropbox

Yo en mi caso, utilizaré mi servidor webdav, así que utilizaré el número 6.

#+BEGIN_SRC
:config sync.target 6
:config sync.6.path https://mi-url/joplin
:config sync.6.username USUARIO
:config sync.6.password CONTRASEÑA
#+END_SRC

*** Iniciar la Sincronizar
#+BEGIN_SRC
:sync
#+END_SRC

*** Cifrado extremo a extremo

Poner la contraseña
#+BEGIN_SRC
:e2ee decrypt
#+END_SRC
Introduzca la contraseña maestra:

*** Cambiar el editor

Cambiar el editor a emacs por defecto a:
#+BEGIN_SRC
:config editor "emacs -nw"
#+END_SRC

** Joplin modo shell
Los comandos son los mismos que la versión terminal, solo que el comando se ejecuta y nos devuelve el resultado.
Voy a resumir algunos de los comandos:
*** Varios
#+begin_src
joplin config editor                    # Muestra el editor que estamos utilizando
joplin config editor "gedit"            # Utilizar gedit como editor
joplin config dateFormat DD-MM-YYYY     # Cambiar formato de fecha
joplin mknote "nueva tarea"             # Crear la tarea llamada "nueva tarea"
joplin edit "nueva tarea"               # Editar la tarea
joplin cat "nueva tarea"                # Mostrar en terminal el contenido de la tarea
joplin cat -v "nueva tarea"             # Mostrar contenido y metadata de la tarea
joplin mkbook tareas                    # Crea la libreta tareas
joplin ls /                             # Listar libretas desde la raíz
joplin tag list                         # Listar etiquetas
joplin tag list "linux"                 # Listar notas con la etiqueta linux
joplin set fd297 titulo "nuevo titulo"  # Cambiar título de una nota
joplin use tareas                       # Situate dentro de la libreta tareas
joplin sync                             # Sincronizar todas las tareas
joplin import linux.md linux            # Importa un documento .md llamado linux en joplin con el título linux
joplin version                          # Versión de joplin

joplin export --note <node-id> --format md <output-dir>
#+end_src

- http://leetschau.github.io/joplin-notes.html

*** Listar
Listar la raíz de tu Joplin
#+begin_src
joplin ls /
#+end_src

Listar la raíz de tu Joplin con los id
#+begin_src
joplin ls / -l
#+end_src


Listar y mostrar los id de las notas:
#+BEGIN_SRC
joplin ls -l
#+END_SRC

*** Cambiar de libreta
#+begin_src
joplin use "nombre de libreta"
#+end_src

Ahora podemos listar las notas o tareas de esa libreta:
#+begin_src
joplin ls
#+end_src
*** Editar Nota o Tarea

Editar nota con id 073ac
#+begin_src
joplin edit 073ac
#+end_src

*** Ver nota
#+begin_src
joplin cat "nombre nota"
#+end_src

#+begin_src
joplin cat id
#+end_src

*** Marcar tarea como realizada o no realizada
#+begin_src
done "nombre tarea"
#+end_src

#+begin_src
undone "nombre tarea"
#+end_src

*** Exportar una nota
Listamos las notas en la ubicación que estamos
#+begin_src
joplin ls -l
#+end_src

Con cat seguido del nombre de la nota/tarea o el id, exportamos su contenido a el archivo llamado *nota.md*.
#+BEGIN_SRC
joplin cat id > nota.md
#+END_SRC

*** Ayuda
Ayuda simple
#+begin_src
joplin help
#+end_src

Ayuda completa
#+begin_src
joplin help all
#+end_src

Muestra de ayuda con todos los comandos
#+begin_src
attach <note> <file>

Adjuntar archivo a la nota.

cat <note>

Mostrar la nota dada.

-v, --verbose  Mostrar la información completa acerca de la nota.

config [name] [value]

Obtener o configurar un valor. Si no se provee el [valor], se mostrará el
valor de [nombre]. Si no se provee [nombre] ni [valor], se listará la
configuración actual.

-v, --verbose         También muestra variables ocultas o no configuradas.
--export              Writes all settings to STDOUT as JSON including
secure variables.
--import              Reads in JSON formatted settings from STDIN.
--import-file <file>  Reads in settings from <file>. <file> must contain
valid JSON.

Claves/valores posbiles:

sync.target                    Destino de sincronización.
El destino de la sincronización. Cada
destino de la sincronización puede tener
parámetros adicionales los cuales son
llamados como `sync.NUM.NAME` (todos abajo
documentados).
Tipo: Enumeración.
Posibles valores: 2 (File system), 3
(OneDrive), 5 (Nextcloud), 6 (WebDAV), 7
(Dropbox).
Por defecto: 7

sync.2.path                    Directorio con el que sincronizarse (ruta
completa).
Attention: If you change this location,
make sure you copy all your content to it
before syncing, otherwise all files will be
removed! See the FAQ for more details:
https://joplinapp.org/faq/
Tipo: string.

sync.5.path                    Servidor WebDAV de Nextcloud.
Attention: If you change this location,
make sure you copy all your content to it
before syncing, otherwise all files will be
removed! See the FAQ for more details:
https://joplinapp.org/faq/
Tipo: string.

sync.5.username                Usuario de Nextcloud.
Tipo: string.

sync.5.password                Contraseña de Nextcloud.
Tipo: string.

sync.6.path                    Servidor WebDAV.
Attention: If you change this location,
make sure you copy all your content to it
before syncing, otherwise all files will be
removed! See the FAQ for more details:
https://joplinapp.org/faq/
Tipo: string.

sync.6.username                Usuario de WebDAV.
Tipo: string.

sync.6.password                Contraseña de WebDAV.
Tipo: string.

sync.maxConcurrentConnections  Conexiones simultáneas máximas.
Tipo: int.
Por defecto: 5

locale                         Idioma.
Tipo: Enumeración.
Posibles valores: ar (Arabic (87%)), eu
(Basque (37%)), bs_BA (Bosnian (81%)),
bg_BG (Bulgarian (73%)), ca (Catalan
(58%)), hr_HR (Croatian (31%)), cs_CZ
(Czech (90%)), da_DK (Dansk (81%)), de_DE
(Deutsch (97%)), et_EE (Eesti Keel (72%)),
en_GB (English (UK) (100%)), en_US (English
(US) (100%)), es_ES (Español (90%)), eo
(Esperanto (41%)), fr_FR (Français (91%)),
gl_ES (Galician (47%)), it_IT (Italiano
(96%)), nl_BE (Nederlands (37%)), nl_NL
(Nederlands (92%)), nb_NO (Norwegian
(97%)), fa (Persian (36%)), pl_PL (Polski
(84%)), pt_PT (Português (98%)), pt_BR
(Português (Brasil) (98%)), ro (Română
(37%)), sl_SI (Slovenian (47%)), sv
(Svenska (78%)), th_TH (Thai (58%)), vi
(Tiếng Việt (94%)), tr_TR (Türkçe (100%)),
el_GR (Ελληνικά (89%)), ru_RU (Русский
(97%)), sr_RS (српски језик (78%)), zh_CN
(中文 (简体) (97%)), zh_TW (中文 (繁體) (98%)),
ja_JP (日本語 (100%)), ko (한국어 (95%)).
Por defecto: "en_GB"

dateFormat                     Formato de fecha.
Tipo: Enumeración.
Posibles valores: DD/MM/YYYY (30/01/2017),
DD/MM/YY (30/01/17), MM/DD/YYYY
(01/30/2017), MM/DD/YY (01/30/17),
YYYY-MM-DD (2017-01-30), DD.MM.YYYY
(30.01.2017), YYYY.MM.DD (2017.01.30).
Por defecto: "DD/MM/YYYY"

timeFormat                     Formato de hora.
Tipo: Enumeración.
Posibles valores: HH:mm (20:30), h:mm A
(8:30 PM).
Por defecto: "HH:mm"

uncompletedTodosOnTop          Mostrar tareas incompletas al inicio de las
listas.
Tipo: bool.
Por defecto: true

showCompletedTodos             Mostrar tareas completadas.
Tipo: bool.
Por defecto: true

notes.sortOrder.field          Ordenar notas por.
Tipo: Enumeración.
Posibles valores: user_updated_time (Fecha
de actualización), user_created_time (Fecha
de creación), title (Título).
Por defecto: "user_updated_time"

notes.sortOrder.reverse        Invierte el orden.
Tipo: bool.
Por defecto: true

folders.sortOrder.field        Ordenar libretas por.
Tipo: Enumeración.
Posibles valores: title (Título),
last_note_user_updated_time (Fecha de
actualización).
Por defecto: "title"

folders.sortOrder.reverse      Invierte el orden.
Tipo: bool.
Por defecto: false

trackLocation                  Guardar geolocalización en las notas.
Tipo: bool.
Por defecto: true

sync.interval                  Intervalo de sincronización.
Tipo: Enumeración.
Posibles valores: 0 (Deshabilitado), 300 (5
minutos), 600 (10 minutos), 1800 (30
minutos), 3600 (1 hora), 43200 (12 horas),
86400 (24 horas).
Por defecto: 300

editor                         Editor de texto.
El comando del editor (puede incluir
argumentos) que se utilizará para abrir una
nota. Si no se provee ninguno se intentará
auto detectar el editor por defecto.
Tipo: string.

net.customCertificates         Certificados TLS personalizados.
Lista de rutas de los directorios de dónde
cargar los certificados separados por
comas, o la ruta individual de los
certificados. Por ejemplo: /mi/cert_dir,
/otro/personalizado.pem. Tenga en cuenta
que si realiza cambios en la configuración
de los certificados debe guardar los
cambios antes de pulsar en «Comprobar la
configuración de sincronización».
Tipo: string.

net.ignoreTlsErrors            Ignorar errores en certificados TLS.
Tipo: bool.
Por defecto: false

sync.wipeOutFailSafe           Fail-safe.
A prueba de fallos: No borre los datos
locales cuando el objetivo de
sincronización esté vacío (a menudo como
resultado de una configuración errónea o de
un error).
Tipo: bool.
Por defecto: true


revisionService.enabled        Habilitar historial de notas.
Tipo: bool.
Por defecto: true

revisionService.ttlDays        Mantener historial de la nota durante.
Tipo: int.
Por defecto: 90

layout.folderList.factor       Notebook list growth factor.
The factor property sets how the item will
grow or shrink to fit the available space
in its container with respect to the other
items. Thus an item with a factor of 2 will
take twice as much space as an item with a
factor of 1.Restart app to see changes.
Tipo: int.
Por defecto: 1

layout.noteList.factor         Note list growth factor.
The factor property sets how the item will
grow or shrink to fit the available space
in its container with respect to the other
items. Thus an item with a factor of 2 will
take twice as much space as an item with a
factor of 1.Restart app to see changes.
Tipo: int.
Por defecto: 1

layout.note.factor             Note area growth factor.
The factor property sets how the item will
grow or shrink to fit the available space
in its container with respect to the other
items. Thus an item with a factor of 2 will
take twice as much space as an item with a
factor of 1.Restart app to see changes.
Tipo: int.
Por defecto: 2

cp <note> [notebook]

Duplica las notas que coincidan con <note> en la libreta. Si no se
especifica una libreta la nota se duplica en la libreta actual.

done <note>

Marca una tarea como hecha.

e2ee <command> [path]

Gestiona la configuración E2EE. Los comandos disponibles son: `enable`,
`disable`, `decrypt`, `status`, `decrypt-file` y `target-status`.

-p, --password <password>  Use this password as master password (For
security reasons, it is not recommended to use
this option).
-v, --verbose              More verbose output for the `target-status`
command
-o, --output <directory>   Output directory
--retry-failed-items       Applies to `decrypt` command - retries
decrypting items that previously could not be
decrypted.

edit <note>

Editar una nota.

export <path>

Exporta datos de Joplin al directorio indicado. Por defecto, se exportará
la base de datos completa incluyendo libretas, notas, etiquetas y
recursos.

--format <format>      Formato de destino: jex (Archivo de exportación de
Joplin), raw (Directorio para exportar de Joplin),
json (Directorio para exportar JSON), md
(Markdown), html (Archivo HTML), html (Directorio
HTML)
--note <note>          Exporta únicamente la nota indicada.
--notebook <notebook>  Exporta únicamente la libreta indicada.

geoloc <note>

Muestra la URL de la geolocalización de la nota.

help [command]

Muestra información de uso.

import <path> [notebook]

Importa los datos en Joplin.

--format <format>  Formato de origen: auto, jex, md, raw, enex, enex
-f, --force        No requiere confirmación.

ls [note-pattern]

Muestra las notas en la libreta actual. Usa `ls /` para mostrar la lista
de libretas.

-n, --limit <num>      Muestra las primeras <num> notas.
-s, --sort <field>     Ordena los elementos por campo ( ej. title,
updated_time, created_time).
-r, --reverse          Invierte el orden.
-t, --type <type>      Muestra únicamente los elementos de los tipos
especificados. Pueden ser `n` para notas, `t` para
tareas, o `nt` para libretas y tareas (ej. `-tt`
mostrará unicamente las tareas, mientras `-ttd`
mostrará notas y tareas).
-f, --format <format>  Puede ser «text» o «json»
-l, --long             Usar formato largo de lista. El formato es ID,
NOTE_COUNT ( para libretas), DATE,TODO_CHECKED (
para tareas), TITLE

mkbook <new-notebook>

Crea una nueva libreta.

mknote <new-note>

Crea una nueva nota.

mktodo <new-todo>

Crea una nueva lista de tareas.

mv <note> [notebook]

Mueve las notas que coincidan con <note> a la [libreta].

ren <item> <name>

Renombra el elemento dado <item> (nota o libreta) a <name>.

rmbook <notebook>

Elimina la libreta dada.

-f, --force  Elimina una libreta sin pedir confirmación.

rmnote <note-pattern>

Elimina las notas que coinciden con <note-pattern>.

-f, --force  Elimina las notas sin pedir confirmación.

server <command>

Inicie, pare o compruebe el servidor API. Para especificar el puerto que
debe ejecutarse use api.port como variable en la configuración. Los
comandos son (start|stop|status). This is an experimental feature - use at
your own risks! It is recommended that the server runs off its own
separate profile so that no two CLI instances access that profile at the
same time. Use --profile to specify the profile path.

set <note> <name> [value]

Asigna el valor [value] a la propiedad <name> de la nota indicada <note>.
Propiedades disponibles:

parent_id (text), title (text), body (text), created_time (int),
updated_time (int), is_conflict (int), latitude (numeric), longitude
(numeric), altitude (numeric), author (text), source_url (text), is_todo
(int), todo_due (int), todo_completed (int), source (text),
source_application (text), application_data (text), order (int),
user_created_time (int), user_updated_time (int), encryption_cipher_text
(text), encryption_applied (int), markup_language (int), is_shared (int)

status

Muestra un resumen acerca de las notas y las libretas.

sync

Sincroniza con el almacenamiento remoto.

--target <target>  Sincroniza con el destino indicado (por defecto al
valor de configuración sync.target)

tag <tag-command> [tag] [note]

<tag-command> puede ser «add», «remove», «list», o «notetags» para asignar
o eliminar [etiqueta] de [nota], o para listar las notas asociadas con
[etiqueta], o para listar las etiquetas asociadas con [nota]. El comando
`tag list` puede ser usado para listar todas las etiquetas (usa -l para la
opción larga).

-l, --long  Usar formato largo de lista. El formato es ID, NOTE_COUNT (
para libretas), DATE,TODO_CHECKED ( para tareas), TITLE

todo <todo-command> <note-pattern>

<todo-command> puede ser «toggle» o «clear». Usa «toggle» para cambiar la
tarea dada entre estado completado y sin completar. (Si el objetivo es una
nota regular se convertirá en una tarea). Usa «clear» para convertir la
tarea a una nota regular.

undone <note>

Marca una tarea como no completada.

use <notebook>

Cambia una [libreta] - todas las demás operaciones se realizan en ésta
libreta.

version

Muestra información de la versión
#+end_src

*** Fuentes

- https://joplinapp.org/terminal/
- https://www.npmjs.com/package/joplin

** Fuentes
- https://joplinapp.org/
- https://appimage.github.io/Joplin/
- https://discourse.joplinapp.org/ (Foro)
**** notas Instalando Node
En la versión anterior de **joplin** para cli, teniamos suficiente instalando **nodejs** y **npm** desde repositorios, ahora es necesario actualizar para solucionar el problema.

#+BEGIN_SRC
sudo apt update
sudo apt install nodejs
#+END_SRC

Ahora npm
#+BEGIN_SRC
sudo apt install npm
#+END_SRC


* TODO Habilitar el modo-org en Emacs, cuando abras un archivo txt o markdown
:PROPERTIES:
:TITLE: Habilitar el modo-org en Emacs, cuando abras un archivo txt o markdown
:EXPORT_FILE_NAME: habilitar-el-modo-org-en-emacs-cuando-abras-un-archivo-txt-o-markdown
:DESCRIPTION: Es posible que te interese el habilitar el modo org cuando abras un archivos .txt o markdown.
:EXPORT_DATE: 2020-06-16 17:30
:CATEGORY: emacs
:TAG: joplin,simplenote
:IMAGE: ./images-blog/emacs.png
:END:

Es posible que te interese el habilitar el modo org cuando abras un archivos .txt o markdown.
#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

Por ejemplo para sincronizar notas abiertas con emacs, utilizando aplicaciones como simplenote o Joplin.

De esa manera, podemos utilizar el modo org con estás aplicaciones de notas

** Cambiando el modo al abrir markdown
Vamos a añadir a nuestro archivo de configuración init.el,  el siguiente código, para que cada vez que abramos un archivo .md, se habilite el modo org.

#+begin_src
(add-to-list 'auto-mode-alist '("\.md\'" . org-mode))
#+end_src

Hacer lo propio también con los archivos extensión .txt
#+begin_src
(add-to-list 'auto-mode-alist '("\.md\'" . org-mode))
(add-to-list 'auto-mode-alist '("\.txt\'" . org-mode))
#+end_src



** Estructura de una nota con Joplin
Para poder utilizar el orgmode con Joplin y no de error en la sincronización, tendremos escribir el título en la parte superior de la nota en texto plano y *dejar un espacio en blanco* antes de escribir el primer asterisco de la sintaxis orgmode.
** Estructura con SimpleNote
Igual que con Joplin, la primera línea será el título de la nota, así que para que no salga el asterisco de la primera cabecera de la sintaxis orgmode,
lo escribiremos en texto plano. El resto del archivo, puede ser orgmode sin problemas.

La ventaja de SimpleNote, es el poder editar la nota varios usuarios.

Recuerda que para hacer esto tenemos que utilizar Emacs con el paquete  *simplenote2*.
** Fuentes
- https://www.emacswiki.org/emacs/AutoModeAlist

* TODO Cliente de escritorio para editar archivos de una nube privada (WebDav, Nextcloud,...) o pública (Drive, Dropbox, OneDrive...) con rclone
:PROPERTIES:
:TITLE: Cliente de escritorio para editar archivos de una nube privada (WebDav, Nextcloud,...) o pública (Drive, Dropbox, OneDrive...) con rclone
:EXPORT_FILE_NAME: cliente-de-escritorio-para-editar-archivos-de-una-nube-privada-(webdav-nextcloud--)-o-publica-(drive-dropbox-onedrive--)-con-rclone
:DESCRIPTION: Muchos me habéis preguntado como edito con emacs mis archivos orgmode que tengo en mi nube webdav, así como mi archivo todo.txt.
:EXPORT_DATE: 2020-06-22 22:22
:CATEGORY: rclone
:TAG: webdav,nextcloud,dropbox,nube,ssh
:IMAGE: ./images-blog/rclone.png
:END:

Muchos me habéis preguntado como edito con emacs mis archivos orgmode que tengo en mi nube webdav, así como mi archivo todo.txt.

Para ello, aunque existe otros clientes webdav, me ha parecido más simple y eficaz utilizar rclone.

Esto podremos hacerlo con cualquier nube pública, privada, como Webdav, Nextcloud, Dropbox, Google Drive, OneDrive,... SSH, SFTP,... vamos, todas las opciones disponibles con Rclone.
#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

Incluso, una opción interesante, cifrar el contenido de una carpeta local con rclone, sincronizar esta con Syncthing y montarla con rclone en otro pc o servidor.

Voy a explicarlo paso a paso.

Para entender más en profundidad como montar una nube con rclone, recomiendo [[https://ugeek.github.io/blog/post/2019-07-03-dale-almacenamiento-ilimitado-a-tu-raspberry-servidor-o-pc-con-rclone.html][este artículo que hice profundizando sobre el tema]].

** Crear el directorio donde montaremos el contenido
Voy a crear la carpeta donde montaré mis archivos *orgmode*. La llamaré *org*.

#+begin_example
mkdir ~/org
#+end_example

** Descomenta --allow-others
Descomenta la línea --allow-others, para permitir a usuarios no root, montar unidades

#+begin_example
sudo nano /etc/fuse.conf
#+end_example

Descomenta --allow-others

#+begin_example
# Allow non-root users to specify the allow_other or allow_root mount options.
--allow-others
#+end_example

Reinicia

** Montando la nube
Tan sencillo como utilizar =rclone mount=.

#+begin_example
rclone mount drive:org ~/org
#+end_example

Para enviar el comando a segundo plano y siempre corriendo, podemos añadir al final de esta línea *&*.

Esto puede dar una serie de lecturas en la terminal, que solucionaremos tal como explico en el automontado. El automontado es con cron, pero ese mismo comando, puedes ejecutarlo en la terminal.

** Automontando al inicio de sesión del sistema operativo
Para automontar la nube al inicio de Debian, Ubuntu,... podemos hacerlo de varias maneras.

Voy a utilizar el método más sencillo que he utilizado, con cron.

Abrimos cron desde la sesión del usuario
#+begin_example
crontab -e
#+end_example

Añadímos la siguiente línea

#+begin_example
@reboot ( sleep 25 && nohup rclone mount drive:org /home/angel/org --vfs-cache-mode full -v --allow-other  2>/dev/null & )
#+end_example

Este comando en crontab, indica que cada vez que iniciamos el sistema operativo, con =@reboot=, esperará 25 segundos y montará la nube que tengo en rclone con el nombre =drive:org=, en la carpeta =~/org=.


*nohup* y *2>/dev/null*, envía a esta posición de memoria el resultado que muestra la terminal, una posición de memoria que tiene nuestro sistema operativo precisamente para no mostrar nada en terminal.

*&*, dejará corriendo el comando indefinidamente, a no ser que lo detengamos nosotros.

*--vfs-cache-mode full*, activa la caché de lectura y escritura

*--allow-other,* permite a otros usuarios que se conecten a este directorio

** Conclusión
Así es como monto mi nube webdav en mi escritorio para editar mis archivos orgmode. Cada vez que inicio el sistema operativo, siempre está disponible ahí mi nube.

También podemos hacer lo mismo, pero en lugar de utilizar cron, podemos crear un servicio, pero esto lo dejo para otro artículo.

* TODO Informacion de tu sistema, pc, servidor,... con neofetch
:PROPERTIES:
:TITLE: Informacion de tu sistema, pc, servidor,... con neofetch
:EXPORT_FILE_NAME: informacion-de-tu-sistema-pc-servidor-con-neofetch
:DESCRIPTION: Neofetch es una aplicación para terminal desarrollada en bash, que muestra información del sistema, pc, servidor, etc...
:EXPORT_DATE: 2020-06-30 20:15
:CATEGORY: bash
:TAG: informacion
:IMAGE: ./images-blog/neofetch.png
:END:
Neofetch es una aplicación para terminal desarrollada en bash, que muestra información del sistema, pc, servidor, etc...
#+HTML: <center>
[[./images-blog/neofetch.png]]
#+HTML: </center>

Ha diferentes opciones de personalización, mediante el archivo de configuración. Vamos a ver como se instala y configura.

** Instalación
En debian, ubuntu, raspberry os,...
#+begin_src
sudo apt install neofetch
#+end_src

** Iniciar
Para iniciar la aplicación, tan simple como:
#+begin_src
neofetch
#+end_src

De forma automática, creará un nuevo archivo de configuración.

#+begin_src
nano ~/.config/neofetch/config.conf
#+end_src

Aquí podemos añadir que aparezca más información como nuestra ip pública, privada, usuario,...

Si una vez configurado, quieres que te aparezca neofetch por defecto, sin hacer uso del archivo de configuración, ejecutaremos:
#+begin_src
neofetch  --config noney
#+end_src

O especificar una ruta por defecto del archivo de configuración
#+begin_src
neofetch --config ~/dotfile/neofetch/config.conf
#+end_src

* TODO Listar paquetes instalados y hacer un poco de limpieza
:PROPERTIES:
:TITLE: Listar paquetes instalados y hacer un poco de limpieza
:EXPORT_FILE_NAME: listar-paquetes-instalados-y-hacer-un-poco-de-limpieza
:DESCRIPTION: Ha llegado el momento de hacer limpieza. Vamos a listar todos los paquetes que hay instalados en nuestra distro y desinstalar aquellos que ya no utilizamos.
:EXPORT_DATE: 2020-07-02 19:50
:CATEGORY: paquetes
:TAG: apt
:IMAGE: ./images-blog/bash.png
:END:

Ha llegado el momento de hacer limpieza. Vamos a listar todos los paquetes que hay instalados en nuestra distro y desinstalar aquellos que ya no utilizamos.

Pasado un largo tiempo, de tanto instalar programas, ya no recuerdo ni lo que tengo instalado. Este método me ayuda a dejar mi sistema operativo más limpio y optimizado.
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

*Recuerda desinstalar solo aquellos paquetes que conoces*. Por tu seguridad, haz una copia en un archivo de texto con el nombre de todos los paquetes que tienes antes de desinstalarlos.

Desinstalar paquetes que no conozcas, puede provocar que tu sistema operativo no funcione correctamente o dejen de funcionar cosas como el Wifi, Bluetooth, etc...

** Listar todos los paquetes instalado
Vamos a ver todos los paquetes instalados

#+begin_src
dpkg --get-selections
#+end_src

Buscar un paquete filtrando por nombre

#+begin_src
dpkg --get-selections | grep syncthing
#+end_src

** Hacer una copia de todos los paquetes instalados en un archivo de texto plano, .txt.
Esto es ideal, para si eliminas algún paquete que pueda hacer que algo no funcione, refrescarte la mente para volver a instalarlo

#+begin_src
dpkg --get-selections > ~/paquetes_instalados.txt
#+end_src


* TODO FileRun. Un Nextcloud-Owncloud más ligero para almacenar tus archivos
:PROPERTIES:
:TITLE: FileRun. Un Nextcloud-Owncloud más ligero para almacenar tus archivos
:EXPORT_FILE_NAME: filerun-un-nextcloud-owncloud-mas-ligero-para-almacenar-tus-archivos
:DESCRIPTION: Lo que apareció como un enlace más, casi sin importancia en el grupo de uGeek en Telegram, enlace publicado por José Jiménez, se va a convertir en uno de mis
:EXPORT_DATE: 2020-07-02 22:02
:CATEGORY: nube
:TAG: nextcloud,owncloud
:IMAGE: ./images-blog/filerun.png
:END:

Lo que apareció como un enlace más, casi sin importancia en el grupo de uGeek en Telegram, enlace publicado por Hugo, @telepredicador en Telegram, se va a convertir en uno de mis servicios imprescindibles en el día a día.

Lo mejor que tiene Nextcloud respecto a la sincronización de archivos, lo tiene FileRun.

[[https://demo.filerun.co/?username=admin&password=admin][Esta es una demo, para que veas el funcionamiento]].

#+HTML: <center>
[[./images-blog/filerun.png]]
#+HTML: </center>

FileRun es muchísimo más ligero que Nextcloud o nubes públicas como Google Drive, Dropbox,... pero respecto a estas últimas, con la ventaja además de tener todos los archivos tú.

Al final, es como instalar un servidor webdav, pero con interfaz web de administración.

Tener una página web de administración, permite más opciones que un servidor WebDav. Estás son algunas de las características que incluye FileRun.

- Control de versiones de archivos
- Compartir directorios o archivos con otros usuarios de la misma nube, pudiendo editarlos y trabajar en equipo.
- Compartir archivos de forma pública sin necesidad de tener cuenta de usuario.
- Previsualización y edición de archivos de texto plano, imágenes, hojas de cálculo, geolocalización, etcétera...
- Poder utilizar las aplicaciones de Nextcloud, Owncloud tanto de escritorio cómo dispositivo móvil. (Utiliza la API Nextcloud)

Permite separar los archivos en tres grupos.

- Fotos. Gracias a la aplicación móvil de Nextcloud, puedo tener un backup clasificado de mis fotos en FileRun, del mismo modo que lo harías con Nextcloud. FileRun las clasificará también por fecha, tag, últimas fotos,...

- Música. Los archivos MP3 que estén dentro de tu nube FileRun, serán clasificados por álbum, autor,...

- Colecciones. Agrupar los archivos en colecciones personalizadas de la misma temática.

- Estado. Podemos etiquetar los archivos o carpetas con una etiqueta, aplicandole un estado.


También permite una búsqueda de archivos avanzada.

Actualmente tengo en mi escritorio y dispositivo móvil, la aplicación de Nextcloud para la subida y bajada de archivos, así como la sincronización bidireccional en mi escritorio, todo ello vinculada a FileRun.

Gracias al servicio WebDav qué incluye FileRun, podrás utilizar aplicaciones de notas como Joplin, Orgzly o el todo.txt con SimpleTask.

La gran diferencia respecto a Nextcloud - OwnCloud, es que *no es Software Libre* y solo permite 3 usuarios en el servidor. Si quieres ampliar en números de usuarios, tendrás que pagar la licencia.

** Docker Compose
Vamos a utilizar docker compose para levantar los dos contenedores tal como explica en la documentación.

Lo he montado tanto en mi servidor, vps y Raspberry a la primera sin problemas.

Copia el los docker-compose.yml en una carpeta y levántalos con:
#+begin_src bash
docker-compose up -d
#+end_src

** Docker amd64

#+BEGIN_SRC sh
version: '2'

services:
  db:
    image: mariadb:10.1
    environment:
      MYSQL_ROOT_PASSWORD: your_mysql_root_password
      MYSQL_USER: your_filerun_username
      MYSQL_PASSWORD: your_filerun_password
      MYSQL_DATABASE: your_filerun_database
    volumes:
      - $HOME/docker/filerun/db:/var/lib/mysql

  web:
    image: afian/filerun
    environment:
      FR_DB_HOST: db
      FR_DB_PORT: 3306
      FR_DB_NAME: your_filerun_database
      FR_DB_USER: your_filerun_username
      FR_DB_PASS: your_filerun_password
      APACHE_RUN_USER: www-data
      APACHE_RUN_USER_ID: 33
      APACHE_RUN_GROUP: www-data
      APACHE_RUN_GROUP_ID: 33
    depends_on:
      - db
    links:
      - db:db
    ports:
      - "80:80"
    volumes:
      - $HOME/docker/filerun/html:/var/www/html
      - $HOME/docker/filerun/user-files:/user-files
#+END_SRC


- https://docs.filerun.com/docker
** Docker arm o Raspberry Pi

#+BEGIN_SRC sh 
version: '2'

services:
  db:
    image: jsurf/rpi-mariadb
    environment:
      MYSQL_ROOT_PASSWORD: your_mysql_root_password
      MYSQL_USER: your_mysql_username
      MYSQL_PASSWORD: your_mysql_password
      MYSQL_DATABASE: your_mysql_database
      PUID: 1000
      PGID: 1000
      TZ: Europe/London
    volumes:
      - $HOME/docker/filerun/db:/var/lib/mysql

  web:
    image: afian/filerun:arm32v7
    environment:
      FR_DB_HOST: db
      FR_DB_PORT: 3306
      FR_DB_NAME: your_mysql_database
      FR_DB_USER: your_mysql_username
      FR_DB_PASS: your_mysql_password
      APACHE_RUN_USER: pi
      APACHE_RUN_USER_ID: 1000
      APACHE_RUN_GROUP: pi
      APACHE_RUN_GROUP_ID: 1000
    depends_on:
      - db
    links:
      - db:db
    ports:
      - "80:80"
    volumes:
      - $HOME/docker/filerun/html:/var/www/html
      - $HOME/docker/filerun/user-files:/user-files
#+END_SRC

- https://docs.filerun.com/docker-arm (Raspberry)

** Docker Traefik
Yo lo tengo montado traefik en una red llamada *web*. Sustituye el dominio duckdns por el tuyo.
#+begin_src bash sh
version: '3'

db:
image: mariadb:10.1
environment:
MYSQL_ROOT_PASSWORD: your_mysql_root_password
MYSQL_USER: your_filerun_username
MYSQL_PASSWORD: your_filerun_password
MYSQL_DATABASE: your_filerun_database
volumes:
- $HOME/docker/filerun/db:/var/lib/mysql
networks:
- web

web:
image: afian/filerun
container_name: filerun
restart: unless-stopped
environment:
FR_DB_HOST: db
FR_DB_PORT: 3306
FR_DB_NAME: your_filerun_database
FR_DB_USER: your_filerun_username
FR_DB_PASS: your_filerun_password
APACHE_RUN_USER: www-data
APACHE_RUN_USER_ID: 33
APACHE_RUN_GROUP: www-data
APACHE_RUN_GROUP_ID: 33
depends_on:
- db
links:
- db:db
ports:
- "800:80"
volumes:
- $HOME/docker/filerun/html:/var/www/html
- $HOME/docker/filerun/user-files:/user-files
networks:
- web
labels:
- traefik.backend=filerun
- traefik.frontend.rule=Host:dominio.duckdns.org
- traefik.docker.network=web
- traefik.port=80
- traefik.enable=true

networks:
web:
external: true
#+end_src

** Iniciando
La primera vez que iniciamos FileRun, tenemos que introducir el usuario y contraseña por defecto (*superuser*).

Recuerda sustituirlo una vez hayas entrado en la sesión, por el usuario y contraseña que desees.

- usuario:      superuser
- contraseña :  superuser
** Conexión webdav
Para conectarte con cualquier cliente *webdav*, tenemos que introducir el siguiente tipo de url:

#+begin_src
https://misitio.filerun.com/dav.php/
#+end_src

** Licencia
Puedes ver los precios para obtener la licencia en https://filerun.com/enterprise

** Fuentes
- https://filerun.com
- Documentación: https://docs.filerun.com/Welcome
* TODO FileRun. Cambiando el idioma por defecto
:PROPERTIES:
:TITLE: FileRun. Cambiando el idioma por defecto
:EXPORT_FILE_NAME: filerun-cambiando-el-idioma-por-defecto
:DESCRIPTION: Por defecto, el docker de FileRun viene en inglés, pero si deseas cambiarlo a castellano o cualquier otro idioma, puedes hacerlo gracias a las traducciones disponibles en [[https://github.com/filerun/translations][uno de los
:EXPORT_DATE: 2020-07-06 20:30
:CATEGORY: filerun
:TAG: nube
:IMAGE: ./images-blog/filerun.png
:END:

Por defecto, el docker de FileRun viene en inglés, pero si deseas cambiarlo a castellano o cualquier otro idioma, puedes hacerlo gracias a las traducciones disponibles en [[https://github.com/filerun/translations][uno de los repositorios de FileRun en GitHub]].

#+HTML: <center>
[[./images-blog/filerun.png]]
#+HTML: </center>

Si copiaste la ubicación del docker-compose que hice en el artículo de FileRun, es tan sencillo como ir al directorio donde están las traducciones:

#+begin_example bash
~/docker/filerun/html/system/data/translations
#+end_example

Por defecto, el único archivo que viene es *english.php*. Yo lo que hice fué moverlo de directorio y borrar el directorio *translation*.

Después, cloné el repositorio con las traducciones en todos los idiomas:

#+begin_example
cp ~/docker/filerun/html/system/data/translations/english.php ~/
rm -Rf ~/docker/filerun/html/system/data/translations
git clone https://github.com/filerun/translations.git ~/docker/filerun/html/system/data/
mv ~/english.php ~/docker/filerun/html/system/data/translations
#+end_example

Ahora al iniciar FileRun, te permite cambiar entre todos los idiomas disponibles.

Si quieres que FileRun siempre esté en un idioma en concreto, tendrás que seleccionar el idioma que desees en el apartado de configuración.

Hay otra opción más sencilla, descargar el archivo *.php* con el idioma que deseeas del repositorio en GitHub, accedes al *Panel Control* y seleccionar *Opciones*.

Le damos a *Cargar fichero de idioma* y guardamos.

- https://github.com/filerun
- https://github.com/filerun/translations



* TODO FileRun. Utilizando tu hora local
:PROPERTIES:
:TITLE: FileRun. Utilizando tu hora local
:EXPORT_FILE_NAME: filerun-utilizando-tu-hora-local
:DESCRIPTION: Por defecto, FileRun no lleva la hora local del lugar donde estás situado. Vamos a crear un archivo *config.php*, para que coincida la hora de sincronización o modificación de archivos
:EXPORT_DATE: 2020-07-07 17:55
:CATEGORY: filerun
:TAG: nube,nextcloud
:IMAGE: ./images-blog/filerun.png
:END:

Por defecto, FileRun no lleva la hora local del lugar donde estás situado. Vamos a crear un archivo *config.php*, para que coincida la hora de sincronización o modificación de archivos con tu hora local.
#+HTML: <center>
[[./images-blog/filerun.png]]
#+HTML: </center>

Modifica o crea un nuevo archivo *config.php*

#+begin_src
~/docker/filerun/html/customizables/config.php
#+end_src

Añade el siguiente contenido, con tu zona horaria.
#+begin_example
<?php
date_default_timezone_set("Europe/Madrid");
#+end_example

Ahora FileRun te mostrará la fecha correcta en tus archivos.

* TODO Compilar Emacs 27.1 para Ubuntu, Debian, Raspbian y derivadas
:PROPERTIES:
:TITLE: Compilar Emacs 27.1 para Ubuntu, Debian, Raspbian y derivadas
:EXPORT_FILE_NAME: compilando-emacs-27-ubuntu-debian-raspbian
:DESCRIPTION: En el Artículo anterior compilamos Nano y ahora toca el turno de Emacs. Los que utilizamos Debian, Ubuntu, Raspbian... tenemos el problema que en los repositorios oficiales, no encontramos nunca
:EXPORT_DATE: 2020-08-12 13:15
:CATEGORY: emacs
:TAG: bash,zsh,compilar
:IMAGE: ./images-blog/emacs.png
:END:


Ya tenemos aquí la versión 27.1 de Emacs llena de novedades. 

Vamos a compilar y tener esta última versión estable en Debian, Ubuntu, Raspbian y derivadas 

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>


** Dependencias necesarias
Instalamos las siguientes dependencias
#+begin_src 
sudo apt-get install build-essential texinfo libx11-dev libxpm-dev libjpeg-dev libpng-dev libgif-dev libtiff-dev libgtk2.0-dev libncurses-dev libxpm-dev automake autoconf
#+end_src
** Descargamos la versión 27.1
Descargamos la última versión de Emacs
#+BEGIN_SRC 
wget https://ftp.gnu.org/gnu/emacs/emacs-27.1.tar.xz
#+END_SRC
Descomprimimos y accedemos a la carpeta
#+BEGIN_SRC 
tar xfv emacs-27.1.tar.xz
cd emacs-27.1
#+END_SRC

** Comenzamos la Compilación

*Accedemos como usuario root*
#+BEGIN_SRC 
su root
#+END_SRC

Ejecutamos los siguientes comandos

#+begin_src
./configure --with-gnutls=no --prefix=/usr --localstatedir=/var &&  make
#+end_src

Compilamos
#+BEGIN_SRC 
make install &&
chown -v -R root:root /usr/share/emacs/27.1 &&
rm -vf /usr/lib/systemd/user/emacs.service
#+END_SRC

** Comprobando la version 

#+BEGIN_SRC 
M-x emacs-version
#+END_SRC


** Conclusión
Ahora toca disfrutar de la última versión de Emacs!!!
* TODO Procesos que consumen más CPU y RAM en Linux
:PROPERTIES:
:TITLE: Procesos que consumen más CPU y RAM en Linux
:EXPORT_FILE_NAME: procesos-que-consumen-mas-cpu-y-ram-en-linux
:DESCRIPTION: Hoy el script que tengo ejecutando en mi Raspberry, para comprobar la temperatura, me ha enviado un mensaje de alta temperatura
:EXPORT_DATE: 2020-08-14 22:10
:CATEGORY: bash
:TAG: ram,cpu,zsh
:IMAGE: ./images-blog/bash.png
:END:


Hoy el script que tengo ejecutando en mi Raspberry, para comprobar la temperatura, me ha enviado un mensaje de alta temperatura
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Ha sido por la transcodificación de un contenido multimedia en jellyfin. Comprobar que procesos consumen más memoria o CPU, es tan sencillo como ejecutar htop o top.

De todas maneras, recuerdo que había un par de comandos que te permitían hacer esto de un modo más sencillo.

** Procesos que consumen más RAM

#+begin_src
ps aux --width 30 --sort -rss | head
#+end_src

También podemos hacer la consulta de otro modo.

#+begin_src
ps aux | awk '{print $2, $4, $11}' | sort -k2r | head -n 15
#+end_src

** Procesos que consumen más CPU

#+begin_src
ps -Ao user,uid,comm,pid,pcpu,tty --sort=-pcpu | head -n 6
#+end_src
** Fuente
- https://blog.desdelinux.net/con-el-terminal-mostrar-los-10-procesos-que-mas-memoria-consumen/
- https://www.ochobitshacenunbyte.com/2018/01/29/como-saber-que-procesos-consumen-mas-cpu-y-memoria-en-linux/

* TODO Suscribirte al RSS de canales de YouTube
:PROPERTIES:
:TITLE: Suscribirte al RSS de canales de YouTube
:EXPORT_FILE_NAME: suscribirte-al-rss-de-canales-de-youtube
:DESCRIPTION: No acostumbro a utilizar la aplicación de YouTube, en cambio, FreshRSS la utilizo a diario. Para seguir los Canales de YouTube que más me interesan, me gustaría suscribirme al RSS,
:EXPORT_DATE: 2020-08-15 20:45
:CATEGORY: rss
:TAG: youtube
:IMAGE: ./images-blog/youtube.png
:END:

No acostumbro a utilizar la aplicación de YouTube, en cambio, FreshRSS la utilizo a diario. Para seguir los Canales de YouTube que más me interesan, me gustaría suscribirme al RSS, que no está de un modo visible.
#+HTML: <center>
[[./images-blog/youtube.png]]
#+HTML: </center>

Vamos a ver como suscribirnos a Canales de YouTube mediante el Feed RSS.

** Métodos

Hay 4 métodos de hacerlo y dos modos de extraer el RSS, ya que hay algunos canales que han registrado el nombre del Canal y otros no.

Así que obtener el rss, necesitaremos ver el final de la url principal del canal de YouTube y ver esta acaba con el nombre del Canal o el id.

** Canales con Nombre

Sitúate en la página principal del Canal.

Añade el nombre del canal que aparece al final de la *url*, a continuación de *user=*, siguiendo este patrón:

#+begin_src
https://www.youtube.com/feeds/videos.xml?user=
#+end_src

Por ejemplo la url del Canal de NASeros es =https://www.youtube.com/user/naseros=. Por lo tanto, el Feed para suscribirme será:
#+begin_src
https://www.youtube.com/feeds/videos.xml?user=naseros
#+end_src



** Canales que no tienen nombre. Tiene id


El Canal de Pelado Nerd no tiene nombre, así que el método anterior no servirá. Su url es https://www.youtube.com/channel/UCrBzBOMcUVV8ryyAU_c6P5g.

La combinación de números y letras del final de la url, es el *id* del canal.

Así que siguiendo un poco el modelo anterior, en este caso será:

#+begin_src
https://www.youtube.com/feeds/videos.xml?channel_id=
#+end_src

El rss del canal de Pelado Nerd sería:

#+begin_src
https://www.youtube.com/feeds/videos.xml?channel_id=UCrBzBOMcUVV8ryyAU_c6P5g
#+end_src



** Buscando en el código fuente de la página
Otro método para buscar el rss, pero que a veces puede que no funcione, es buscar dentro del código fuente de la página:

1.- Seleccionamos ver el *Código fuente de la página*, para ver todo el código *html*.
2.- Buscamos el la página, habitualmente suele ser con el atajo *Ctrl+f*, la palabra rss
3.- En el código aparecerá algo así

#+begin_src
<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.youtube.com/feeds/videos
#+end_src

** Google nos facilita el trabajo

Si lo que quieres es exportar todas tus subscripciones de canales de YouTube, desde tu cuenta de YouTube:

- Ve a la página gestionar suscripciones: https://www.youtube.com/subscription_manager.
- En la parte inferior de la página, encontrarás la opción *Exportar a lectores de RSS*. Exporta el archivo *opml* que te permitirá importar todas las fuentes en servidor o cliente *rss*.


* TODO Compilar i3wm para Debian, Ubuntu y otras derivadas
:PROPERTIES:
:TITLE: Compilar i3wm para Debian, Ubuntu y otras derivadas
:EXPORT_FILE_NAME: compilar-i3wm-para-debian-ubuntu-y-otras-derivadas
:DESCRIPTION: Si utilizas Debian o versiones antiguas de Ubuntu, en los repositorios no está disponible la última versión i3wm.
:EXPORT_DATE: 2020-08-16 14:00
:CATEGORY: i3wm
:TAG: debian,ubuntu
:IMAGE: ./images-blog/i3wm.png
:END:




Si utilizas Debian o versiones antiguas de Ubuntu, en los repositorios no está disponible la última versión i3wm.
#+HTML: <center>
[[./images-blog/i3wm.png]]
#+HTML: </center>

En Debian Buster, la versión disponible en repositorios es de Enero del 2019, en cambio compilando, siempre tendremos la última versión. En el momento de este artículo, la última versión disponible es la versión 4.18.2 (2020-07-26).  Este artículo te puede servir de modelo para posteriores versiones, únicamente cambiando el número de versión y quizás, instalando alguna dependencia nueva si te lo pide la terminal.

Vamos con la compilación, que veréis que es muy sencilla
** Instalar Dependencias
Esta son algunas dependencias necesarias

#+begin_src
sudo apt-get install libxcb1-dev libxcb-keysyms1-dev libxcb-util0-dev libxcb-icccm4-dev libyajl-dev libstartup-notification0-dev libxcb-randr0-dev libev-dev libxcb-xinerama0-dev libpango1.0-dev libxcursor-dev libxcb-cursor-dev libxcb-xkb-dev libxkbcommon-dev libxkbcommon-x11-dev libxcb-xrm-dev libxcb-shape0-dev 
#+end_src

** Descargamos la última versión

Podemos ver y descargar la última versión estable, desde https://i3wm.org/.

Descargaremos con wget la última versión en el momento de este artículo =4.18.2=.
#+begin_src
wget https://i3wm.org/downloads/i3-4.18.2.tar.bz2 -O - | tar -xj
cd i3-4.18.2
mkdir -p build && cd build
#+end_src

** Compilamos
#+begin_src
../configure
make
sudo make install
#+end_src
** Reiniciamos
Reiniciamos la sesión de usuario, para iniciar la nueva versión de i3wm.
** Conclusión
A disfrutar plenamente de la última versión de i3wm!!!
** Fuentes
- https://lunaticgeek.com/compila-i3wm/
- https://faq.i3wm.org/question/68/how-to-build-and-install-i3-from-sources.1.html
- https://i3wm.org/

* TODO Instalar última versión de Go en Raspberry, ARM o amd64
:PROPERTIES:
:TITLE: Instalar última versión de Go en Raspberry, ARM o amd64
:EXPORT_FILE_NAME: instalar-ultima-version-de-go-en-raspberry-arm-o-amd64
:DESCRIPTION: Cada vez utilizo más aplicaciones en Go y aunque en las últimas versiones de Debian, Ubuntu, Raspbian,... viene en los repositorios oficiales, no disponemos de la última versión.
:EXPORT_DATE: 2020-08-17 17:25
:CATEGORY: go
:TAG: arm,amd64
:IMAGE: ./images-blog/go.png
:END:




Cada vez utilizo más aplicaciones en Go y aunque en las últimas versiones de Debian, Ubuntu, Raspbian,... viene en los repositorios oficiales, no disponemos de la última versión.
#+HTML: <center>
[[./images-blog/go.png]]
#+HTML: </center>

Vamos a ver como descargarla e instalarla, veréis que sencillo

Yo pongo de ejemplo arquitectura para ARM y amd64, si utilizas alguna otra arquitectura, descarga la correspondiente siguiendo los mismos pasos que muestro.

** Desde los repositorios
Desde los repositorios oficiales de Ubuntu, Debian, Raspberry OS, sería:

#+begin_src
sudo apt install golang
#+end_src

Como he comentado, no tendríamos la última versión.

** Instalar Go en Raspberry o ARM
*** Descargando en instalando Go

Descargamos la versión más reciente [[https://golang.org/doc/install][desde la página de go]].

#+begin_src
wget https://storage.googleapis.com/golang/go1.14.6.linux-armv6l.tar.gz
sudo tar -C /usr/local -xvf go1.14.6.linux-armv6l.tar.gz
#+end_src

*** Añadimos a .bashr o .zshrc

#+begin_src
export GOPATH=$HOME/go
export PATH=/usr/local/go/bin:$PATH:$GOPATH/bin
#+end_src

*** Volvemos a cargar el archivo .bashrc o .zshrc

#+begin_src
source ~/.bashrc
#+end_src
o
#+begin_src
source ~/.zshrc
#+end_src

*** Comprobamos que esta todo ok y que versión tenemos

#+begin_src
go version
#+end_src

** Instalar Go en amd64
*** Descargando en instalando Go


#+begin_src
wget https://storage.googleapis.com/golang/go1.14.6.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.14.6.linux-amd64.tar.gz
#+end_src

*** Añadimos a .bashr o .zshrc

#+begin_src
export GOPATH=$HOME/go
export PATH=/usr/local/go/bin:$PATH:$GOPATH/bin
#+end_src

*** Volvemos a cargar el archivo .bashrc o .zshrc

#+begin_src
source ~/.bashrc
#+end_src
o
#+begin_src
source ~/.zshrc
#+end_src

*** Comprobamos que esta todo ok y que versión tenemos

#+begin_src
go version
#+end_src


** Fuentes

- https://golang.org/dl/
- https://golang.org/doc/install

* TODO Jellycon. La mejor experiencia de Jellyfin en Kodi
:PROPERTIES:
:TITLE: Jellycon. La mejor experiencia de Jellyfin en Kodi
:EXPORT_FILE_NAME: jellycon-la-mejor-experiencia-de-jellyfin-en-kodi
:DESCRIPTION: JellyCon es un complemento ligero de Kodi que te permite navegar y reproducir archivos multimedia desde su servidor Jellyfin directamente dentro de la interfaz de Kodi.
:EXPORT_DATE: 2020-08-19 17:30
:CATEGORY: jellyfin
:TAG: kodi
:IMAGE: ./images-blog/jellycon.png
:END:



JellyCon es un complemento ligero de Kodi que te permite navegar y reproducir archivos multimedia desde su servidor Jellyfin directamente dentro de la interfaz de Kodi.

A diferencia del [[https://www.jellyfin.eu/kodi/][plugin de Kodi]], que necesita de hacer una primera sincronización con el servidor para integrar todas las bibliotecas en Kodi y a partir de entonces, comenzar a reproducir el contenido, Jellycon Reproduce directamente de Kodi al servidor.

Esto es genial!!! es instalar el plugin y comenzar a reproducir. El proceso es muchísimo más rápido y sencillo

#+HTML: <center>
[[./images-blog/jellycon.png]]
#+HTML: </center>


Como puedes imaginar, no solo tienes acceso a tus Películas, Series,... sino también tu música.

Ahora en tu PC con Linux, Windows, Mac, Android, Android TV,... No tienes escusas para reproducir Jellyfin con Kodi

** Instalación
Accede al [[https://github.com/mcarlton00/jellycon/releases][repositorio de GitHub de Jellycon]], descarga la última versión del plugin con extensión *.zip* y instálalo en Kodi.


A disfrutar de Jellyfin!!!!


** Fuentes
- https://github.com/mcarlton00/jellycon/
- https://github.com/mcarlton00/jellycon/releases

* TODO gossa. Servidor ligero de archivos, multimedia, desarrollado en Go
:PROPERTIES:
:TITLE: gossa. Servidor ligero de archivos, multimedia, desarrollado en Go
:EXPORT_FILE_NAME: gossa-servidor-ligero-de-archivos-multimedia-desarrollado-en-go
:DESCRIPTION: Un nuevo servicio en Go. Gossa es un servidor web rápido y simple para ver archivos, sin dependencia y con menos de 200 líneas de código, de modo que es
:EXPORT_DATE: 2020-08-21 17:30
:CATEGORY: servicios
:TAG: go
:IMAGE: ./images-blog/gossa.png
:END:

Un nuevo servicio en Go. Gossa es un servidor web rápido y simple para ver archivos, sin dependencia y con menos de 200 líneas de código, de modo que es muy fácil de revisar.

#+HTML: <center>
[[./images-blog/gossa.png]]
#+HTML: </center>

La interfaz de usuario es muy simple y viene por defecto, con:

- navegador de archivos/directorios
- Arrastrar y soltar para subir archivos/directorios
- Interfaz de usuario predeterminada solo pesa 110 kb, pudiendo manejar archivos, moverlos, renombrarlos, borrarlos
- navegador de imágenes
- Reproducción video en streaming
- Editor de texto simple
- atajos de teclado
- servidor estático rápido de golang, llena fácilmente el ancho de banda disponible
- bloquear configuración fácil/segura de múltiples cuentas

** Instalación

Nos conectamos a la *release* disponible en GitHub y descargamos la correspondiente a nuestra arquitectura o sistema operativo.
https://github.com/pldubouilh/gossa/releases

En este caso, voy a utilizar de ejemplo Linux y arquitectura ARM

*** ARM

Descargamos la release correspondiente, en el momento de redactar el artículo, está la versión 0.1.6.

#+begin_src
wget https://github.com/pldubouilh/gossa/releases/download/v0.1.6/gossa-linux-arm
#+end_src

#+begin_src
mv gossa-linux-arm gossa
#+end_src


#+begin_src
./gossa -h 192.168.1.100 ~/directorio
#+end_src

Hacer correr, por ejemplo, por el Puerto 8888
#+begin_src d
./gossa -h 192.168.1.100 -p 8888 ~/directorio
#+end_src

*** Docker arquitectura amd64

#+begin_src
docker run -v ~/directorio:/shared -p 8001:8001 pldubouilh/gossa
#+end_src
** Ayuda

Gossa también la podemos utilizar con la terminal.

Para mostrar las opciones disponibles, ejecutamos la ayuda:

#+begin_src
./gossa -h
#+end_src

#+begin_src
flag needs an argument: -h

usage: ./gossa ~/directory-to-share

-h string
host to listen to (default "127.0.0.1")
-k
skip hidden files (default true)
-p string
port to listen to (default "8001")
-prefix string
url prefix at which gossa can be reached, e.g. /gossa/ (slashes of importance) (default "/")
-ro
read only mode (no upload, rename, move, etc...)
-symlinks
follow symlinks WARNING: symlinks will by nature allow to escape the defined path (default: false)
-verb
verbosity
#+end_src

** Fuentes

- https://github.com/pldubouilh/gossa
- https://github.com/pldubouilh/gossa/releases
- https://hub.docker.com/r/pldubouilh/gossa




* TODO Saltando de un directorio a otro con Jump
:PROPERTIES:
:TITLE: Saltando de un directorio a otro con Jump
:EXPORT_FILE_NAME: saltando-de-un-directorio-a-otro-con-jump
:DESCRIPTION: Después de escuchar el Podcast de Lorenzo, atareao.es, he decidido probar este complemento para la terminal que hacía mucho tiempo que estaba buscando y no sabía que existía.
:EXPORT_DATE: 2020-08-24 17:30 2020-12-31
:CATEGORY: bash
:TAG: terminal
:IMAGE: ./images-blog/jump.svg
:END:



Después de escuchar el Podcast de Lorenzo, atareao.es, he decidido probar este complemento para la terminal que hacía mucho tiempo que estaba buscando y no sabía que existía.

#+HTML: <center>
[[./images-blog/jump.svg]]
#+HTML: </center>

Es un complemento súper productivo para moverte por la terminal.

Jump se integra con su shell y aprende sobre sus hábitos de navegación al realizar un seguimiento de los directorios que visita. Te proporciona el directorio más visitado para el término de búsqueda más corto que escriba.


** Instalación
*** Con Go
Si no tienes instalado Go, busca el artículo donde explico como hacerlo.

Si lo tienes instalado, la instalación es tan simple como:

#+begin_src
go get github.com/gsamokovarov/jump
#+end_src

*** Ubuntu
#+begin_src
wget https://github.com/gsamokovarov/jump/releases/download/v0.30.1/jump_0.30.1_amd64.deb && sudo dpkg -i jump_0.30.1_amd64.deb
#+end_src

*** Mac y otras distros
Visita el repositorio de Jump donde explica como instalarlo en el resto de distros



** Añadir a bash o zsh

Para bash y zsh, añade la siguiente línea a ~/.bashrc, ~/bash_profileo o ~/.zshrc


#+begin_src
eval "$(jump shell)"
#+end_src


** En fish
Para que funcione en fish, tenemos que añadir al archivo =~/.config/fish/config.fish=

#+BEGIN_SRC 
status --is-interactive; and source (jump shell fish | psub)
#+END_SRC

A mi este método no me funcionó, así que lo que hice es añadirlo en el alias así:

#+BEGIN_SRC 
alias j='~/go/bin/jump shell fish |'
#+END_SRC

Ahora cuando pulso *j* en la terminal, ejecuta =~/go/bin/jump shell fish |=


** Cambiar j por z

Si deseas utilizar otra letra para ejecutar jump, por ejemplo la letra z

#+begin_src
eval "$(jump shell --bind=z)"
#+end_src

Si lo has hecho mediante el alias, es tan simple como poner *z* en lugar de *j*, en el apartado anterior.

** Funcionamiento
Jump usa la coincidencia difusa para encontrar el directorio deseado para saltar. Solo necesita de 2 a 5 caracteres para saltar al directorio.

Para alimentar jump de los directorios que utilizamos frecuentemente, tendremos que movernos por estos de un modo normal como lo hacemos habitualmente y jump irá añadiendo estos a su base de datos.


Pusamos *j* seguido de los *caracteres que coincidan con el directorio* que buscamos y pulsamos *enter*.

Ejemplo: Buscar el directorio docker

#+begin_src
j dk
#+end_src

Si no coincide con lo que buscabamos, ya que queríamos ir al directorio ~/docker/docker, escribiremos *j* + *enter* y nos aparecerá la siguiente sugerencia.

#+begin_src
j
#+end_src

** Listado de directorios añadidos en la base de datos de jump

#+begin_src
jump top
#+end_src

** Eliminar una ruta de directorio
Nos situamos en ese directorio y ejecutamos

#+begin_src
jump forget
#+end_src


** Ayuda
Para ver todas las opciones disponibles, veremos la ayuda

#+begin_src
jump
#+end_src



** Fuentes
- https://github.com/gsamokovarov/jump
- https://www.atareao.es/podcast/personalizar-el-terminal/




* TODO Kanboard
:PROPERTIES:
:TITLE: Kanboard
:EXPORT_FILE_NAME: kanboard
:DESCRIPTION: Kanboard es un servicio que nos permite gestionar nuestras tareas siguiendo el método Kanban.
:EXPORT_DATE: 2020-08-26 17:30
:CATEGORY: docker
:TAG: kanban
:IMAGE: ./images-blog/kanboard.png
:END:


Kanboard es un servicio que nos permite gestionar nuestras tareas siguiendo el método Kanban.

#+HTML: <center>
[[./images-blog/kanboard.png]]
#+HTML: </center>

He instalado el servicio después de mucho tiempo tanto en mi Raspberry como mi Servidor amd64, de un modo súper sencillo y rápido, gracias a Docker.


** Docker

El docker lo tenemos disponible tanto para arquitectura amd64, arm, arm64...

*** Docker amd64


#+begin_src
docker create --name=kanboard       -p "80:80"       -v $HOME/docker/kanboard/data:/var/www/app/data       -v $HOME/docker/kanboard/plugins:/var/www/app/plugins       -v $HOME/docker/kanboard/ssl:/etc/nginx/ssl kanboard/kanboard:latest
#+end_src


*** Docker arm o Raspberry Pi

#+begin_src
docker create --name=kanboard       -p "80:80"       -v $HOME/docker/kanboard/data:/var/www/app/data       -v $HOME/docker/kanboard/plugins:/var/www/app/plugins       -v $HOME/docker/kanboard/ssl:/etc/nginx/ssl kanboard/kanboard:arm32v7-latest
#+end_src

*** Docker más arquitecturas
Si quieres otra arquitectura, revisa en [[https://hub.docker.com/r/kanboard/kanboard/tags][DockerHub]] todas las etiquetas disponibles, cambiando la etiqueta que corresponda.

*** Docker Compose para Traefik y Proxy Inverso
Si utilizas un proxy inverso, podemos montar el contenedor con este docker-compose

#+begin_src
version: "3"

networks:
web:
external: true

services:
kanboard:
image: kanboard/kanboard:latest
ports:
- "83:80"
volumes:
- $HOME/docker/kanboard/data:/var/www/app/data
- $HOME/docker/kanboard/plugins:/var/www/app/plugins
- $HOME/docker/kanboard/ssl:/etc/nginx/ssl
labels:
- traefik.backend=kanboard
- traefik.frontend.rule=Host:kanboard.midominio.duckdns.org
- traefik.docker.network=web
- traefik.port=80
- traefik.enable=true
networks:
- web
#+end_src


** Iniciar Kanboard y cambiar usuario y contraseña
La primera vez que iniciamos Kanboard, para utilizar el servicio, utilizaremos el usuario y contraseña por defecto:


Username: admin
Password: admin


Es importante el cambiar el usuario y contraseña. Para hacerlo, lo haremos del siguiente modo pulsando en el icono del usuario.

- Cambiar usuario: Gestión de usuarios -> Acciones -> Editar perfil
- Cambiar contraseña: Gestión de usuarios -> Acciones -> Cambiar contraseña


** Habilitar plugins
Por defecto y por seguridad, vienen deshabilitada la posibilidad de instalar plugins. Si deseas instalar cualquiera del gran número de plugins disponibles, entramos dentro del contenedor y editaremos con vi el archivo *config.php*.


#+begin_src
vi /var/www/app/config.php
#+end_src

#+begin_src
// Plugins directory
define('PLUGINS_DIR', 'plugins');

// Plugins directory URL
define('PLUGIN_API_URL', 'https://kanboard.org/plugins.json');

// Enable/Disable plugin installer
define('PLUGIN_INSTALLER', true);
#+end_src

*Restaurar el docker, para que los cambios tengan efecto*.


** Temas
Hay varios temas disponible, que harán de Kanboard una interfaz más amigable, bonita y moderna.

En mi caso he instalado la de *Greenwing*.

** Notificaciones
Si creamos un Bot con su Token en Telegram, podremos hacer que nos notifique cada vez que cambiemos una tarea de estado.

Recuerda el Podcast y Artículo donde explico como hacerlo paso a paso : https://ugeek.github.io/post/2018-02-09-kanboard-con-notificaciones-en-telegram.html

** Fuentes
- https://docs.kanboard.org/en/latest/admin_guide/docker.html
- https://hub.docker.com/r/kanboard/kanboard/tags
- https://www.ochobitshacenunbyte.com/2019/04/26/kanboard-instalacion-de-plugins-via-web/
- https://github.com/Confexion/Greenwing



* TODO Visualizar aparte una Cabecera de un OrgMode en Emacs
:PROPERTIES:
:TITLE: Visualizar aparte una Cabecera de un OrgMode en Emacs
:EXPORT_FILE_NAME: visualizar-aparte-una-cabecera-de-un-orgmode-en-emacs
:DESCRIPTION: Hay momentos, al menos a mi me pasa, de todas las notas que voy registrando en mi orgmode, quiero exporta una ya sea en formato txt, pdf, markdown,...
:EXPORT_DATE: 2020-09-03 17:30
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/orgmode.png
:END:

Hay momentos, al menos a mi me pasa, de todas las notas que voy registrando en mi orgmode, quiero exporta una ya sea en formato txt, pdf, markdown,...

#+HTML: <center>
[[./images-blog/orgmode.png]]
#+HTML: </center>

Para poder visualizar esa cabecera (nota) en un buffer aparte, para poder trabajar con ella, o como en el caso de este artículo, exportarla a formato de texto plano (.txt), es tan simple como:

- Nos situamos en la cabecera que queremos visualizar en un buffer aparte
- Utilizamos el siguiente atajo:

#+BEGIN_SRC
C-c C-x b
#+END_SRC

Recuerda que Emacs lo único que está haciendo, es visualizar esa cabecera aparte, pero todo aquello que modifiques, lo harás en el orgmode que abriste al principio, no es una archivo aparte.

** OrgMode a txt
Una vez visualizado en un buffer aparte, voy a exportarlo a texto plano

#+BEGIN_SRC
C-c C-e t u
#+END_SRC

** Orgmode a pdf
También podríamos exportarlo a pdf

#+BEGIN_SRC
C-c C-e l p
#+END_SRC

** Orgmode a markdown
Emacs también permite exportar a markdown desde nuestro orgmode

#+BEGIN_SRC
C-c C-e M m
#+END_SRC


* TODO Navidrome. La alternativa a Airsonic desarrollada en Go
:PROPERTIES:
:TITLE: Navidrome. La alternativa a Airsonic desarrollada en Go
:EXPORT_FILE_NAME: navidrome-la-alternativa-a-airsonic-desarrollada-en-go
:DESCRIPTION: Navidrome es un servidor de música en streaming de código abierto basado en un servidor web. Da la libertad de escuchar tu colección de música desde cualquier navegador o dispositivo
:EXPORT_DATE: 2020-09-16 18:45
:CATEGORY: subsonic
:TAG: servidor,música
:IMAGE: ./images-blog/navidrome.png
:END:

Navidrome es un servidor de música en streaming de código abierto basado en un servidor web. Da la libertad de escuchar tu colección de música desde cualquier navegador o dispositivo móvil. ¡Es como tu Spotify personal!

[[https://translate.googleusercontent.com/translate_c?depth=1&hl=es&pto=aue&rurl=translate.google.com&sl=auto&sp=nmt4&u=https://www.navidrome.org/demo/&usg=ALkJrhjBly3sgwOBW24Lv39WuY7lBJAAxw][Aquí hay una Demo]], para que veáis el servicio en acción.

#+HTML: <center>
[[./images-blog/navidrome.png]]
#+HTML: </center>


Cosas que me gustan:
- Página web del servicio
- Descargar canción o album en formato .zip
- Actualización si añades nuevo álbum
- Descargar archivos de listas y exportar listas en .m3u
- Listas públicas y privadas

** Características

- Maneja colecciones de música muy grandes
- Transmite prácticamente cualquier formato de audio disponible
- Lee y usa todos sus metadatos
- Gran soporte para compilaciones (álbumes de varios artistas) y conjuntos de cajas (álbumes de varios discos)
- Multiusuario , cada usuario tiene sus propios recuentos de reproducción, listas de reproducción, favoritos, etc.
- Uso de recursos muy bajo
- Multiplataforma , se ejecuta en macOS, Linux y Windows. También se proporcionan imágenes de Docker
- Binarios listos para usar para todas las plataformas principales, incluida Raspberry Pi
- Supervisa automáticamente su biblioteca en busca de cambios, importa nuevos archivos y recarga nuevos metadatos
- Interfaz web  moderna y receptiva basada en Material UI
- Compatible con todos los clientes Subsonic, Madsonic, Airsonic
- Transcodificación sobre la marcha. Se puede configurar por usuario/reproductor. Se admite la codificación Opus
- Traducido a varios idiomas

** Docker

Tenemos disponible el docker para arquitectura amd64, arm y arm64.



#+BEGIN_SRC
docker run -d    --name navidrome    --restart=unless-stopped    --user $(id -u):$(id -g)    -v $HOME/docker/media/Musica:/music    -v $HOME/navidrome:/data    -p 4533:4533
-e ND_LOGLEVEL=info    deluan/navidrome:latest
#+END_SRC


** Docker Raspberry

Vamos, que también podemos instalarlo en nuestra Raspberry Pi.

#+BEGIN_SRC
docker run -d    --name navidrome    --restart=unless-stopped    --user $(id -u):$(id -g)    -v $HOME/docker/media/Musica:/music    -v $HOME/navidrome:/data    -p 4533:4533
-e ND_LOGLEVEL=info    deluan/navidrome:pi
#+END_SRC

** Docker Compose

#+begin_src
version: "3"
services:
navidrome:
image: deluan/navidrome:latest
ports:
- "4533:4533"
environment:
# All options with their default values:
ND_MUSICFOLDER: /music
ND_DATAFOLDER: /data
ND_SCANINTERVAL: 1m
ND_LOGLEVEL: info
ND_PORT: 4533
ND_TRANSCODINGCACHESIZE: 100MB
ND_SESSIONTIMEOUT: 24h
ND_BASEURL: ""
volumes:
- "$HOME/navidrome:/data"
- "$HOME/docker/media/Musica:/music:ro"

#+end_src

** Reescanear biblioteca

Entramos dentro del docker y ejecutamos
#+BEGIN_SRC
/app/navidrome scan -f
#+END_SRC

** Ayuda

#+BEGIN_SRC
/app/navidrome --help
#+END_SRC

** Fuentes

- https://www.navidrome.org
- https://github.com/deluan/navidrome
- https://www.navidrome.org/docs/installation/docker/

* TODO Croc, la aplicación que nos permite enviar o compartir archivos, directorios, texto... a cualquier dispositivo esté donde esté de un modo fácil con la terminal
:PROPERTIES:
:TITLE: Croc, la aplicación que nos permite enviar o compartir archivos, directorios, texto... a cualquier dispositivo esté donde esté de un modo fácil con la terminal
:EXPORT_FILE_NAME: croc-la-aplicacion-que-nos-permite-enviar-o-compartir-archivos-directorios-texto--a-cualquier-dispositivo-este-donde-este-de-un-modo-facil-con-la-terminal
:DESCRIPTION: Croc una herramienta que permite transferir archivos,directorios y texto, de forma sencilla y segura, entre dos PC's, servidores, etc....
:EXPORT_DATE: 2020-09-20 17:30
:CATEGORY: sincronización
:TAG: sync,go
:IMAGE: ./images-blog/croc.png
:END:

Croc una herramienta que permite transferir archivos,directorios y texto, de forma sencilla y segura, entre dos PC's, servidores, etc....

#+HTML: <center>
[[./images-blog/croc.png]]
#+HTML: </center>

AFAIK, croc es la única herramienta de transferencia de archivos CLI que hace todo lo siguiente:

- permite que dos computadoras transfieran datos (usando un Relay)
- proporciona *cifrado de extremo a extremo* (mediante PAKE)
- permite transferencias sencillas entre plataformas (Windows, Linux, Mac)
- permite múltiples transferencias de archivos
- permite reanudar transferencias interrumpidas
- No es necesario servidor local o reenvío de puertos
- más rápido que wormhole , rsync , scp a través de la compresión y multiplexación (aceleraciones de 1.5xa 4x)
ipv6-first con respaldo de ipv4.

** Instalación
La instalación podemos hacerla de diferente maneras, también en función de tu sistema operativo
*** Instala la última release Linux
#+BEGIN_SRC
curl https://getcroc.schollz.com | bash
#+END_SRC

*** Instalación por snap
#+BEGIN_SRC
sudo snap install croc
#+END_SRC

*** Termux
Si utilizas Termux en Android:
#+BEGIN_SRC
pkg install croc
#+END_SRC
** Funcionamiento

Una vez instalado croc en ambos dispositivos, para enviar una archivo o directorio, de un dispositivo a otro, utilizaremos el siguiente comando
#+BEGIN_SRC  shell
croc send archivo.txt

Code is: adrian-freedom-harris
On the other computer run

croc adrian-freedom-harris
#+END_SRC

Para poder recibir este archivo en el otro dispositivo, introduciremos en su terminal *adrian-freedom-harris*

El archivo, queda a la espera en el dispositivo origen, a la espera que introduzcamos el siguiente código en el dispositivo destino:

#+BEGIN_SRC  shell
croc adrian-freedom-harris
#+END_SRC

El otro dispositivo preguntará, si queremos descargar el archivo. Pulsaremos *y* para descargarlo.

#+BEGIN_SRC  shell
croc adrian-freedom-harris

Accept 'archivo.txt' (208.3 kB)? (y/n)
#+END_SRC

El resultado será..
#+BEGIN_SRC
Receiving (<-[::1]:44504)
unison.log 100% |████████████████████| (203/203 kB, 2.943 MB/s) [0s:0s] ✔️
#+END_SRC

Ahora mi Raspberry se comunica perfectamente con mi PC

** Código personalizado
Para automatizar esta tarea mediante un script, podemos enviar con la opción *--code* nuestro propio código (debe tener más de 4 caracteres).

#+BEGIN_SRC
croc send --code [código_frase] ~/directorio
#+END_SRC

** Enviando texto
Para enviar un texto:
#+BEGIN_SRC
croc send --text "hola mundo"
#+END_SRC


** Utilizando tuberías: stdin y stdout

#+BEGIN_SRC
cat archivo.txt | croc send
#+END_SRC


** Creando un servidor relay
Entre las opciones de croc, incluye el levantar tu propio relay:

#+BEGIN_SRC
croc relay
#+END_SRC

De forma predeterminada, utiliza los puertos TCP 9009-9013. Asegúrate de abrirlos. Puede personalizar los puertos (por ejemplo croc relay --ports 1111,1112), pero debe tener un mínimo de 2 puertos para el relay.

El primer puerto es para la comunicación y los puertos subsiguientes se utilizan para la transferencia de datos multiplexados.

Puede enviar archivos usando su relay ingresando *--relay* para cambiar el relé que está usando si desea personalizar el suyo propio.

#+BEGIN_SRC  shell
croc --relay "mirelay.duckdns.org:9009" send archivo.txt
#+END_SRC

al enviar, solo necesita incluir el primer puerto (puerto de comunicación). Los puertos posteriores son para la transferencia de datos que se transmitirán al usuario desde el relay.

** Relay por Docker

Para crear nuestro relay permanente utilizando docker:

#+BEGIN_SRC
docker run -d -p 9009-9013:9009-9013 -e CROC_PASS='TU_CONTRASEÑA' schollz/croc
#+END_SRC

Asegúrate de incluir la contraseña para el relay, de lo contrario, se rechazarán las solicitudes.

#+BEGIN_SRC  shell
croc --pass TU_CONTRASEÑA --relay "mirelay.duckdns.org:9009" send archivo
#+END_SRC


En el otro dispositivo pondremos para descargar utilizando nuestro relay:
#+BEGIN_SRC
croc --pass TU_CONTRASEÑA --relay "mirelay.duckdns.org:9009" código_que_dará_nuestro_relay
#+END_SRC

** Código personalizado en mi Relay

#+BEGIN_SRC
croc --pass CONTRASEÑA --relay "mi.duckdns.org:9009"  send --code este-es-mi-codigo archivo.txt
#+END_SRC

Para no tener que confirmar la descarga, en casos que quieras automatizar esta con un script, utilizaremos *--yes*

#+BEGIN_SRC
croc --yes --pass CONTRASEÑA --relay "mi.duckdns.org:9009"  send --code este-es-mi-codigo archivo.txt
#+END_SRC

** Exportando mi contraseña

Si no deseas tener que poner en tu dispositivo siempre la contraseña de tu realy, ya que tu dispositivo en de confianza, puedes añadir una variable en ./bashrc o ./zshrc, para que al iniciar bash cargue esta contraseña. Yo he utilizado:

#+BEGIN_SRC
export CROC_RELAY="--yes --pass CONTRASEÑA --relay mi.duckdns.org:9009"
#+END_SRC

Ahora para enviar lo hariamos:
#+BEGIN_SRC
croc $(echo $CROC_RELAY)  send --code este-es-mi-codigo archivo.txt
#+END_SRC

Recargamos los cambios, por ejemplo en  *.bashrc:
#+BEGIN_SRC
source ~/.bashrc
#+END_SRC


** Ayuda
Comando de ayuda y más opciones:
#+BEGIN_SRC
croc -h
NAME:
croc - easily and securely transfer stuff from one computer to another

USAGE:
Send a file:
croc send file.txt

Send a file with a custom code:
croc send --code secret-passphrase file.txt

VERSION:
v8.3.2-7d155ad

COMMANDS:
send     send a file (see options with croc send -h)
relay    start your own relay (optional)
help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:
--remember      save these settings to reuse next time (default: false)
--debug         toggle debug mode (default: false)
--yes           automatically agree to all prompts (default: false)
--stdout        redirect file to stdout (default: false)
--no-compress   disable compression (default: false)
--ask           make sure sender and recipient are prompted (default: false)
--relay value   address of the relay (default: "142.93.177.120:9009") [$CROC_RELAY]
--relay6 value  ipv6 address of the relay (default: "[2604:a880:800:c1::14c:1]:9009") [$CROC_RELAY6]
--out value     specify an output folder to receive the file (default: ".")
--pass value    password for the relay (default: "pass123") [$CROC_PASS]
--help, -h      show help (default: false)
--version, -v   print the version (default: false)
#+END_SRC
** Fuentes
- https://github.com/schollz/croc
- https://hub.docker.com/r/schollz/croc



* TODO Crear enlaces simbólicos a otros directorios o archivos
:PROPERTIES:
:TITLE: Crear enlaces simbólicos a otros directorios o archivos
:EXPORT_FILE_NAME: crear-enlaces-simbolicos-a-otros-directorios-o-archivos
:DESCRIPTION: Un enlace simbólico, sería algo similar a crear un acceso directo de un directorio o archivo, a otro dentro en un mismo dispositivo.
:EXPORT_DATE: 2020-10-05 22:10
:CATEGORY: bash
:TAG: zsh
:IMAGE: ./images-blog/bash.png
:END:

Un enlace simbólico, sería algo similar a crear un acceso directo de un directorio o archivo, a otro dentro en un mismo dispositivo.
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

** Crear enlace simbólico

Crear enlace simbólico con directorios:

#+BEGIN_SRC  shell
ln -s ~/directorio_origen ~/directorio_destino
#+END_SRC

También podemos hacerlo con archivos:

#+BEGIN_SRC  shell
ln -s ~/directorio/archivo_origen.txt ~/directorio/archivo_destino.txt
#+END_SRC

** Eliminar en enlace simbólico

Para eliminar el enlace simbólico.

#+BEGIN_SRC shell
unlink ruta_del_enlace
#+END_SRC

También podríamos utilizar:

#+BEGIN_SRC shell
rm ~/directorio_destino
#+END_SRC

Enlace simbólico de un directorio:
#+BEGIN_SRC shell
rm -Rf ~/directorio_destino
#+END_SRC

* TODO Montar un usb, tarjeta SD, disco duro o SSD formateado en EXT4, FAT32 o NTFS, en un directorio con Linux
:PROPERTIES:
:TITLE: Montar un usb, tarjeta SD, disco duro o SSD formateado en EXT4, FAT32 o NTFS, en un directorio con Linux
:EXPORT_FILE_NAME:
:DESCRIPTION: Vamos a ver los comandos para montar un usb, SD, disco duro o SSD, en un directorio desde la terminal.
:EXPORT_DATE: 2020-10-07 07:30 2021-01-30
:CATEGORY: bash
:TAG: sd,ssd,usb
:IMAGE: ./images-blog/sd.png
:END:
He conectado 5 relés y 4 Discos Duros a mi Raspberry para hacer backups.
#+HTML: <center>
[[./images-blog/sd.png]]
#+HTML: </center>

Ahora tengo que crear un script para automatizar el montaje de estos discos y siempre cada uno de ellos tiene que montarse en el mismo directorio.

Vamos a ver como podemos hacer esto. Voy a utilizar un ejemplo con un disco.

** Conocer el UUID
Primero necesitamos conocer el UUID de un disco. 

#+BEGIN_SRC 
sudo blkid
#+END_SRC

El resultado que me ha dado es:

#+begin_src sh
UUID="54C2D371C2D447BD"
#+end_src


También podríamos utilizar

#+BEGIN_SRC 
ls -l /dev/disk/by-uuid
#+END_SRC


También podemos ver todas las unidades conectadas a nuestro dispositivo con:

#+BEGIN_SRC 
ls -l /dev/sd*
#+END_SRC


** Montar Disco
Ya lo tenemos resuelto. Ahora vamos a montar el disco. En mi ejemplo el disco está en formato NTFS, tal como venía de la tienda y he pasado de formatearlo. Si el disco tiene otro tipo de formato, tienes que especificarlo en le montaje.


#+BEGIN_SRC 
sudo mount -t ntfs-3g  UUID="54C2D371C2D447BD" /home/angel/Disco1
#+END_SRC

** Desmontar Disco

Para desmontar un disco:
#+begin_src sh
sudo umount directorio
#+end_src

Para desmontar varios discos:

#+begin_src sh
sudo umount directorio1 directorio2 directorio3 directorio4
#+end_src


**** Forzar desmontar 

En ocasiones el sistema kernel considera que el sistema de archivos está ocupado, en estos casos, puedes forzar con el desmontaje =umount -f=.
 
Averigua el porque no puedes desmontarlo antes de forzar, porque quizás si hay un motivo.


#+begin_src sh
sudo umount -f directorio
#+end_src




** Ver todas las unidades montadas
#+begin_src sh
mount
#+end_src



** Montar unidad EXT4

#+BEGIN_SRC
sudo mount -t ext4 -o defaults /dev/sda1 /media/usb
#+END_SRC

** Montar unidad FAT32

#+BEGIN_SRC
sudo mount -t vfat /dev/sdb1 /media/usb
#+END_SRC

** Montar unidad NTFS

Para montar una partición NTFS, utilizaremos:

#+BEGIN_SRC
sudo mount -t ntfs-3g /dev/sdb1 /media/usb
#+END_SRC

** Montaje de otro tipo de formatos
Para verlo de un modo más simplificado y sin opciones especiales de montaje:

**** FAT16 o FAT32  

#+begin_src sh
sudo mount -t vfat UUID="54C2D371C2D447BD" /home/angel/Disco1
#+end_src

**** NTFS 

#+begin_src sh
sudo mount -t ntfs UUID="54C2D371C2D447BD" /home/angel/Disco1
#+end_src

**** EXT3 

#+begin_src sh
sudo mount -t ext3 UUID="54C2D371C2D447BD" /home/angel/Disco1
#+end_src


**** EXT4 

#+begin_src sh
sudo mount -t ext4 UUID="54C2D371C2D447BD" /home/angel/Disco1
#+end_src

**** UFS 

#+begin_src sh
sudo mount -t ufs -o ro UUID="54C2D371C2D447BD" /home/angel/Disco1
#+end_src

**** UFS2 

#+begin_src sh
sudo mount -t ufs -o ro,ufstype=ufs2 UUID="54C2D371C2D447BD" /home/angel/Disco1
#+end_src

**** Montar un directorio en otro dentro de nuestro sistema

#+begin_src sh
sudo mount /home/angel/directorio1 /home/angel/directorio2
#+end_src


** Comprobar si la unidad se ha montado correctamente
Sería tan fácil como hacer un *ls* en el directorio donde hemos montado la unidad, pero para ver un resumen del resto de unidades:

#+BEGIN_SRC
df -l
#+END_SRC

** Montar al inicio con el sistema

Montar automáticamente con el sistema, sería añadirlo en el archivo de configuración =/etc/fstab=.

Vamos a editarlo:
#+begin_src sh
sudo nano /etc/fstab
#+end_src

Es importante que los espacios son *Tabulados.*
#+BEGIN_SRC sh
UUID="54C2D371C2D447BD"  /home/angel/Disco1   ext    defaults,auto 0    0
#+END_SRC
Si en las opciones de montaje no utilizamos ningún valor, como en la línea anterior, podremos =defaults=.


** Montar todos los discos
Para montar todos los disco que hay en el archivo =/etc/fstab= a la vez, en el caso que hayamos desmontado alguno, utilizaremos el siguiente comando.

#+begin_src  sh
sudo mount -a
#+end_src















** Desmontar una unidad

#+BEGIN_SRC
sudo umount /media/usb
#+END_SRC

Puede que la unidad esté ocupada realizando un proceso. Para forzar y desmontar la unidad:

#+BEGIN_SRC 
sudo umount -l /dev/sdb1
#+END_SRC

Para desmontar varios discos

#+begin_src sh
sudo umount directorio1 directorio2 directorio3 directorio4
#+end_src

*** Montar al inicio con el sistema

Montar automáticamente con el sistema, sería añadirlo en el archivo de configuración =/etc/fstab=.

Vamos a editarlo:
#+begin_src sh
sudo nano /etc/fstab
#+end_src

Es importante que los espacios son *Tabulados.*
#+BEGIN_SRC sh
UUID="54C2D371C2D447BD"  /home/angel/Disco1   ext    defaults,auto 0    0
#+END_SRC
Si en las opciones de montaje no utilizamos ningún valor, como en la línea anterior, podremos =defaults=.


*** Montar todos los discos
Para montar todos los disco que hay en el archivo =/etc/fstab= a la vez, en el caso que hayamos desmontado alguno, utilizaremos el siguiente comando.

#+begin_src  sh
sudo mount -a
#+end_src


* TODO duf. Visualizando el almacenamiento
:PROPERTIES:
:TITLE: duf. Visualizando el almacenamiento
:EXPORT_FILE_NAME: duf-visualizando-el-almacenamiento
:DESCRIPTION: Normalmente para ver el tamaño de mis unidades de almacenamiento, utilizo =du -h.= Si quiero conocer el tamaño de un directorio, me situo dentro del mismo y hago un =du
:EXPORT_DATE: 2020-10-10 08:15
:CATEGORY: bash
:TAG: tesrminal
:IMAGE: ./images-blog/bash.png
:END:

Normalmente para ver el tamaño de mis unidades de almacenamiento, utilizo =du -h.= Si quiero conocer el tamaño de un directorio, me situo dentro del mismo y hago un =du -hs=.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Ahora con duf, ver el almacenamiento de mis unidades, es muchísimo más simple y sencillo porque podemos verlo de un modo más gráfico.

** Instalación
[[https://github.com/muesli/duf/releases/tag/v0.4.0][Descargaremos el paquete .deb de la última release]], para arquitectura que tengamos: amd64, arm,... siempre y cuando utilices una derivada de Debian.

En el caso de instalarlo en una Raspberry, vamos a proceder como habitualmente lo hacemos:
#+BEGIN_SRC
sudo dpkg -i duf_0.4.0_linux_armv6.deb
#+END_SRC

Recuerda que los archivos *.deb* no se auto-actualizan, así que si quieres tener la última versión, tendrás que seguir este proceso con cada actualización.

** Ejecutando duf
Para ver de un modo gráfico el tamaño de todas las particiones, ejecutaremos duf de este modo tan simple

#+BEGIN_SRC
duf
#+END_SRC


** Fuentes
- https://github.com/muesli/duf
- https://nksistemas.com/ver-espacio-de-disco-en-linux-con-du


* TODO Buscar texto en un directorio, archivo,... con grep y find
:PROPERTIES:
:TITLE: Buscar texto en un directorio, archivo,... con grep y find
:EXPORT_FILE_NAME: buscar-texto-en-un-directorio-archivo---con-grep-y-find
:DESCRIPTION: Grep y find vienen instaladas por defecto en todas las distros y tienen un potencial increíble.
:EXPORT_DATE: 2020-10-14 07:45
:CATEGORY: bash
:TAG: terminal
:IMAGE: ./images-blog/bash.png
:END:

Grep y find vienen instaladas por defecto en todas las distros y tienen un potencial increíble.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Con grep y find podemos buscar directorios, archivos o el texto que contenga estos archivos. Ideal para encontrar todo aquello que no recuerdes donde lo has dejado.

** grep
*** Buscar en un directorio con grep
Buscamos la palabra “texto” en el directorio "directorio":

#+BEGIN_SRC 
grep "texto" ~/directorio
#+END_SRC

*** Busqueda recursiva con grep
La opción *-R*, busca de forma recursiva en los subdirectorios

- -R = Recursivo mostrando también los enlaces simbólicos
- -r = recursivo
- -i = No distingue entre mayúsculas o minúsculas
- -l = Mostrar la ruta del archivo que tenga la palabra buscada

#+BEGIN_SRC  
grep -R "texto" ~/directorio
#+END_SRC


#+BEGIN_SRC  
grep -ir "texto" ~/directorio
#+END_SRC

Buscar la palabra linux en el contenido de todos los archivos y mostrar su ruta

#+BEGIN_SRC
grep -ril "linux" .
#+END_SRC

*** Excluyendo determinados directorios o archivos

#+BEGIN_SRC
grep -ir --color --exclude-dir={directorio1,directorio2,.git} --exclude={*.txt,*.md} /
#+END_SRC

** find
*** Buscar archivo, directorios con find
A partir del directorio donde estamos, busca recursivamente:

#+BEGIN_SRC
find . -name "archivo"
#+END_SRC

Buscar en todo el dispositivo:
#+BEGIN_SRC
find / -name "archivo"
#+END_SRC

No tener en cuenta mayúsculas o minúsculas
#+BEGIN_SRC
find . -iname "archivo"
#+END_SRC

Podemos utilizar expresiones regulares para ayudarnos a encontrar lo que deseamos, si no recordamos la palabra exacta.

No recuerdo como empieza y acaba la palabra "archivo"...

#+BEGIN_SRC
find . -iname "*chiv*"
#+END_SRC



* TODO Docker: Wireguard para Raspberry, Ubuntu, Debian,...
:PROPERTIES:
:TITLE: Docker: Wireguard para Raspberry, Ubuntu, Debian,...
:EXPORT_FILE_NAME: docker-wireguard-para-raspberry-ubuntu-debian--
:DESCRIPTION: Ya hemos visto como instalar  Wireguard con los paquetes disponibles en la distro o añadiendo el repositorio del desarrollador. También os expliqué como crear el archivo de configuración del
:EXPORT_DATE: 2020-10-19 14:30
:CATEGORY: vpn
:TAG: wireguard,terminal,servidor,raspberry,ubuntu
:IMAGE: ./images-blog/wireguard.png
:END:

Ya hemos visto como instalar  Wireguard con los paquetes disponibles en la distro o añadiendo el repositorio del desarrollador. También os expliqué como crear el archivo de configuración del servidor y clientes con el script wgc.

#+HTML: <center>
[[./images-blog/wireguard.png]]
#+HTML: </center>

Hoy vamos a montar todo de una vez con docker, gracias nuevamente a la comunidad LinuxServer.io que nos lo pone pone muy muy fácil.

He seguido paralelamente también la documentación el artículo de Joan del blog de [[https://geekland.eu/instalar-y-configurar-el-servidor-vpn-wireguard-con-docker/][geekland.eu]], que me ha ayudado mucho.

** Crear el Docker
Creando el docker de wireguard, el servidor y peers:
- He puesto las DNS de  Cloudflare, 1.1.1.1 y Quad9 (IBM) 9.9.9.9.
- Vamos a generar solo *1* peer. Si quieres generar más, indica el número de peers que deseas
- El puerto para acceder al servidor, lo he desviado al 33555. Recuerda que si hacemos esto, cuando vayamos a utilizar los clientes, *el peer generado utilizará el puerto 51820 , así que deberemos modifiarlo a 33555*.


#+begin_src  shell
docker create   --name=wireguard   --cap-add=NET_ADMIN   --cap-add=SYS_MODULE   -e PUID=1000   -e PGID=1000   -e TZ=Europe/Madrid   -e SERVERURL=midominio.duckdns.org   -e SERVERPORT=51820   -e PEERS=1   -e PEERDNS=1.1.1.1,9.9.9.9    -e INTERNAL_SUBNET=10.13.13.0    -p 33555:51820/udp   -v $HOME/docker/wireguard/config:/config   -v /lib/modules:/lib/modules   --sysctl="net.ipv4.conf.all.src_valid_mark=1"   --restart unless-stopped   linuxserver/wireguard
#+end_src

** Clientes o Peers

Una vez levantado el docker de wireguard, podremos ver los código QR de los peers desde la terminal, para añadir a nuestro móvil.

#+begin_src
docker logs -f wireguard
#+end_src

*Toda la configuración tanto del servidor como los peers, está en el volumen que se ha creado con el contenedor* =$HOME/docker/wireguard/config=.

** Crear nuevos peers o clientes

Para crear nuevos peers, tan sencillo como:

#+begin_src
docker exec -it wireguard /app/add-peer
#+end_src

Nos creará un nuevo peer o cliente y previsualizará el código QR en pantalla

** Mostrar QR de un peer o cliente ya creado
Aunque como he comentado antes, toda la configuración tanto del servidor como los peers está en =$HOME/docker/wireguard/config=, también podemos previsualizarlo directamente desde la terminal con:

#+BEGIN_SRC
docker exec -it wireguard /app/show-peer 1
#+END_SRC

En este caso, estamos previsualizando el código QR del peer 1. Indica el número de peer que desees.

** Eliminar Peers o Clientes

Accederemos a nuestro volumen de configuración y eliminaremos directamente el peer que no deseemos

#+begin_src
cd $HOME/docker/wireguard/config
#+end_src

Borro el peer3
#+begin_src
rm -r peer3
#+end_src

Elimina en el archivo de configuración del servidor *wg0.conf*, los valores del peer eliminado

#+begin_src
nano wg0.conf
#+end_src

** Conclusión
Como veis, en menos de 5 minutos tenemos creada una vpn con docker de un modo seguro y sencillo.



* TODO Añadiendo texto al principio de cada línea en Emacs
:PROPERTIES:
:TITLE: Añadiendo texto al principio de cada línea en Emacs
:EXPORT_FILE_NAME: anadiendo-texto-al-principio-de-cada-linea-en-emacs
:DESCRIPTION: Como podéis imaginar, yo creo y edito mis scripts con Emacs. Hay momentos en los que quiero añadir "#" en un bloque de código para que no se ejecute, o
:EXPORT_DATE: 2020-10-24 20:25
:CATEGORY: emacs
:TAG: bash,script
:IMAGE: ./images-blog/emacs.png
:END:


Como podéis imaginar, yo creo y edito mis scripts con Emacs. Hay momentos en los que quiero añadir "#" en un bloque de código para que no se ejecute, o simplemente, añadir un comentario respecto al código.


Esto con emacs es muy sencillo.

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

Yo lo utilizo para los scripts, pero como puedes imaginar, puedes añadir a cada línea el texto que desees.

** Añadir texto al inicio de cada línea
1) Pulsa =Ctrl+Space= para seleccionar el texto
2) Ahora pulsa =C-x r t=. Equivale a =M-x string-rectangle=
3) Añade el texto que quieres añadir al inicio de cada línea

** Eliminar el texto al principio de cada línea
1) Selecciona el texto al principio de cada línea, con =C-x Space=
2) pulsa =suprimir=.

* TODO Borrando líneas en blanco de un texto con Emacs
:PROPERTIES:
:TITLE: Borrando líneas en blanco de un texto con Emacs
:EXPORT_FILE_NAME: borrando-lineas-en-blanco-de-un-texto-con-emacs
:DESCRIPTION: A veces cuando copio un documento en la terminal, lo hace dejando líneas en blanco entre líneas. Para eliminar esto con Emacs es muy sencillo:
:EXPORT_DATE: 2020-10-26 11:30
:CATEGORY: emacs
:TAG: terminal
:IMAGE: ./images-blog/emacs.png
:END:

A veces cuando copio un documento en la terminal, lo hace dejando líneas en blanco entre líneas. Para eliminar esto con Emacs es muy sencillo:

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>


1) Seleccionamos todo el contenido del buffer con =C-x h=
2) Introducimos: =M-x flush-lines= RET =^$= RET

=flush-lines= significa que limpia las líneas que coincidan con una expresión regular, en este caso del principio al final =^$=, lo que interpreta como lineas en blanco.




* TODO s-screen. Gestionando mis procesos en segundo plano de un modo sencillo
:PROPERTIES:
:TITLE: s-screen. Gestionando mis procesos en segundo plano de un modo sencillo
:EXPORT_FILE_NAME: s-screen-gestionando-mis-procesos-en-segundo-plano-de-un-modo-sencillo
:DESCRIPTION: Este artículo es una recopilación de los dos anteriores, dónde íntegro todo lo aprendido dentro de un script.
:EXPORT_DATE: 2020-10-28 18:45
:CATEGORY: bash
:TAG: screen
:IMAGE: ./images-blog/bash.png
:END:

Este artículo es una recopilación de los dos anteriores, dónde íntegro todo lo aprendido dentro de un script.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Recordar los comandos, a veces suele ser una tarea dura, así que si no te quieres calentar la cabeza, una solución sería el crear alias o mejor aún, como en este caso, englobar dentro todo de un script, donde además podremos gestionar las respuestas a modo de menú sin tener que introducir ningún texto en la terminal.

Rápido y sencillo

De todos los atajos que aprendimos, solo tenemos que recordar el de *Control + a + d*, para salir de la sesión.

** Instalación

El script está en GitHub, de manera que podemos instalarlo gracias a curl con este sencillo comando.

#+BEGIN_SRC
sudo curl -L https://raw.githubusercontent.com/uGeek/s-screen/main/s -o /usr/bin/s && sudo chmod +x /usr/bin/s
#+END_SRC


** Funcionamiento

A partir de ahora, utilizaremos la letra *s* en lugar, para ejecutar el script.

Paralelamente, si así lo deseas, también puedes utilizar screen. Este método no te obliga a utilizar sí o sí el script.




** Crear una nueva sesión
Hay dos modos de crear una nueva sesión.

*** Crear sesión

Igual que hacemos con screen, en lugar de utilizar la palabra screen para iniciar una nueva sesión, en este caso utilizaremos la letra *s.*

#+BEGIN_SRC
s
#+END_SRC

*** Crear sesión con nombre

Para crear una nueva sesión y además nombrarla, utilizaremos el comando:

#+BEGIN_SRC
s n
#+END_SRC


recuerda que para salir de la sesión tienes que utilizar el atajo, control + a + d.

** Listar sesiones

Para listar las sesiones que están corriendo en este momento, utilizaremos el comando.

#+BEGIN_SRC
s ls
#+END_SRC



** Cambiar nombre de una sesión

Una vez creada la sesión, hayas nombrado o no ésta, puedes cambiar el nombre o crear uno nuevo si previamente no lo has hecho.

Tan sencillo como utilizar el comando:

#+BEGIN_SRC
s n
#+END_SRC

** Entrar dentro de una sesión

Para entrar en una de las sesiones están corriendo, utilizaremos el comando

#+BEGIN_SRC
s i
#+END_SRC

Primero *s* coma listar a todas las sesiones que hay corriendo con un número delante, en produce el número de la sesión que quieres entrar y listo.

** Cerrar una sesión

Quizás lo te deseas es cerrar una sesión esté abierta con un proceso o no dentro.

Para ello utiliza el comando:

#+BEGIN_SRC
s k
#+END_SRC

nuevamente  para todas las sesiones numeradas, induce el número de la sesión que quieres cerrar.

** Ayuda

#+BEGIN_SRC
s h
#+END_SRC

** Conclusiones

Como puedes ver, de un modo sencillo podemos crear un script que nos permitan facilitarnos  poco vida y no tener que recordar complejos comandos.

Esto tengo que decir que crea dependencia del script, pero a la vez te hace disfrutar mucho más de la terminal.

También aquel que crea el script, lo disfruta muchísimo.

Espero que disfrutéis del script.
* TODO Nuevas DNS de CloudFlare
:PROPERTIES:
:TITLE: Nuevas DNS de Cloudflare
:EXPORT_FILE_NAME: nuevas-dns-de-cloudflare
:DESCRIPTION: Ahora se añade nuevos filtros a la familia de DNS CloudFlare.
:EXPORT_DATE: 2020-10-29 18:40
:CATEGORY: dns
:TAG: internet,web
:IMAGE: ./images-blog/cloudflare.png
:END:

Ahora se añade nuevos filtros a la familia de DNS CloudFlare.
#+HTML: <center>
[[./images-blog/cloudflare.png]]
#+HTML: </center>

** DNS sin filtros

CloudFlare sigue teniendo por defecto la  tradicional ruta de DNS 1.1.1.1

Esta dirección no tiene ningún filtro.

- 1.1.1.1

** Bloquear malware

Ahora CloudFlare añade dos nuevas DNS para filtrar el malware.

- 1.1.1.2
- 1.0.0.2

** Bloquear malware y contenido para adultos

Ideal como control parental, CloudFlare añade dos nuevas rutas de DNS para filtrar el malware y el contenido de sitios de adultos.

- 1.1.1.3
- 1.0.0.3

* TODO Jellyfin Skin Manager. Repositorio para cambiar el tema de tu Jellyfin
:PROPERTIES:
:TITLE: Jellyfin Skin Manager. Repositorio para cambiar el tema de tu Jellyfin
:EXPORT_FILE_NAME: jellyfin-skin-manager-repositorio-para-cambiar-el-tema-de-tu-jellyfin
:DESCRIPTION: Dado que la comunidad está creando muchos temas para jellyfin, cambiando el aspecto de nuestro servidor multimedia, un desarrollador ha decidido crear un repositorio dentro de las extensiones de jellyfin,
:EXPORT_DATE: 2020-11-15 18:20
:CATEGORY: jellyfin
:TAG: docker
:IMAGE: ./images-blog/jellyfin.png
:END:

Dado que la comunidad está creando muchos temas para jellyfin, cambiando el aspecto de nuestro servidor multimedia, un desarrollador ha decidido crear un repositorio dentro de las extensiones de jellyfin, para que sea mucho más sencillo cambiar los temas a tan solo un clic.

#+HTML: <center>
[[./images-blog/jellyfin.png]]
#+HTML: </center>

Tengo que decir que ya había creado un repositorio donde estaba recopilando todos estos skins, pero el poderlo tener en una extensión tal como implementó jellyfin en las últimas actualizaciones, lo hace todavía mucho más sencillo.

La instalación es muy sencilla.

** Instalación

1) En jellyfin, ves a Panel Control -> Extensiones -> Repositorios -> agregua y pegue este enlace

#+BEGIN_SRC
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
#+END_SRC

2) Ves al Catálogo y busqua Skin Manager

3) Haz clic en él, e instalalo
4) Reinicia Jellyfin
5) Vuelve a Extensiones -> Mis Extensiones, y selecciona el tema que más te guste

Cambia de aspecto Jellyfin y disfruta de todos los temas disponibles

** Fuentes
- https://github.com/danieladov/jellyfin-plugin-skin-manager
* TODO Docker: Telegram de terminal para Raspberry Pi y amd64
:PROPERTIES:
:TITLE: Docker: Telegram de terminal para Raspberry Pi y amd64
:EXPORT_FILE_NAME: docker-telegram-de-terminal-para-raspberry-pi-y-amd64
:DESCRIPTION: He creado un docker para poder utilizar Telegram desde tu terminal, ya estes en tu PC o Raspberry Pi.
:EXPORT_DATE: 2020-12-06 19:56
:CATEGORY: docker
:TAG: telegram
:IMAGE: ./images-blog/telegram.png
:END:

He creado un docker para poder utilizar Telegram desde tu terminal, ya estes en tu PC o Raspberry Pi.

#+HTML: <center>
[[./images-blog/telegram.jpg]]
#+HTML: </center>

** Dockers en dos versiones
*** Crear docker para amd64
#+BEGIN_SRC sh
docker create --name telegram-cli -e TZ=Europe/Madrid -v $HOME/docker/telegram-cli:/root/.telegram-cli ugeek/telegram-cli:amd64
#+END_SRC

*** Crear docker para arm y Raspberry Pi
#+BEGIN_SRC sh
docker create --name telegram-cli -e TZ=Europe/Madrid -v $HOME/docker/telegram-cli:/root/.telegram-cli ugeek/telegram-cli:arm
#+END_SRC

** Iniciar el docker

#+BEGIN_SRC
docker start telegram-cli
#+END_SRC

** Iniciar telegram-cli

#+BEGIN_SRC
docker exec -it telegram-cli telegram-cli -N -W
#+END_SRC

** Fuente
- https://hub.docker.com/r/ugeek/telegram-cli

* TODO Conectandose por SSH introduciendo la contraseña en una única línea de terminal
:PROPERTIES:
:TITLE: Conectándote por SSH introduciendo la contraseña en una única línea de terminal
:EXPORT_FILE_NAME: conectandote-por-ssh-introduciendo-la-contrasena-en-una-unica-linea-de-terminal
:DESCRIPTION: El mejor método para conectarse a un servidor por SSH, es enviando las llaves al servidor y no tener que estar introduciendo la contraseña.
:EXPORT_DATE: 2020-12-07 17:10
:CATEGORY: bash
:TAG: ssh
:IMAGE: ./images-blog/bash.png
:END:

El mejor método para conectarse a un servidor por SSH, es enviando las llaves al servidor y no tener que estar introduciendo la contraseña.

Aparte de ser más rápido y cómodo, es mucho más seguro, ya que enviando las llaves, también puedes deshabilitar el tener que introducir la contraseña.

Pero si por algún motivo no tienes la posibilidad de enviar las llaves al servidor, siempre puedes utilizar sshpass.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Sshpass es una herramienta que vienen todas las distros Linux pero no viene instalada por defecto y te permite el poder añadir en una única línea de terminal la dirección del servidor y la contraseña.

Cómo explicaba al inicio del artículo, es un método un poco inseguro ya que sí entra en el historial de todo aquello que hemos tecleado en la terminal o si añadimos esta opción en un script, queda de un modo visible la contraseña del servidor.

Vamos a ver cómo instalarlo y conocer algunos ejemplos.

** Instalación

En todas distro derivadas de Debian lo haremos del siguiente modo

#+begin_src sh
sudo apt install sshpass
#+end_src


** Utilizando sshpass

Conectarnos por ssh, suponiendo que nuestra ip es "192.168.1.100" y el usuario "pi", con la contraseña en una misma línea seria:

#+begin_src sh
sshpass -p 'contraseña' ssh pi@192.168.1.100
#+end_example


Para especificar un puerto, ejemplo puerto "9122"

#+begin_src sh
sshpass -p 'contraseña' ssh pi@192.168.1.100 -p 9122
#+end_src

* TODO Trilium. Notas jerárquicas en Markdown
:PROPERTIES:
:TITLE: Trilium. Notas jerárquicas en Markdown
:EXPORT_FILE_NAME: trilium-notas-jerarquicas-en-markdown
:DESCRIPTION: Quizás ha llegado el momento de tomar notas para seres humanos, voy a
:EXPORT_DATE: 2020-12-25 20:41
:CATEGORY: markdown
:TAG: servidor
:IMAGE: ./images-blog/trilium.png
:END:

Quizás ha llegado el momento de tomar notas para seres humanos, voy a
hablar de Trilum.

Trilium es un método jerárquico para tomar notas, tareas,... donde estás
se gestionan con un método jerarquico como el orgmode y las podemos
exportar a posterior a HTML, Markdown o incluso imprimirlas en pdf. 

#+HTML: <center>
[[./images-blog/trilium.png]]
#+HTML: </center>

El método para introducir el texto es mediante la sintaxis markdown.

He probado diferentes dockers para la arquitectura amd64 y ARM así que finalmente me quedo con él dockers oficial para amd64 y otro que he encontrado de "hlince" para arm, que funciona muy bien en Raspberry.

** Docker amd64

El docker oficial y más actualizado para amd64 es:

#+BEGIN_EXAMPLE
docker run -t -i --name=trilium -p 127.0.0.1:99:8080 -v ~/trilium:/root/trilium-data zadam/trilium
#+END_EXAMPLE

Servicio disponible por el puerto en este ejemplo 99.

- [[https://github.com/zadam/trilium/wiki/Docker-server-installation]]

Fork ugeek

#+BEGIN_EXAMPLE
docker run -t -i --name=trilium -p 127.0.0.1:99:8080 -v ~/trilium-data:/root/trilium-data ugeek/trilium:amd64
#+END_EXAMPLE

Servicio disponible por el puerto en este ejemplo 99.

** Docker para arm

Es docker-compose para arm o Raspberry y funciona a la perfeción:

#+BEGIN_EXAMPLE
trilium:
 image: hlince/trilium:latest-stable-arm
 restart: always
 ports:
  - 99:8080
 environment:
  - TRILIUM_DATA_DIR=/data
 volumes:
  - ./trilium/data:/data
#+END_EXAMPLE

- https://hub.docker.com/r/hlince/trilium

Fork de ugeek

#+BEGIN_EXAMPLE
trilium:
 image: ugeek/trilium:arm
 restart: always
 ports:
  - 99:8080
 environment:
  - TRILIUM_DATA_DIR=/data
 volumes:
  - ./trilium/data:/data
#+END_EXAMPLE

** Docker con Proxy Inverso con Traefik
#+BEGIN_SRC 
version: '3.7'
services:
  web:
    image: hlince/trilium:latest-stable-arm
    container_name: trilium
    environment:
      - TRILIUM_DATA_DIR=/data
    volumes:
      - ./trilium/data:/data  
    networks:
      - web
    labels:
      - traefik.port=8080
      - traefik.enable=true
      - traefik.frontend.rule=Host:trilium.midominio.duckdns.org
      - "traefik.entrypoints=https"
      - "traefik.docker.network=web"
      - "traefik.backend.loadbalancer.stickiness=true"
      - "traefik.backend.loadbalancer.swarm=true"
      - "traefik.backend=trilium"      
networks:                                                                                                                   
  web:
   external: true 
#+END_SRC
** Fuentes

- [[https://github.com/zadam/trilium]]
- https://www.electronjs.org/apps/trilium-notes



* TODO Trilium Web Clipper. Importando el contenido de una web a Trilium
:PROPERTIES:
:TITLE: Trilium Web Clipper. Importando el contenido de una web a Trilium
:EXPORT_FILE_NAME: trilium-web-clipper-importando-el-contenido-de-una-web-a-trilium
:DESCRIPTION: Trilium Web Clipper es una extensión del navegador web que permite al
:EXPORT_DATE: 2020-12-25 22:40
:CATEGORY: trilium
:TAG: markdown
:IMAGE: ./images-blog/web-clipper-trilium.png
:END:

Trilium Web Clipper es una extensión del navegador web que permite al
usuario recortar texto, capturas de pantalla, páginas enteras y notas
breves y guardarlas directamente en [[https://github.com/zadam/trilium][Trilium Notes]].

#+HTML: <center>
[[./images-blog/web-clipper-trilium.png]]
#+HTML: </center>


** Atajos de teclado

Los atajos de teclado están disponibles para la mayoría de las
funciones:

- Guardar el texto seleccionado: =Ctrl+Shift+S= (Mac: Cmd+Shift+S)
- Guardar toda la página: =Alt+Shift+S= (Mac: Opt+Shift+S)
- Guardar captura de pantalla: =Ctrl+Shift+E= (Mac: Cmd+Shift+E)

** Instalando Trilium Web Clipper en Firefox

Para instalarlo en Firefox, es tan sencillo como acceder al repositorio
en [[https://github.com/zadam/trilium-web-clipper/releases][GitHub]] y
haciendo click sobre el archivo *.xpi* lo descargaremos e instalaremos.

Después añadiremos la url y contraseña del Trilium de nuestro servidor.

Es genial porque permite el importar no solo el texto, sino que también
las imágenes.

** Instalando Trilium Web Clipper en Chrome

Podemos instalarlo con la extension disponible en el [[https://chrome.google.com/webstore/detail/trilium-web-clipper/dfhgmnfclbebfobmblelddiejjcijbjm?hl=en&authuser=0][Chrome Web Store]].

También podemos hacerlo desde el repositorio en [[https://github.com/zadam/trilium-web-clipper/releases][GitHub]] y haciendo click sobre el archivo .zip para chrome, lo descargaremos, crearemos un directorio y dentro de el descomprimiremos todo el contenido del archivo *.zip*.

- Ahora abriremos chrome accederemos a la url =chrome://extensions/shortcuts=
- En la parte superior derecha de la pantalla, accionaremos el *Modo de desarrollador*.
- Ahora en la parte superior izquierda, pulsaremos sobre *Modo de desarrollador*. Selecciona el directorio donde hemos descomprimido el archivo *.zip*


Ya está la extensión instalada en Google Chrome. Ahora solo queda
indicar la url y contraseña de nuestro servidor.

** Wiki

Para más detalles, siempre puedes consultar la
[[https://github.com/zadam/trilium/wiki/Web-clipper][wiki]]

** Fuentes

- [[https://github.com/zadam/trilium-web-clipper]]
- https://github.com/zadam/trilium-web-clipper/releases



* TODO Conectarse a una red Wifi desde la Terminal
:PROPERTIES:
:TITLE: Conectarse a una red Wifi desde la Terminal
:EXPORT_FILE_NAME: conectarse-a-una-red-wifi-desde-la-terminal
:DESCRIPTION: Estoy lejos de mi router y mi pc se ha desconectado de la Wi-Fi.  Ha
:EXPORT_DATE: 2020-12-26 21:38
:CATEGORY: wifi
:TAG: terminal
:IMAGE: ./images-blog/wifi.png
:END:


Estoy lejos de mi router y mi pc se ha desconectado de la Wi-Fi.  Ha
sido muy sencillo volver a conectarme, utilizando la terminal.

Como siempre he comentado,  aunque al principio puede dar un poco de
miedo la terminal, el conocerla un poco más a fondo te permite
comunicarte más directamente con tu máquina.

#+HTML: <center>
[[./images-blog/wifi.png]]
#+HTML: </center>


En este caso utilizar la terminal para conectarte a tu red Wi-Fi es
mucho más sencillo y rápido que hacerlo de forma gráfica.



En este artículo os explico de un modo sencillo cómo hacerlo.


** Conocer tu dispositivo Wifi
Introduciremos el comando

#+begin_example
iwconfig
#+end_example

El resultado será todos los dispositivos de red que tenemos en nuestra
máquina. Para filtrar el contenido solo de nuestra Wifi, podemos
utilizar grep.

#+begin_example
ip link sho | grep w
#+end_example

Antiguamente el resultado sería =wlan0=, ahora Ubuntu, Debian,... toma por defecto otro nombre aleatorio, en mi caso =wlp5s0=, pero vamos a considerar ahora en el tutorial que el nombre de mi dispositivo wifi es  =wlan0=.

** Activar tu tarjeta Wifi
Para activar tu tarjeta wifi:

#+begin_example
sudo iwconfig wlan0
#+end_example

** Conectarse a un punto de acceso Wifi
Introduciremos este comando, sustituyendo =nombre_punto_acceso= por tu
nombre de acceso, en este caso sería el nombre de tu red Wifi.

#+begin_example
iwconfig wlan0 essid nombre_punto_acceso
#+end_example

Si en un futuro se desconecta nuestra red wifi, sería tan fácil como
ejecutar este comando.



Ahora introduciremos nuestra contraseña

#+begin_example
iwconfig wlan0 essid nombre_punto_acceso key contraseña
#+end_example



** Ping para saber si tenemos internet
Vamos ha hacer un ping a los servidores de cloudflare.

#+begin_example
ping 1.1.1.1
#+end_example
* TODO i3wm en Ubuntu, Debian, Raspbian,... desde 0
:PROPERTIES:
:TITLE: i3wm en Ubuntu, Debian, Raspbian,... desde 0
:EXPORT_FILE_NAME: i3wm-en-ubuntu-debian-raspbian---desde-0
:DESCRIPTION: En Debian, Ubuntu, Raspbian,... por defecto no hay una distro con el
:EXPORT_DATE: 2020-12-28 16:30
:CATEGORY: i3wm
:TAG: escritorio,debian,ubuntu,raspberry
:IMAGE: ./images-blog/i3wm.png
:END:

En Debian, Ubuntu, Raspbian,... por defecto no hay una distro con el
gestor de ventanas de i3wm, pero eso no significa que podamos construir
desde cero nuestro entorno.

#+HTML: <center>
[[./images-blog/i3wm.png]]
#+HTML: </center>

Si no quieres complicarte la vida, puedes instalar una Debian,
Ubuntu,... con un escritorio LXDE y después, con un simple
=sudo apt install i3=, cuando arranques tu ordenador, te dará a elegir
entre LXDE y i3. Vamos, que prácticamente viene todo hecho.

El punto positivo de este método, es que te instalará una serie de
aplicaciones, digamos un poco de todo y te evitas este proceso. El punto
negativo, es que probablemente, el 90% de las aplicaciones que acabas de
instalar, para ti no son necesarias.

Así que el objetivo de este artículo es instalar desde cero un entorno
i3wm.

** Instalar i3wm
Vamos a instalar i3wm

#+begin_example
sudo apt install xorg lightdm i3-wm i3status suckless-tools
#+end_example

Ahora, si reiniciemos, ya tendríamos listo nuestro escritorio para
trabajar, pero antes vamos a instalar alguna cosa mas que nos será útil.

i3blocks nos permite mejorar y personalizar la barra de i3wm.

Para instalarlo

#+begin_example
sudo apt install i3blocks
#+end_example

Sensores de temperatura con i3blocks

#+BEGIN_SRC 
sudo apt install lm-sensors
#+END_SRC


** Rofi
Rofi es un lanzador de aplicaciones muy liviano y configurable. En breve
hablaré mas en profundizad de él.

#+begin_example
sudo apt install rofi
#+end_example

** pcmanfm
pcmanfm es un explorador de archivos muy ligero.

#+begin_example
sudo apt install pcmanfm
#+end_example


** Conclusión
Este sería el método para instalar el escritorio i3wm de un modo limpio
partiendo desde una Debian de servidor.

El punto positivo, es que estas construyendo tu entorno desde cero y sin
ningún software innecesario por defecto.

De todas maneras, si nunca has utilizado i3wm, te recomiendo que partas
de un escritorio como LXDE, ya que puede que al principio te encuentres
en un callejón sin salida.


* TODO Grabar lo que suena en tu ordenador
:PROPERTIES:
:TITLE: Grabar lo que suena en tu ordenador
:EXPORT_FILE_NAME: grabar-lo-que-suena-en-tu-ordenador
:DESCRIPTION: La intención es grabar los chats de voz de Telegram en mi PC, pero... ¿Cómo podría hacerlo?
:EXPORT_DATE: 2020-12-30 15:30
:CATEGORY: audio
:TAG: musica
:IMAGE: ./images-blog/altavoz.png
:END:

La intención es grabar los chats de voz de Telegram en mi PC, pero... ¿Cómo podría hacerlo?
#+HTML: <center>
[[./images-blog/altavoz.png]]
#+HTML: </center>

** Instalación de Configuración de Pulseaudio
Instalamos el *control de volumen de PulseAudio* si no lo tenemos
instalado en nuestra máquina.

#+begin_example
sudo apt install pavucontrol
#+end_example

Para lanzarla con Rofi u otro lanzador, utilizaremos el nombre de *Control de volumen de PulseAudio*.


** Grabar lo que suena en el ordenador

1) Abrimos *Configuración de Pulseaudio y Audacity.*
2) Vamos al navegador o programa del que deseamos grabar e iniciamos la reproducción de audio
3) Iniciamos la grabación en *Audacity*
4) Vamos al programa de   *Configuración de Pulseaudio* y accedemos a la pestaña grabación.
5) Saldrá que hay una aplicación grabando sonido "Audacity" y podremos. *elegir la fuente que le queremos pasar a Audacity para que la grabe.*
* TODO Launchers opensource para Android. Personalizando tu móvil
:PROPERTIES:
:TITLE: Launchers opensource para Android. Personalizando tu móvil
:EXPORT_FILE_NAME: launchers-opensource-para-android
:DESCRIPTION: Si compras dispositivos de diferentes marcas, como pueden ser Samsung, Xiaomi, Huawei, etcétera,... es posible que vayas un poco perdido a la hora de utilizar tu dispositivo móvil, ya que
:EXPORT_DATE: 2020-12-30 23:50
:CATEGORY: android
:TAG: launchers
:IMAGE: ./images-blog/olauncher.png
:END:


Si compras dispositivos de diferentes marcas, como pueden ser Samsung, Xiaomi, Huawei, etcétera,... es posible que vayas un poco perdido a la hora de utilizar tu dispositivo móvil, ya que las aplicaciones se muestran de un modo diferente y con iconos totalmente diferentes. Para mí esto no es práctico así que habituo utilizar launcher para unificar la experiencia en todos mis dispositivos.


#+HTML: <center>
[[./images-blog/olauncher.png]]
#+HTML: </center>


Los launcher son unas aplicaciones disponibles en los dispositivos Android, que permiten personalizar y lanzar las aplicaciones de un modo diferente.

Digamos que es una especie de cómo personalizar el escritorio de tu dispositivo móvil.

Hay Launcher míticos como Nova Launcher, que te ofrecen una experiencia de usuario más parecida a Android puro.


Después hay otros muchísimos más complejos. Pero como sabéis que me encanta el software libre, voy a mostraros tres de los launchers open source que está utilizando últimamente y con cuál me decido quedar al final.

Para ser sincero, la elección va por épocas. Así que eres tú el que tiene la última palabra, y qué tipo de launcher quieres utilizar.

** Lawnchair Launcher
Aunque un poco desactualizado en el momento de escribir este artículo, Lawnchair es la opción más parecida a utilizar Android puro, pero con más personalización y vitaminado.

Puedes personalizar el dock, habilitar gestos, de manera que puedes abrir aplicaciones en función de los gestos que utilices... personalizar el tamaño de los iconos. Añade una opción para instalar una pequeña extensión que te permita el deslizando hacia la derecha como sucede con Android puro, el poder ver los feeds de tu cuenta Google.

Lo que más me gusta de este launcher aparte de ser opensource, es que te permite exportar todo aquello que configures, de manera que puedes utilizarlo en otro dispositivo puedes importar esa configuración y tener ambos dispositivos exactamente igual, permitiendo el fácil uso de tu dispositivo.

Si no te gusta la capa de personalización de tu dispositivo móvil y quieres utilizar una interfaz más Android puro,  esta es una gran opción.

Instalación disponible en su versión 2, únicamente en Google Play Store.

** Olauncher
Si lo que buscas el minimalismo y centrarte únicamente en la productividad, Olauncher es tu launcher.

Actualmente es el launcher que estoy utilizando y la verdad es que me he acostumbrado bastante rápido a él.

Es un poco diferente ya que no vamos a poder ver iconos como sucede con la gran mayoría de los launchers, pero por otra parte te permite el poder centrarte exclusivamente a utilizar aquellas aplicaciones que realmente utiliza.

Cuando lleves una semana, te darás cuenta de que solo utilizas un 5% de las aplicaciones que tienes instaladas en tu dispositivo, de manera que puedes desinstalar aquellas aplicaciones que no utilizas ahorrando, espacio y batería.

Pero vamos a centrarnos en el funcionamiento de este launcher y qué ventajas trae respecto a otras alternativas.

De salida solo te permite mostrar un máximo de 8 aplicaciones en la pantalla principal. Esto significa que tendrás que descartar un gran número de aplicaciones que tengas instaladas y decidir cuáles son realmente las 8 más importantes. Hay que tener en cuenta que el desarrollador ha ampliado hasta 8, en versiones anteriores recuerdo que estaba del orden de las tres a cinco aplicaciones.


Estas aplicaciones se mostraran solo con texto, nada de iconos.

Pero... ¿Qué sucede con el resto de aplicaciones?. Deslizando hacia arriba con el dedo, abrirá el equivalente a abrir el cajón de aplicaciones, pero todas estas aplicaciones aparecerán en formato texto, o sea el nombre de la aplicación. Nada de iconos.

En la parte inferior se abrirá también el teclado, de manera que tal como vayamos escribiendo el nombre de la aplicación, ir a filtrando Olauncher todas las aplicaciones que tenemos y cuando coincida las letras que estamos introduciendo con la aplicación que buscamos, se abrirá esta de forma automática.

Vámos, que en lugar de recordar las imágenes de los iconos, tendrás que recordar el nombre de la aplicación. De salida parece complejo, pero os puedo asegurar que el uso de este modo de lanzar aplicaciones es muchísimo más rápido que buscar un icono.

Dispone de 4 gestos personalizables. Por defecto si deslizas a la izquierda o derecha se abre la aplicación de llamadas de teléfono y la cámara de fotos.

Pero como comento, es totalmente personalizable. En mi caso he añadido la aplicación Feedme para acceder a FreshRSS y deslizando de derecha izquierda, abre la aplicación de Plus Messenger.

La opción de teléfono y cámara las he puesto entre las 8 aplicaciones más utilizadas en la pantalla principal.

Si deslizas hacia abajo, se despliega la barra de notificaciones.

Cómo puedes imaginar, este lanzador lo que permite es tener una pantalla totalmente limpia con únicamente las 8 aplicaciones que comentaba al principio la hora y fecha. Las 8 aplicaciones podemos ponerlas a la parte izquierda o derecha de la pantalla. Todo el rato hablo de eso aplicaciones, pero esto es totalmente personalizable. Esto quiere decir que si solo quieres utilizar dos tres o cinco puedes hacerlo también.

Finalmente dos características que me parecen también bastante interesantes.

Permitiendo el acceso a Internet a este launcher, existe la posibilidad de descargar un fondo de escritorio diferente cada día.

También dispone de la opción, que mediante un doble toque en pantalla, bloquee el dispositivo. De esta manera no será necesario esperar al tiempo de bloqueo de pantalla o pulsar el botón de bloqueo.

Se me olvidaba que este launcher, como puedes imaginar, no permite utilizar widget.

La instalación está disponible en f-droid y Play Store
- https://f-droid.org/packages/app.olauncher

** Posidon Launcher

Otro concepto totalmente diferente de launcher. Este Launcher se basa en que todas las notificaciones que va recibiendo tu dispositivo móvil, aparecen en el la pantalla de escritorio y y tú mediante un gesto de izquierda a derecha o derecha izquierda vas quitando estas.

El punto positivo de este launcher es que te garantiza que no vas a perder ninguna de las notificaciones que recibas.

Es bastante personalizable y permite el añadir fuentes de RSS, de manera que entre medio de las notificaciones recibirás noticias o publicaciones de tus blogs favoritos.

También permite poder exportar toda configuración te hagas y de esta manera, poder importarlo en otro dispositivo.

Respecto a la versión anterior que utilicé hace unos meses, ha evolucionado mucho. Pero en esta última versión he visto que tenía un poco de lag. Es un proyecto muy interesante y hay que darle un poco de tiempo a que avance su desarrollo.

Instalación disponible en f-droid y Google Play Store.

- https://f-droid.org/packages/posidon.launcher

** Conclusiones
En este punto de madurez del sistema operativo Android, como puedes ver, hay muchas alternativas de launchers opensource y ya no es necesario utilizar exclusivamente la capa de personalización que trae por defecto el dispositivo comprado de fábrica.

** Fuentes
- https://github.com/LawnchairLauncher/Lawnchair
- https://github.com/tanujnotes/Olauncher
- https://github.com/lposidon/posidonLauncher
* TODO Crear una imagen docker desde un repositorio de GitHub
:PROPERTIES:
:TITLE: Crear una imagen docker desde un repositorio de GitHub
:EXPORT_FILE_NAME: crear-una-imagen-docker-desde-un-repositorio-de-github
:DESCRIPTION: Existe la posibilidad de crear imágenes para contenedores Docker, desde un repositorio de GitHub  a partir de un Dockerfile.
:EXPORT_DATE: 2021-01-02 17:30
:CATEGORY: docker
:TAG: imagen
:IMAGE: ./images-blog/docker.png
:END:

Existe la posibilidad de crear imágenes para contenedores Docker, desde un repositorio de GitHub  a partir de un Dockerfile.
#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>


** Creando una imagen
En este ejemplo, utilizaré el nombre de *ugeek* cómo propietario de la imagen para posteriormente subirla al dockerhub, *contenedor* es el nombre del contenedor y *arm* la etiqueta. En este caso coincide la etiqueta con la arquitectura.

Seguidamente, añadiremos la URL del repositorio en GitHub sin utilizar el https.

#+begin_example
docker build -t="ugeek/contenedor:arm" github.com/ugeek/contenedor
#+end_example

* TODO Mi alternativa a Nextcloud como nube. Filebrowser, WebDav y Syncthing
:PROPERTIES:
:TITLE: Mi alternativa a Nextcloud como nube. Filebrowser, WebDav y Syncthing
:EXPORT_FILE_NAME: mi-alternativa-a-nextcloud-como-nube-filebrowser-webdav-y-syncthing
:DESCRIPTION: Siempre he comentado que una nube como Nextcloud para solo acceder o sincronizar archivos es muy pesada. Existen otros proyectos, mucho más ligeros con lenguajes de programación mucho más modernos,
:EXPORT_DATE: 2021-01-03 15:10
:CATEGORY: nube
:TAG: syncthing,filebrowser,webdav
:IMAGE: ./images-blog/nube.png
:END:




Siempre he comentado que una nube como Nextcloud para solo acceder o sincronizar archivos es muy pesada. Existen otros proyectos, mucho más ligeros con lenguajes de programación mucho más modernos, por ejemplo en GO como FileBrowser.

El objetivo por mi parte, ha sido el sumar lo mejor de 2 servicios. 

1) Mi servidor webdav que utilizo a diario
2) Anadir una interfaz web, para no estar obligado a utilizar un cliente de administración.

#+HTML: <center>
[[./images-blog/nube.png]]
#+HTML: </center>

FileBrowser es la herramienta que nos permitirá visualizar nuestros archivos y directorios, a través de un navegador web. FileBrowser no tiene aplicación, es única y exclusivamente para utilizarla desde un navegador web. Eso significa que allá donde haya un navegador web, podremos acceder a nuestros archivos. En dispositivos móviles y tablets, FileBrowser se adapta perfectamente a todo tipo de pantalla, así que es un servicio fantástico. Webdav es el servicio para sincronizar mis archivos con aplicaciones como *SimpleTask*, *Orgzly*, *FolderSync*, *X-plore*, *Solid Explorer* o *Pure Writer*. También envío *backups* y accedo a archivos con *rclone*.

FileBrowser tiene una función para compartir archivos o directorios con cualquier persona mediante un link que podemos determinar una duración de validez para su descarga.

FileBrowser también permite crear tantos usuarios como queramos, pero si queremos combinar esta función con *WebDav*, entonces necesitaremos crear tantos servidores WebDav como usuarios lo necesiten y dirigir el directorio donde estarán los archivos, en mi ejemplo =/webdav=, por el directorio del usuario de FileBrowser.

FileBrowser + WebDav es la apuesta ganadora como servicios super livianos y sencillos. Podemos ampliar esta apuesta incluyendo algún directorio de nuestra nube mediante *Syncthing*. En mi caso, no he añadido esta opción en la primera parte del artículo, para no complicar más el tutorial. Lo que está claro, es que es muy recomendable utilizar *docker-compose*, para esta tarea ya que permite ir incluyendo servicios dentro de nuestra nube igual que lo hariamos con Nextcloud y ganar en diversidad, funcionalidades y potencia.

Partiendo de que el directorio =/webdav= es compartido con el servicio *FileBrowser* y *Webdab*,  personalmente recomiendo ir añadiendo servicios enlazados a determinados directorios como:

- Radicale (Calendarios, tareas, contactos)
- Navidrome (Servidor de música)
- Jellyfin (Servidor multimedia. Películas, Música, Libros,...)
- Syncthing (Sincronización de directorios. Sincronizo mis fotos y dotfiles)

Como he comentado antes, el directorio donde irán los archivos de la nube será =/webdav=. Yo he decidido que sea esta, pero tu puedes personalizarlo al directorio que desees.

** Iniciando

Vamos a clonar el repositorio que tengo en GitHub, donde están los archivos de configuración para Filebrowser para que persista la configuración una vez actualicemos el docker.

#+BEGIN_EXAMPLE
git clone https://github.com/uGeek/docker-filebrowser.git
#+END_EXAMPLE

** Docker-cli

** Filebrowser para ARM

Inicia el docker desde el repositorio que hemos clonado de GitHub. Este directorio es donde se guardarán la configuración y base de datos de FileBrowser.

#+BEGIN_EXAMPLE
docker run --name filebrowser         -v  /webdav:/srv         -v  $PWD/filebrowser.db:/database.db         -v  $PWD/filebrowser.json:/.filebrowser.json         -p  80:80         filebrowser/filebrowser:pi
#+END_EXAMPLE

- Username: admin
- Password: admin

*Si da error el arranque del docker, crea una nueva base de datos en blanco filebrowser.db*

#+BEGIN_EXAMPLE
touch filebrowser.db
#+END_EXAMPLE

*** WebDav para ARM

#+BEGIN_EXAMPLE
docker run --name webdav       --restart=unless-stopped       -p 80:80       -v /webdav:/media       -e USERNAME=webdav       -e PASSWORD=webdav       -e TZ=Europe/Madrid        -e UDI=1000       -e GID=1000       -d  ugeek/webdav:arm
#+END_EXAMPLE

- Username: webdav
- Password: webdav
- port: 80
- root path: /webdav
- --restart=unless-stopped : siempre que iniciemos la máquina se inicia el docker a menos que lo detengamos

** Filebrowser para amd64

Inicia el docker desde el repositorio que hemos clonado de GitHub. Este directorio es donde se guardarán la configuración y base de datos de FileBrowser.

#+BEGIN_EXAMPLE
docker run --name filebrowser         -v  /webdav:/srv         -v  $PWD/filebrowser.db:/database.db         -v  $PWD/filebrowser.json:/.filebrowser.json         -p  80:80         filebrowser/filebrowser
#+END_EXAMPLE

- Username: admin
- Password: admin

*Si da error el arranque del docker, crea una nueva base de datos en blanco filebrowser.db*

#+BEGIN_EXAMPLE
touch filebrowser.db
#+END_EXAMPLE

- Fuente: [[https://filebrowser.org/installation]]

** WebDav para amd64

#+BEGIN_EXAMPLE
docker run --name webdav       --restart=unless-stopped       -p 80:80       -v /webdav:/media       -e USERNAME=webdav       -e PASSWORD=webdav       -e TZ=Europe/Madrid        -e UDI=1000       -e GID=1000       -d  ugeek/webdav:amd64
#+END_EXAMPLE

- Username: webdav
- Password: webdav
- port: 80
- root path: /webdav
- --restart=unless-stopped : siempre que iniciemos la máquina se inicia el docker a menos que lo detengamos

** Docker Compose

Si vas a utilizar docker-compose para levantar ambos servicios, renombra el archivos [[https://github.com/uGeek/docker-filebrowser/commit/e5a1c4c4eeb5cf44bde7dceddcb32f7ce24f442b][docker-compose_filebrowser+webdav.yml]]  por docker-compose.yml.

En este caso, voy a utilizar como ejemplo de dominio *ugeek* en duckdns.org. Vamos a utilizar *sed* para sustituir la palabra *dominio* por *ugeek*. También lo puedes hacer manualmente desde el docker-compose.yml

#+BEGIN_EXAMPLE
sed -i s'|dominio|ugeek|'g docker-compose.yml
#+END_EXAMPLE

- Pon tu dominio si no tienes duckdns.org en las tres lineas donde está =filebrowser.dominio.duckdns.org= y =webdav.dominio.duckdns.org=.

** Ajustes de Webdav

- Añade en el docker webdav el *usuario*, *contraseña* y *zona horaria*.
- Los archivos irán al directorio =/webdav=, pero puedes utilizar el que tu desees, simplemente cambiandolo

** Ajustes de FileBrowser

Inicia el docker desde el repositorio que hemos clonado de GitHub. Este directorio es donde se guardarán la configuración y base de datos de FileBrowser.

- Username: admin
- Password: admin

*Si da error el arranque del docker, crea una nueva base de datos en blanco filebrowser.db*

#+BEGIN_EXAMPLE
touch filebrowser.db
#+END_EXAMPLE

Ya está listo todo para levantar el docker.

** Docker para arm y Raspberry Pi

#+BEGIN_EXAMPLE
version: '3'
 services:
  filebrowser:
   image: filebrowser/filebrowser:pi
   container_name: filebrowser
   restart: unless-stopped
   volumes:
    - /webdav:/srv
    - $PWD/filebrowser.db:/database.db
    - $PWD/filebrowser.json:/.filebrowser.json
  webdav:
   container_name: webdav
   image: ugeek/webdav:arm
   restart: unless-stopped
    volumes:
    - /webdav:/media
   environment:
    - USERNAME=usuario
    - PASSWORD=contraseña
    - UID=1000
    - GID=1000
    - TZ=Europe/Madrid
#+END_EXAMPLE

*** Proxy inverso con traefik

#+BEGIN_EXAMPLE
version: '3'
 services:

  filebrowser:
   image: filebrowser/filebrowser:pi
   container_name: filebrowser
   restart: unless-stopped
   volumes:
    - /webdav:/srv
    - $PWD/filebrowser.db:/database.db
    - $PWD/filebrowser.json:/.filebrowser.json
   networks:
    - web
   labels:
    - "traefik.backend=filebrowser"
    - "traefik.docker.network=web"
    - "traefik.enable=true"
    - "traefik.port=80"
    - "traefik.default.protocol=http"
    - "traefik.frontend.rule=Host:filebrowser.dominio.duckdns.org"
    - "traefik.frontend.headers.SSLHost=filebrowser.dominio.duckdns.org"
    - "traefik.frontend.headers.SSLRedirect=true"
    - "traefik.frontend.headers.SSLForceHost=true"
    
  webdav:
   container_name: webdav
   image: ugeek/webdav:arm
   restart: unless-stopped
   volumes:
    - /webdav:/media
   environment:
    - USERNAME=usuario
    - PASSWORD=contraseña
    - UID=1000
    - GID=1000
    - TZ=Europe/Madrid
   networks:
    - web
   labels:
    - traefik.backend=webdav
    - traefik.frontend.rule=Host:webdav.dominio.duckdns.org
    - traefik.docker.network=web
    - traefik.port=80
    - traefik.enable=true
    # Adding in secure headers
    - traefik.http.middlewares.securedheaders.headers.forcestsheader=true
    - traefik.http.middlewares.securedheaders.headers.sslRedirect=true
    - traefik.http.middlewares.securedheaders.headers.STSPreload=true
    - traefik.http.middlewares.securedheaders.headers.ContentTypeNosniff=true
    - traefik.http.middlewares.securedheaders.headers.BrowserXssFilter=true
    - traefik.http.middlewares.securedheaders.headers.STSIncludeSubdomains=true
    - traefik.http.middlewares.securedheaders.headers.stsSeconds=63072000
    - traefik.http.middlewares.securedheaders.headers.frameDeny=true
    - traefik.http.middlewares.securedheaders.headers.browserXssFilter=true
    - traefik.http.middlewares.securedheaders.headers.contentTypeNosniff=tru
   networks:
   web:
   external: true
   
#+END_EXAMPLE

*** Docker para amd64

#+BEGIN_EXAMPLE
version: '3'
services:

filebrowser:
image: filebrowser/filebrowser
container_name: filebrowser
restart: unless-stopped
volumes:
- /webdav:/srv
- $PWD/filebrowser.db:/database.db
- $PWD/filebrowser.json:/.filebrowser.json

webdav:
container_name: webdav
image: ugeek/webdav:amd64
restart: unless-stopped
volumes:
- /webdav:/media
environment:
- USERNAME=usuario
- PASSWORD=contraseña
- UID=1000
- GID=1000
- TZ=Europe/Madrid
#+END_EXAMPLE

*** Proxy inverso con traefik

#+BEGIN_EXAMPLE
version: '3'
services:

filebrowser:
image: filebrowser/filebrowser
container_name: filebrowser
restart: unless-stopped
volumes:
- /webdav:/srv
- $PWD/filebrowser.db:/database.db
- $PWD/filebrowser.json:/.filebrowser.json
networks:
- web
labels:
- "traefik.backend=filebrowser"
- "traefik.docker.network=web"
- "traefik.enable=true"
- "traefik.port=80"
- "traefik.default.protocol=http"
- "traefik.frontend.rule=Host:filebrowser.dominio.duckdns.org"
- "traefik.frontend.headers.SSLHost=filebrowser.dominio.duckdns.org"
- "traefik.frontend.headers.SSLRedirect=true"
- "traefik.frontend.headers.SSLForceHost=true"

webdav:
container_name: webdav
image: ugeek/webdav:amd64
restart: unless-stopped
volumes:
- /webdav:/media
environment:
- USERNAME=usuario
- PASSWORD=contraseña
- UID=1000
- GID=1000
- TZ=Europe/Madrid
networks:
- web
labels:
- traefik.backend=webdav
- traefik.frontend.rule=Host:webdav.dominio.duckdns.org
- traefik.docker.network=web
- traefik.port=80
- traefik.enable=true
# Adding in secure headers
- traefik.http.middlewares.securedheaders.headers.forcestsheader=true
- traefik.http.middlewares.securedheaders.headers.sslRedirect=true
- traefik.http.middlewares.securedheaders.headers.STSPreload=true
- traefik.http.middlewares.securedheaders.headers.ContentTypeNosniff=true
- traefik.http.middlewares.securedheaders.headers.BrowserXssFilter=true
- traefik.http.middlewares.securedheaders.headers.STSIncludeSubdomains=true
- traefik.http.middlewares.securedheaders.headers.stsSeconds=63072000
- traefik.http.middlewares.securedheaders.headers.frameDeny=true
- traefik.http.middlewares.securedheaders.headers.browserXssFilter=true
- traefik.http.middlewares.securedheaders.headers.contentTypeNosniff=tru
networks:
web:
external: true
#+END_EXAMPLE

** Syncthing

También es posible sincronizar con el exterior de nuestra nube gracias a Syncthing. He tomado de ejemplo dos directorios dentro de /webdav llamado *Fotos* y *dotfiles,* pero puedes sincronizar tantos directorios como quieras. Incluso, sincronizar absolutamente todo.

Añade al docker-compose.yml anteriores, estas líneas si quieres añadir *Syncthing*.

#+BEGIN_EXAMPLE
syncthing:
image: ghcr.io/linuxserver/syncthing
container_name: syncthing
environment:
- PUID=1000
- PGID=1000
- TZ=Europe/Madrid
volumes:
- $HOME/syncthing/config:/config
- /webdav/Fotos:/webdav/Fotos              ## Directorio a sincronizar
- /webdav/dotfiles:/webdav/dotfiles        ## Directorio a sincronizar
ports:
- 8384:8384
- 22000:22000
- 21027:21027/udp
restart: unless-stopped
#+END_EXAMPLE

** Fuentes

- [[https://github.com/filebrowser/filebrowser]]
- [[https://hub.docker.com/r/ugeek/webdav]]
- https://www.freepik.es/foto-gratis/conexion-red-computacion-nube-papel-perforado_2761244.htm#page=1&query=cloud%20computing&position=13

* TODO Montar un directorio en otro directorio
:PROPERTIES:
:TITLE: Montar un directorio en otro directorio
:EXPORT_FILE_NAME: montar-un-directorio-en-otro-directorio
:DESCRIPTION: Es posible que tengas un directorio en una ubicación que no te gusta, o que te sea más práctico tenerlo a mano en otro lugar y no puedas moverlo.
:EXPORT_DATE: 2021-01-04 13:05
:CATEGORY: bash
:TAG: zsh,fish
:IMAGE: ./images-blog/bash.png
:END:


Es posible que tengas un directorio en una ubicación que no te gusta, o que te sea más práctico tenerlo a mano en otro lugar y no puedas moverlo.

A mi me sucede con mi servicio de webdav. Quiero añadir temporal mente el directorio de música para editar unos archivos, pero no quiero que este directorio cambie de ruta porque estoy corriendo en el directorio de música otro servicio.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


En definitiva, vamos a tener 2 directorios en nuestro host exactamente iguales,  los archivos son los mismo, pero podremos acceder desde dos rutas.

Vamos a ver como hacer esto. 

** Con un enlace simbólico

Es el método que menos me gusta, a veces los dockers no pueden leer desde enlaces simbólicos. 

#+BEGIN_EXAMPLE
ln -s /webdav/Música /home/angel/Música
#+END_EXAMPLE

** Con mount

Este me gusta mucho más y tenemos que ejecutarlo como root

#+BEGIN_EXAMPLE
sudo mount --bind /webdav/Música /home/angel/Música
#+END_EXAMPLE

Para desmontarlo

#+BEGIN_EXAMPLE
sudo umount /home/angel/Música
#+END_EXAMPLE

Este último método, podríamos añadirlo en un script con cron, montando y desmontando cuando lo deseemos.
* TODO Docker: Ctop. El portanier de terminal
:PROPERTIES:
:TITLE: Docker: Ctop. El portanier de terminal
:EXPORT_FILE_NAME: docker-ctop-el-portanier-de-terminal
:DESCRIPTION: ctop proporciona una descripción general concisa y condensada de métricas en tiempo real de tus contenedores. Puedes ver el consumo de cpu, ram, datos de subida y bajada...
:EXPORT_DATE: 2021-01-05 05:15
:CATEGORY: docker
:TAG: bash,zsh
:IMAGE: ./images-blog/ctop.gif
:END:


ctop proporciona una descripción general concisa y condensada de métricas en tiempo real de tus contenedores. Puedes ver el consumo de cpu, ram, datos de subida y bajada...

#+HTML: <center>
[[./images-blog/ctop.gif]]
#+HTML: </center>


También puedes detener, iniciar, ver logs o borrar un contenedor entre ostras  cosas.

Viendo una imagen de como se ve en la terminal, da ganas de probarlos.

Para ver el rendimiento de los Dockers, me parece una herramienta fantástica.

** Docker para ARM

#+BEGIN_EXAMPLE
docker run --rm -it --name ctop --volume /var/run/docker.sock:/var/run/docker.sock:ro jinnlynn/ctop
#+END_EXAMPLE

En raspberry, crea un alias con el comando *ctop*.

#+BEGIN_EXAMPLE
alias ctop='docker run --rm -it --name ctop --volume /var/run/docker.sock:/var/run/docker.sock:ro jinnlynn/ctop'
#+END_EXAMPLE

** Docker para amd64

#+BEGIN_EXAMPLE
docker run --rm -it --name ctop     --volume /var/run/docker.sock:/var/run/docker.sock:ro     quay.io/vektorlab/ctop:latest
#+END_EXAMPLE

*** crea un alias con el comando *ctop*.

#+BEGIN_EXAMPLE
alias ctop='docker run --rm -it --name ctop     --volume /var/run/docker.sock:/var/run/docker.sock:ro     quay.io/vektorlab/ctop:latest'
#+END_EXAMPLE

** Uso

ctop no requiere argumentos y utiliza variables de host de Docker de forma predeterminada. Consulta los [[https://github.com/bcicen/ctop/blob/master/_docs/connectors.md][conectores]] para obtener más opciones de configuración.

*** Archivo de configuración

Mientras se ejecuta, use =S= para guardar los filtros actuales, el campo de clasificación y otras opciones en una ruta de configuración predeterminada ( =~/.config/ctop/config=en sistemas XDG, de lo contrario =~/.ctop=).

Los valores del archivo de configuración se cargarán y aplicarán la próxima vez que =ctop=se inicie.

*** Atajos de teclado

| Llave | Acción                                                                                   |
|-------+------------------------------------------------------------------------------------------|
| enter | Abrir menú contenedor                                                                    |
| a     | Alternar la visualización de todos los contenedores (en ejecución y no en ejecución)     |
| f     | Filtrar los contenedores mostrados ( =esc=para limpiarlos cuando estén abiertos)         |
| H     | Alternar encabezado ctop                                                                 |
| h     | Abrir diálogo de ayuda                                                                   |
| s     | Seleccionar campo de clasificación de contenedores                                       |
| r     | Orden de clasificación de contenedores inverso                                           |
| o     | Abrir vista única                                                                        |
| l     | Ver registros de contenedores ( =t=para alternar la marca de tiempo cuando está abierto) |
| e     | Exec Shell                                                                               |
| c     | Configurar columnas                                                                      |
| S     | Guardar la configuración actual en un archivo                                            |
| q     | Salir de ctop                                                                            |

** Fuentes

- [[https://geekland.eu/monitorizar-el-rendimiento-de-contenedores-docker/]]
- [[https://ctop.sh/]]
- [[https://github.com/bcicen/ctop]]
* TODO Comando sudo y su
:PROPERTIES:
:TITLE: Comando sudo y su
:EXPORT_FILE_NAME: comando-sudo-y-su
:DESCRIPTION: Cuando utilizas Ubuntu, Debían y Raspberry OS, te das cuenta que entrar en la terminal como usuario root, es totalmente diferente dependiendo de la distribución.
:EXPORT_DATE: 2021-01-06 18:20
:CATEGORY: bash
:TAG: zsh,fish,bash
:IMAGE: ./images-blog/bash.png
:END:

Cuando utilizas Ubuntu, Debían y Raspberry OS, te das cuenta que entrar en la terminal como usuario root, es totalmente diferente dependiendo de la distribución.
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Esto es debido a que distribuciones como Ubuntu, deshabilitan el usuario root por razones de seguridad.

Vamos a ver cómo utilizar el comando su o sudo.

** Comando su

Es un comando que te permite convertirte temporalmente en otro usuario.

La sintaxis del comando =su= es la siguiente:

#+BEGIN_EXAMPLE
su [OPTIONS] [USER [ARGUMENT...]
#+END_EXAMPLE

Para cambiar el usuario actual al usuario root, e iniciar la shell como root

#+BEGIN_EXAMPLE
su
#+END_EXAMPLE

Una vez introducida la contraseña, estaremos en una sesión de root.

Para confirmar que realmente estamos en la sesión root y no en el usuario, introduciremos el comando =whoami=

#+BEGIN_EXAMPLE
whoami
#+END_EXAMPLE

Si iniciamos la sesión con -, =-l= o =--login=, cambiar directorio de actual de la shell, inicia como si comentaremos una sesión totalmente de cero.

#+BEGIN_EXAMPLE
su -
#+END_EXAMPLE

Para iniciar la nueva sesión iniciando un comando, por ejemplo zsh

#+BEGIN_EXAMPLE
su -s /usr/bin/zsh
#+END_EXAMPLE

Para preservar el entorno actual de usuario ejecutando comandos de root, utilizaremos la opción =-p=, =--preserve-environment=

#+BEGIN_EXAMPLE
su -p
#+END_EXAMPLE

Si utilizas la opción =-=, =-p= se ignora.

** Cambiar de usuario

Para cambiar a otra sesión de usuario

#+BEGIN_EXAMPLE
su angel
#+END_EXAMPLE

** su o sudo? Ubuntu

En distribuciones como Ubuntu, el comando su no funciona, debido que la cuenta root está deshabilitado por defecto.

Para acceder como root en estas distribuciones tenemos que utilizar el comando

sudo permite ejecutar comandos como otro usuario.

Para entrar como root, sería escribir sudo seguido de su , e introducir la contraseña del usuario actual. Solo podremos entrar como usuario root si este usuario tiene permisos de administración.

#+BEGIN_EXAMPLE
sudo su -
#+END_EXAMPLE

Para entrar como usuario root y estar dentro del entorno de este usuario

#+BEGIN_EXAMPLE
sudo -i
#+END_EXAMPLE

 sería equivalente a sudo -

La ventaja del comando sudo, es ejecutar instrucciones como usuario root dentro de la sesión de un usuario.

** Fuentes

- https://linuxize.com/post/su-command-in-linux/
* TODO Docker: topydo y todotxt-machine en un docker
:PROPERTIES:
:TITLE: Docker: topydo y todotxt-machine en un docker
:EXPORT_FILE_NAME: docker-topydo-y-todotxt-machine-en-un-docker
:DESCRIPTION: Si te gusta el todo.txt, te gustará este docker
:EXPORT_DATE: 2021-01-12 18:15
:CATEGORY: docker
:TAG: todo.txt,tareas
:IMAGE: ./images-blog/todotxt-machine.png
:END:

Si te gusta el todo.txt, te gustará este docker.

Para no tener que instalar estás aplicaciones en tu sistema mediante Python, he decidido crear este docker que podemos correr tanto en nuestro PC, servidor o raspberry en remoto mediante SSH.

Nuestro archivo *todo.txt*, en este caso estará en la ruta =~/todo/todo.txt= 

** Montar el docker amd64
Tan sencillo como:
#+BEGIN_EXAMPLE
docker run -it --name=todotxt -v $HOME/todo:/data ugeek/topydo-todotxt-machine:amd64 sh
#+END_EXAMPLE

** Montar el docker para ARM y Raspberry Pi
En tu Raspberry
#+BEGIN_EXAMPLE
docker run -it --name=todotxt -v $HOME/todo:/data ugeek/topydo-todotxt-machine:arm sh
#+END_EXAMPLE

** topydo
Para iniciar topydo. 
#+BEGIN_EXAMPLE
docker exec -t todotxt topydo
#+END_EXAMPLE

** topydo. Prompt mode

#+BEGIN_EXAMPLE
docker exec -t todotxt topydo prompt
#+END_EXAMPLE

** topydo. Columnas o método Kanban
Me gusta mucho utilizar el todo.txt con el método Kanban
#+HTML: <center>
[[./images-blog/topydo.png]]
#+HTML: </center>

#+BEGIN_EXAMPLE
docker exec -t todotxt topydo columns
#+END_EXAMPLE

** todotxt-machine
Para utilizar todotxt-machine
#+HTML: <center>
[[./images-blog/todotxt-machine.png]]
#+HTML: </center>


#+BEGIN_EXAMPLE
docker exec -t todotxt todotxt-machine todo.txt done.txt
#+END_EXAMPLE

** Fuentes
- https://github.com/bram85/topydo
- https://pypi.org/project/topydo/
- https://github.com/AnthonyDiGirolamo/todotxt-machine
- https://pypi.org/project/todotxt-machine/
- https://ugeek.github.io/blog/post/2020-05-22-gestionando-mis-tareas-en-la-terminal-con-topydo.html
- https://ugeek.github.io/blog/post/2020-01-31-a-python-tambien-le-gusta-el-todo-txt-todotxt-machine.html
* TODO PodGrab. Mi servidor de Podcast en Raspberry o Servidor Ubuntu, Debian,... mediante Docker
:PROPERTIES:
:TITLE: PodGrab. Mi servidor de Podcast en Raspberry o Servidor Ubuntu, Debian,... mediante Docker
:EXPORT_FILE_NAME: podgrab-mi-servidor-de-podcast-en-raspberry-o-servidor-ubuntu-debian---mediante-docker
:DESCRIPTION: Podgrab es un administrador de podcasts desarrollado en Go, que descarga automáticamente los últimos episodios de podcasts a los que estés suscrito.
:EXPORT_DATE: 2021-01-14 18:38
:CATEGORY: docker
:TAG: podcast
:IMAGE: ./images-blog/podgrab.png
:END:

Podgrab es un administrador de podcasts desarrollado en Go, que descarga automáticamente los últimos episodios de podcasts a los que estés suscrito.
#+HTML: <center>
[[./images-blog/podgrab.png]]
#+HTML: </center>

Existe la posibilidad de buscar podcast a través de iTunes para su posterior susbcripción, así como importar mediante el archivo /OPML/ que  tiene  la  mayor  parte  de  las  aplicaciones  de  podcast.
#+HTML: <center>
[[./images-blog/podgrab1.png]]
#+HTML: </center>

El desarrollador explica en su repositorio de GitHub, que la motivación de crear este servidor, fue que desde el inicio de pandemia comenzó a salir a correr y como no quería llevarse el móvil, decidió escuchar podcasts utilizando su reloj inteligente sincronizado con auriculares bluetooth y montó este método que podemos instalar a modo de servidor, para que se descarguen los podcast y tenerlos siempre disponibles.

El desarrollador explica que está trabajando para implementar un reproductor integrado en el servidor y crear una API para que se puedan crear aplicaciones que sincronicen con este servidor.

Docker oficial está genial, porque es compatible con  arquitecturas *amd64, ARM / Raspberry Pi.*

** Docker para amd64, Raspberry Pi y ARM

Yo he expuesto el servicio por el puerto 90

#+BEGIN_EXAMPLE
docker run -d -p 90:8080 --name=podgrab -v "$HOME/docker/podgrab/assets:/assets" -v "$HOME/docker/podgrab/config:/config" akhilrex/podgrab
#+END_EXAMPLE

La base de datos que en el volumen */config* y los podcasts se descargan en el directorio *assets*.

** Docker-compose

Como siempre, para futuras modificaciones, recomiendo utilizar docker-compose

#+BEGIN_EXAMPLE
version: "2.1"
services:
podgrab:
image: akhilrex/podgrab
container_name: podgrab
environment:
- CHECK_FREQUENCY=240
volumes:
- $HOME/docker/podgrab:/config
- /media/podcast:/assets
ports:
- 90:8080
restart: unless-stopped
#+END_EXAMPLE

Después ejecutaremos:

#+BEGIN_EXAMPLE
docker-compose up -d
#+END_EXAMPLE

*** Variables de entorno

| Nombre             | Descripción                                                                              | Defecto   |
|--------------------+------------------------------------------------------------------------------------------+-----------|
| CHECK_FREQUENCY   | Con qué frecuencia comprobar si hay nuevos episodios y archivos faltantes (en minutos)   | 30        |

** Conclusión

Hacía mucho tiempo que buscaba un servicio como este. Por fin tenemos la posibilidad de tener un servicio liviano, desarrollado en Go, para tener todos nuestros podcast favoritos accesibles y disponibles en un único lugar.

** Fuentes

- [[https://github.com/akhilrex/podgrab]]
- https://hub.docker.com/r/akhilrex/podgrab/
* TODO Servidor de mensajería Matrix Synapse, en Raspberry, Ubuntu, Debian... con Docker
:PROPERTIES:
:TITLE: Servidor de mensajería Matrix Synapse, en Raspberry, Ubuntu, Debian... con Docker
:EXPORT_FILE_NAME: servidor-de-mensajeria-matrix-synapse-en-raspberry-ubuntu-debian--con-docker
:DESCRIPTION: Cómo expliqué en el Podcast, no existe una  imagen oficial del contenedor Synapse,  pero *black0* ha creado una para todo tipo de arquitecturas, entre ellas ARM. 
:EXPORT_DATE: 2021-01-28 18:55
:CATEGORY: matrix
:TAG: mensajería
:IMAGE: ./images-blog/matrix.png
:END:

Cómo expliqué en el Podcast, no existe una  imagen oficial del contenedor Synapse,  pero *black0* ha creado una para todo tipo de arquitecturas, entre ellas ARM. 
#+HTML: <center>
[[./images-blog/matrix.png]]
#+HTML: </center>


El contenedor de =black0/synapse= se crea exactamente igual que con la  imagen oficial, =matrixdotorg/synapse=.

He utilizado la versión =black0/synapse:v1.20.1=,  porque la versión *latest*, he visto que no tiene compatibilidad con arquitectura ARM,  en el momento de escribir este artículo.

Si vas a instalarlo en un Ubuntu, Debian,... con arquitectura amd64, puedes utilizar la imagen oficial =matrixdotorg/synapse=. Sustituye en cada comando =black0/synapse:v1.20.1= por =matrixdotorg/synapse=.

** Creando archivos de configuración

Vamos a utilizar la imagen con el comando *generate*, para generar el archivo de configuración de nuestro servidor matrix-synapse.

Crearemos un volumen en la ruta =$HOME/docker/synapse-data=, dónde están los archivos de configuración.

Recuerda añadir en la variable *SYNAPSE_SERVER_NAME*,  la dirección de tu servidor.

Voy a utilizar =matrix.ugeek.duckdns.org=, como dirección de ejemplo de mi servidor.

#+BEGIN_EXAMPLE
docker run -it --rm         -v $HOME/docker/synapse-data:/data         -e SYNAPSE_SERVER_NAME=matrix.ugeek.duckdns.org         -e SYNAPSE_REPORT_STATS=yes         black0/synapse:v1.20.1 generate
#+END_EXAMPLE

** Crear el Contenedor

 Ahora que tenemos los archivos de configuración, vamos a crear el contenedor con el servidor.

#+BEGIN_EXAMPLE
docker run -d --name synapse         -v $HOME/docker/synapse-data:/data         -p 8008:8008         black0/synapse:v1.20.1
#+END_EXAMPLE

Si todo ha salido correctamente, conectándonos a la dirección de nuestro servidor por el puerto 8008,  veremos una página de Matrix, conforme el servidor está disponible.

** Crear contenedor con traefik

Yo utilizo traefik a modo de proxy inverso y así también consigo mi certificado Let's Encrypt de un modo sencillo con este docker-compose.

Recuerda sustituir la dirección del servidor en los dos lugares que aparece en este docker-compose (matrix.ugeek.duckdns.org).

#+BEGIN_EXAMPLE
version: "3"

services:
matrix:
image: "black0/synapse:v1.20.1"
container_name: synapse
#   ports:
#     - "8008:8008"
networks:
- web
volumes:
- $HOME/docker/synapse-data:/data
environment:
- SYNAPSE_NO_TLS=1  # La documentación dice si este valor es igual a 0, permite la federación
- SYNAPSE_SERVER_NAME=matrix.ugeek.duckdns.org
- SYNAPSE_ENABLE_REGISTRATION=1
- SYNAPSE_ALLOW_GUEST=1
- SYNAPSE_REPORT_STATS=1
labels:
- traefik.frontend.rule=Host:matrix.ugeek.duckdns.org
- traefik.frontend.entryPoints=https
- traefik.port=8008
- traefik.backend=synapse

networks:
web:
external: true
#+END_EXAMPLE

Permitir la federación, significa poder comunicarte con otros servidores de Matrix-Synapse

Ahora para levantar el docker:

#+BEGIN_EXAMPLE
docker-compose up -d
#+END_EXAMPLE

** Creando usuarios

Los usuarios hay que crearlos desde un cliente de Matrix (fluffy Chat, Element,...), en esta web hay un amplio listado para todos los sistemas operativos [[https://matrix.org/clients/]]. Pero antes tenemos que habilitar la opción en el servidor.

Para permitir el registro de usuarios, hay que editar el archivo *homeserver.yaml* y desmarcar la "*#*" habilitando =enable_registration: true=. 

#+BEGIN_EXAMPLE
nano ~/docker/synapse-data/homeserver.yaml
#+END_EXAMPLE

Desmarcamos la opción *enable_registration* y ponemos *true*.
 

#+BEGIN_EXAMPLE
# Enable registration for new users.
enable_registration: true
#+END_EXAMPLE

Reinicia el contenedor.

Ahora con nuestro cliente favorito, podemos crear nuestra cuenta en el servidor.

** Cerrar registro de usuarios

Si no quieres que se creen más usuarios, siempre puedes volver a marcar con "*#*" y poner *false* en enable_registration.

#+BEGIN_EXAMPLE
# Enable registration for new users.
enable_registration: false
#+END_EXAMPLE

** Fuentes

- [[https://github.com/matrix-org/synapse]]
- [[https://www.fusehunt.co.uk/post/matrix-server-raspberry-pi-docker/]]
* TODO Saber si existen variables, directorios o archivos con bash
:PROPERTIES:
:TITLE: Saber si existen variables, directorios o archivos con bash
:EXPORT_FILE_NAME: saber-si-existen-variables-directorios-o-archivos-con-bash
:DESCRIPTION: Buscando en internet, he visto este artículo de Linux Center super interesante, sobre si una variable tiene o no un valor.
:EXPORT_DATE: 2021-01-29 09:30
:CATEGORY: bash
:TAG: if,variables
:IMAGE: ./images-blog/bash.png
:END:


Buscando en internet, he visto este artículo de [[https://linuxcenter.es/component/k2/item/124-saber-si-una-variable-existe-y-tiene-un-valor-distinto-a-vacio-en-bash][Linux Center]] super interesante, sobre si una variable tiene o no un valor.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

He copiado parte del artículo para tenerlo siempre accesible.

Ya de pasada, para que el artículo sea más completo, he añadido también la opción de comprobar si existe un directorio o archivo y si estos son ejecutables, tienen permisos...

Para comprobarlo en estos ejemplos, utilizaremos siempre la sentencia *if*.

** Si existe un directorio

Con la opción *-d*, especificamos el directorio

#+BEGIN_EXAMPLE
#!/bin/bash

DIRECTORIO=/root1

if [ -d "$DIRECTORIO" ]
then
echo "El directorio ${DIRECTORIO} existe"
else
echo "El directorio ${DIRECTORIO} no existe"
fi
#+END_EXAMPLE

** Si existe un archivo

Con la opción *-f*, especificamos el archivo

#+BEGIN_EXAMPLE
#!/bin/bash

ARCHIVO=/etc/passwd

if [ -f $ARCHIVO ]
then
echo "El fichero $ARCHIVO existe"
else
echo "El fichero $ARCHIVO no existe"
fi
#+END_EXAMPLE

- Con la opción *-w*, comprobamos si determinado archivo tiene permisos de escritura.
- Con la opción *-x*, comprobamos si determinado archivo tiene permisos de ejecución.

** Saber si una variable existe

*** Si existe una variable

Para saber si una variable existe y está inicializada en un script o tu máquina, que esté o no está vacía.

Tomaremos =variable=""= como ejemplo.

#+BEGIN_EXAMPLE
#!/bin/bash
if [ "$variable" ]
then
echo "La variable existe y no está vacía"
else
echo "La variable no existe o está vacía"
fi
#+END_EXAMPLE

El resultado sería: =La variable no existe o está vacía=

** Variable vacía

#+BEGIN_EXAMPLE
#!/bin/bash

variable=""

if [ "$variable" ]
then
echo "La variable existe y no está vacía"
else
echo "La variable no existe o está vacía"
fi
#+END_EXAMPLE

Resultado: =La variable no existe o está vacía=

** Variable no vacía

#+BEGIN_EXAMPLE
#!/bin/bash

variable="valor"

if [ "$variable" ]
then
echo "La variable existe y no está vacía"
else
echo "La variable no existe o está vacía"
fi
#+END_EXAMPLE

Resultado: =La variable existe y no está vacía=

** Variable con valor y no vacía

- Lo primero que haremos es comprobar si existe.
- Si existe y no contiene nada, su valor es "". Esto lo haremos con [ -n"${variable-unset}" ], que dará verdadero si no existe:

#+BEGIN_SRC
#!/bin/bash

variable="valor"

if [ "$variable" ]
then
echo "La variable existe y no está vacía"
else
if [ -n "${variable-unset}" ] 
then
echo "La variable no existe"
else
echo "La variable existe pero está vacía"
fi
fi
#+END_SRC

Resultado: =La variable existe y no está vacía=

Y ahora probaremos si la cadena está vacía:

#+BEGIN_EXAMPLE
#!/bin/bash

variable=""

if [ "$variable" ]
then
echo "La variable existe y no está vacía"
else
if [ -n "${variable-unset}" ]
then
echo "La variable no existe"
else
echo "La variable existe pero está vacía"
fi
fi
#+END_EXAMPLE

Resultado: =La variable existe pero está vacía=

Sin variable (la comento):

#+BEGIN_EXAMPLE
#!/bin/bash

# variable=""

if [ "$variable" ]
then
echo "La variable existe y no está vacía"
else
if [ -n "${variable-unset}" ]
then
echo "La variable no existe"
else
echo "La variable existe pero está vacía"
fi
fi
#+END_EXAMPLE

Resultado: =La variable no existe=

** Fuentes

- [[https://linuxcenter.es/component/k2/item/124-saber-si-una-variable-existe-y-tiene-un-valor-distinto-a-vacio-en-bash]]
- [[https://www.sysadmit.com/2018/01/linux-saber-si-existe-directorio-fichero.html]]
* TODO Mi nueva nube es ownCloud
:PROPERTIES:
:TITLE: Mi nueva nube es ownCloud
:EXPORT_FILE_NAME: mi-nueva-nube-es-owncloud
:DESCRIPTION: Después de probar Nextcloud, FileRun,... y otras tantas nubes, me quedo con versión reescrita en Go de ownCloud. OwnCloud al pasar a su nueva Versión 10, ha decidido reescribir el
:EXPORT_DATE: 2021-01-31 18:54
:CATEGORY: owncloud
:TAG: nube
:IMAGE: ./images-blog/owncloud.png
:END:


Después de probar Nextcloud, FileRun,... y otras tantas nubes, me quedo con versión reescrita en Go de ownCloud. OwnCloud al pasar a su nueva Versión 10, ha decidido reescribir el código a Go, aumentando muchisímo su velocidad, reduciendo consumo, temperatura de nuestro servidor, pudiendo ejecutarlo en máquinas con menos hardware...

#+HTML: <center>
[[./images-blog/owncloud.png]]
#+HTML: </center>

Os dejo esta [[https://owncloud.com/es/news/ready-steady-go/][traducción casi literal del blog de ownCloud donde explica los motivos]].

También existe la posibilidad de crear una base de datos con *mariadb*. Yo en este caso lo he dejado sin base de datos para que sea más sencillo y sin tantas variables, pero en la documentación de ownCloud encontrarás como hacerlo.
#+HTML: <center>
[[./images-blog/owncloud1.png]]
#+HTML: </center>

** El porque del cambio

PHP ha sido durante mucho tiempo la herramienta elegida por ownCloud. Pero el lenguaje de secuencias de comandos ya no cumple con los requisitos de ownCloud para desarrollar una aplicación de colaboración de contenido moderno.

Es hora de un cambio y un cambio al lenguaje de programación Go.

PHP se ha vuelto cada vez más poderoso con el tiempo gracias a numerosas adaptaciones, como la orientación a objetos, el acceso estandarizado a las bases de datos, un servidor web integrado y una mejor gestión de la memoria. Los intérpretes y compiladores de PHP han aumentado aún más la velocidad de ejecución de scripts.

Pero todas estas mejoras no pueden ocultar el hecho de que en los años transcurridos desde que se desarrolló ownCloud por primera vez, los requisitos relacionados con el rendimiento y la escalabilidad han cambiado. Mientras tanto, Go surgió como un nuevo lenguaje que ofrece ventajas significativas para el desarrollo de aplicaciones modernas en general y para adaptarse a la nueva visión de ownCloud en particular.

** Ventajas más importantes de utilizar Go:

- Multiplataforma:  Go se ejecuta en todos los sistemas operativos de forma nativa.  El conjunto de herramientas de Go proporciona excelentes utilidades para la compilación cruzada, lo que permite la implementación rápida e inmediata de la aplicación para muchas plataformas diferentes.
- Velocidad: Go no requiere un intérprete de scripts ni un entorno de ejecución virtual.  Esto hace que Go sea tan rápido como el lenguaje de programación C, que normalmente se utiliza para requisitos de alto rendimiento.
- Concurrencia: Go ofrece la posibilidad de realizar varios cálculos en paralelo.  "Esto hace que sea más fácil para los desarrolladores paralelizar operaciones intensivas en recursos y así desarrollar una aplicación de alto rendimiento", agrega Felix Böhm, CTO de ownCloud.
- Sintaxis:  Go es muy fácil de aprender y tiene muchos paralelismos con el lenguaje de programación C. Los desarrolladores pueden ponerse al día fácilmente con Go o cambiar de su pila de herramientas anterior.  "Es muy divertido programar en Go", enfatiza Alex Unger, desarrollador de software senior en ownCloud.
- Ecosistema:  El lenguaje fue desarrollado por equipos de Google y presentado por primera vez en 2009. Es un proyecto de código abierto y se beneficia de la participación de la comunidad.  Muchas herramientas para proyectos nativos de la nube están escritas en Go, como las soluciones de contenedor Docker y Kubernetes.  "Go hace que ownCloud sea atractivo para una comunidad de desarrolladores mundial", concluye Felix Böhm.

Go tiene muchos otros beneficios, como la gestión automática de la memoria y una implementación directa y flexible de la orientación a objetos.

Las aplicaciones Go son más eficaces y utilizan significativamente menos recursos del servidor, lo que reduce tanto los costes de hardware como el consumo de energía.

La nueva generación de ownCloud, ownCloud Infinite Scale, irá un paso más allá y almacena los metadatos de los archivos directamente con los datos en el almacenamiento y por lo tanto ya no requiere una base de datos.

Fuente:  https://owncloud.com/es/news/ready-steady-go/

** Montar docker para amd64

Puedes añadir las variables de =ADMIN_USERNAME= y =ADMIN_PASSWORD= a la línea de terminal, si quieres cambiar el usuario y contraseña por defecto.

- usuario: *admin*
- contraseña: *admin*

#+BEGIN_SRC sh
docker run -e OWNCLOUD_DOMAIN=localhost:8080 -p 8080:8080 -v $HOME/docker/owncloud:/mnt/data owncloud/server
#+END_SRC

*** Docker-compose amd64

Las siguientes instrucciones asumen que lo instala localmente. Para el acceso remoto, el valor de OWNCLOUD_DOMAIN debe adaptarse.

| Nombre de configuración   | Descripción                               | Ejemplo            |
|---------------------------+-------------------------------------------+--------------------|
| =OWNCLOUD_VERSION=        | La versión ownCloud                       | =latest=           |
| =OWNCLOUD_DOMAIN=         | El dominio ownCloud                       | =localhost:8080=   |
| =ADMIN_USERNAME=          | El nombre de usuario del administrador    | =admin=            |
| =ADMIN_PASSWORD=          | La contraseña del usuario administrador   | =admin=            |
| =HTTP_PORT=               | El puerto HTTP al que enlazar             | =8080=             |

#+BEGIN_EXAMPLE sh
owncloud:
container_name: owncloud
image: owncloud/server
ports:
- 8080:8080
environment:
- OWNCLOUD_DOMAIN=localhost:8080
- OWNCLOUD_ADMIN_USERNAME=admin
- OWNCLOUD_ADMIN_PASSWORD=admin
volumes:
- $HOME/docker/owncloud:/mnt/data
#+END_EXAMPLE

** Docker-compose con proxy inverso en traefik

#+BEGIN_EXAMPLE sh
services:
owncloud:
container_name: owncloud
image: owncloud/server
#ports:
#  - 8080:8080
environment:
- OWNCLOUD_DOMAIN=localhost:8080
- OWNCLOUD_ADMIN_USERNAME=admin
- OWNCLOUD_ADMIN_PASSWORD=admin
volumes:
- $HOME/docker/owncloud:/mnt/data
networks:
- web

restart: always
labels:
- traefik.backend=owncloud
- traefik.frontend.rule=Host:owncloud.midominio.duckdns.org
- traefik.docker.network=web
- traefik.port=8080
- traefik.enable=true

networks:
web:
external: true
#+END_EXAMPLE

** Docker cli para Raspberry o ARM

#+BEGIN_EXAMPLE sh
docker run -e OWNCLOUD_DOMAIN=localhost:8080 -p 8080:8080 -v $HOME/docker/owncloud:/mnt/data owncloud/server
#+END_EXAMPLE

** Docker Compose

#+BEGIN_EXAMPLE sh
owncloud:
container_name: owncloud
image: owncloud/qnap:10.6
ports:
- 8080:8080
environment:
- OWNCLOUD_DOMAIN=localhost:8080
- OWNCLOUD_ADMIN_USERNAME=admin
- OWNCLOUD_ADMIN_PASSWORD=admin
volumes:
- $HOME/docker/owncloud:/mnt/data
#+END_EXAMPLE

** Docker-compose ARM proxy inverso con Traefik

#+BEGIN_EXAMPLE sh
services:
owncloud:
container_name: owncloud
image: owncloud/qnap:10.6
#ports:
#  - 8080:8080
environment:
- OWNCLOUD_DOMAIN=localhost:8080
- OWNCLOUD_ADMIN_USERNAME=admin
- OWNCLOUD_ADMIN_PASSWORD=admin
volumes:
- $HOME/docker/owncloud:/mnt/data
networks:
- web

restart: always
labels:
- traefik.backend=owncloud
- traefik.frontend.rule=Host:owncloud.midominio.duckdns.org
- traefik.docker.network=web
- traefik.port=8080
- traefik.enable=true

networks:
web:
external: true
#+END_EXAMPLE

** OwnCloud vs. Nextcloud

#+BEGIN_HTML
<table>
#+END_HTML

#+BEGIN_HTML
<tbody>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Nube

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

OwnCloud

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Nextcloud

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Página del proyecto

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

owncloud.com

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

nextcloud.com

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Desarrollador

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

ownCloud GmbH

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Nextcloud GmbH

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Año de publicación

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

2010

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

2016

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Licencia

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Open Source / propietario

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Open Source

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Modelos

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Standard, Enterprise

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Basic, Standard, Premium

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Costes

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

A partir de 3.000 euros para 50 usuarios al año

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

A partir de 1.900 euros para 50 usuarios al año

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Clientes para el acceso en la nube

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Windows, macOS, Linux, iOS, Android

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Windows, macOS, Linux, iOS, Android, Windows Phone

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Funciones de pago

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Sí

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

No

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Posibilidad de alojamiento en un servidor propio/vps/Raspberry

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Sí

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Sí

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
<tr>
#+END_HTML

#+BEGIN_HTML
<th>
#+END_HTML

Código

#+BEGIN_HTML
</th>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

Go

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
<td>
#+END_HTML

PHP

#+BEGIN_HTML
</td>
#+END_HTML

#+BEGIN_HTML
</tr>
#+END_HTML

#+BEGIN_HTML
</tbody>
#+END_HTML

#+BEGIN_HTML
</table>
#+END_HTML

** Fuentes
- https://owncloud.com/
- [[https://doc.owncloud.com/server/admin_manual/installation/docker/]]
- [[https://www.ionos.es/digitalguide/servidores/herramientas/owncloud-vs-nextcloud-ventajas-e-inconvenientes/]]
* TODO Instalando la última versión de Qutebrowser
:PROPERTIES:
:TITLE:  Instalando la última versión de Qutebrowser
:EXPORT_FILE_NAME: instalando-la-ultima-version-de-qutebrowser
:DESCRIPTION: He encontrado varios métodos de instalación en Blogs, que con versiones anteriores funcionaba, pero con la actual versión 2 y Ubuntu 20.04, no funciona.
:EXPORT_DATE: 2021-02-05 08:55
:CATEGORY: qutebrowser
:TAG: navegador
:IMAGE: ./images-blog/qutebrowser.png
:END:

He encontrado varios métodos de instalación en Blogs, que con versiones anteriores funcionaba, pero con la actual versión 2 y Ubuntu 20.04, no funciona.


#+HTML: <center>
[[./images-blog/qutebrowser.png]]
#+HTML: </center>

Se trataba de descargar el archivo *.zip* de la última release, descomprimirlo y ejecutar los siguientes comandos:

#+BEGIN_SRC
sudo apt install python3-pip
pip3 install --user pyqt5 pypeg2 jinja2 pygments
sudo apt-get install python3-venv
sudo apt install python3-pyqt5.qtwebengine
python3 scripts/mkvenv.py
#+END_SRC

Por último, ejecutar:
#+BEGIN_SRC
python3 qutebrowser.py
#+END_SRC

Pero esto da errores.

La solución ha sido acudir a la [[https://github.com/qutebrowser/qutebrowser/blob/master/doc/install.asciidoc][documentación Oficial]].

*** Instalación de Qutebrowser versión 2 en Ubuntu 20.04

Primero instalaremos la versión de repositorios 1.10

#+BEGIN_SRC
sudo apt install qutebrowser
#+END_SRC

Ahora vamos a instalar la nueva versión.
Nos situaremos en el directorio *HOME* y clonamos el repositorio.

#+BEGIN_SRC
cd

git clone https://github.com/qutebrowser/qutebrowser.git

cd qutebrowser
#+END_SRC


Como lo hacemos desde git, instalaremos:


#+BEGIN_SRC
sudo apt install --no-install-recommends asciidoc
#+END_SRC

#+BEGIN_SRC
python3 scripts/asciidoc2html.py
#+END_SRC

El video o el sonido no funcionan con QtWebKit, instala los complementos de gstreamer:

#+BEGIN_SRC
sudo apt install gstreamer1.0-plugins-{bad,base,good,ugly}
#+END_SRC


Instalamos python3-venv
#+BEGIN_SRC
sudo apt-get install python3-venv
#+END_SRC


#+BEGIN_SRC
python3 scripts/mkvenv.py
#+END_SRC

Ahora debería arrancar qutebrowser con:
#+BEGIN_SRC
.venv/bin/python3 -m qutebrowser
#+END_SRC


Si todo ha funcionado correctamente, vamos ha crear un script para correr la última versión de Qutebrowser por defecto, en lugar de la de repositorios.

*** Crea el siguiente script

#+BEGIN_SRC
sudo nano /usr/local/bin/qutebrowser
#+END_SRC

Damos permisos de ejecución:

#+BEGIN_SRC
sudo chmod +x /usr/local/bin/qutebrowser
#+END_SRC

Copia el siguiente contenido
#+BEGIN_SRC
#!/bin/bash
~/qutebrowser/.venv/bin/python3 -m qutebrowser "$@"
#+END_SRC

Ya tenemos la última versión!!!

*** Fuentes
- https://github.com/qutebrowser/qutebrowser/
- https://github.com/qutebrowser/qutebrowser/blob/master/doc/install.asciidoc#tox
- https://github.com/qutebrowser/qutebrowser/blob/master/doc/install.asciidoc


* TODO Docker. Servidor SSH para conectarte por SFTP
:PROPERTIES:
:TITLE: Docker. Servidor SSH para conectarte por SFTP
:EXPORT_FILE_NAME: docker-servidor-ssh-para-conectarte-por-sftp
:DESCRIPTION: Me he encontrado con un dilema cuando he montado ownCloud y es que antes tenía directorios en mi Raspberry con los que editaba mis orgmode, todo.txt, que ahora están dentro
:EXPORT_DATE: 2021-02-06 18:30
:CATEGORY: ssh
:TAG: bash,servidor
:IMAGE: ./images-blog/sftp.png
:END:


Me he encontrado con un dilema cuando he montado ownCloud y es que antes tenía directorios en mi Raspberry con los que editaba mis orgmode, todo.txt, que ahora están dentro de la nube y no los puedo editar.

Para solucionar este problema, he creado un docker con un servidor SSH para conectarme via SFTP. De esta manera también soluciono el problema que me comento un oyente, de como crear un servidor para conectarse a un directorio remoto cifrando el tráfico, todo ello dentro de una red local.
#+HTML: <center>
[[./images-blog/sftp.png]]
#+HTML: </center>

Este docker va a permitir el compartir un directorio local con el servidor SSH, solo aquel que necesito acceder, sin tener que conectarnos a la máquina host.

Mediante el almacenamiento externo de ownCloud, voy a conectarme a este docker por SFTP y con esto ganaré el tener los archivos fuera de la nube ownCloud y mantener todas las ventajas de mi nube como el control de versiones.

He creado el docker para varias arquitecturas partiendo de un Alpine Linux, lo que significa que la imágen tan solo tiene 11mb de tamaño y no consume nada en reposo.

** Docker para Raspberry o ARM

#+BEGIN_EXAMPLE
docker run -d --name=ssh -p 7777:22 -v /nube:/nube  ugeek/ssh:arm
#+END_EXAMPLE

Por defecto:

- usuario: root
- contraseña: EntraenlaMatrix

** Docker para AMD64

#+BEGIN_EXAMPLE
docker run -d --name=ssh -p 7777:22 -v /nube:/nube  ugeek/ssh:amd64
#+END_EXAMPLE

Por defecto:

- usuario: root
- contraseña: EntraenlaMatrix

** Conectate al servidor
Para conectarse al servidor con Linux:

#+BEGIN_SRC 
ssh root@localhost -p 7777
#+END_SRC


Si nuestra ip fuera 192.168.1.100:

#+BEGIN_SRC 
ssh root@192.168.1.100 -p 7777
#+END_SRC



** Cambiar Contraseña

=EntraenlaMatrix= es la contraseña por defecto, pero quizás quieras cambiarla por una que decidas tu. 

Vamos a cambiar la contraseña.  Para hacer esto, tenemos que utilizar el comando =passwd.=

Podemos hacerlo con un solo comando con:

#+BEGIN_EXAMPLE
docker exec -it ssh passwd
#+END_EXAMPLE

Ahora pedirá que pongamos la nueva contraseña que queremos utilizar, la introducimos dos veces y ya está.

** Archivo de configuración de ssh 

El archivo de configuración del servidor ssh, lo podemos encontrar en */etc/ssh/ssh_config*.

** Enviando las  llaves para no utilizar contraseña

Para no tener que escribir la contraseña cada vez y para darle más seguridad a nuestro servidor, vamos añadir la llave pública en nuestro servidor.

Creamos directorio de configuración ssh

#+BEGIN_EXAMPLE
docker exec -it ssh mkdir /root/.ssh
#+END_EXAMPLE

Creamos el archivo *authorized_keys* y añadimos id_*rsa.pub* de nuestra máquina local

#+BEGIN_EXAMPLE
docker exec -it ssh vi /root/.ssh/authorized_keys
#+END_EXAMPLE

Ahora solo falta que envíes o añadas añadas la llave pública del servidor.

** Fuentes

El Dockerfile de este contenedor, lo he extraído de un repositorio del GitHub https://github.com/AzagraMac/alpine-ssh
* TODO Instalando Thunderbird y añadiendo el corrector ortográfico
:PROPERTIES:
:TITLE: Instalando Thunderbird y añadiendo el corrector ortográfico
:EXPORT_FILE_NAME: instalando-thunderbird-y-anadiendo-el-corrector-ortografico
:DESCRIPTION: Una de las aplicaciones que me encanta para gestionar el correo electrónico es Thunderbird.
:EXPORT_DATE: 2021-02-08 09:00
:CATEGORY: correo
:TAG: ubuntu,debian
:IMAGE: ./images-blog/thunderbird.png
:END:

Una de las aplicaciones que me encanta para gestionar el correo electrónico es Thunderbird.

#+HTML: <center>
[[./images-blog/thunderbird.png]]
#+HTML: </center>


Voy a explicar como instalarlo en Ubuntu 20.04 y como instalar los plugins para el corrector ortográfico.

*** Instalación

Instalación de Thunderbird desde los repositorios oficiales de Ubuntu y sus paquetes en castellano y catalán.

#+BEGIN_SRC
sudo apt-get install thunderbird thunderbird-locale-es-es thunderbird-locale-ca
#+END_SRC

- thunderbird-locale-es-es
- thunderbird-locale-ca

Si necesitas otro idioma, tan sencillo como  escribir =sudo apt install thunderbird-locale= Seguido de tabulado "*TAB*" para que muestre sugerencias tu terminal de los idiomas disponibles.

*** Corrector ortográfico

Para habilitar el corrector ortográfico, iremos a la parte superior-derecha y pulsaremos sobre las *tres rallas* - Preferencias - Preferencias -Redacción - Ortografía.

Descarga el idioma e instala el idioma que necesites.
* TODO Proxy Inverso con Caddy
:PROPERTIES:
:TITLE: Proxy Inverso con Caddy
:EXPORT_FILE_NAME: proxy-inverso-con-caddy
:DESCRIPTION: Cómo cuarta opción, he estado probando Caddy tras la recomendación de Germán .
:EXPORT_DATE: 2021-02-19 15:35
:CATEGORY: proxy-inverso
:TAG: go,proxy,inverso
:IMAGE: ./images-blog/caddy.png
:END:


Cómo cuarta opción, he estado probando Caddy tras la recomendación de Germán .
#+HTML: <center>
[[./images-blog/caddy.png]]
#+HTML: </center>

Ya había visto a diferentes artículos de cómo construir tu proxy inverso con Caddy, incluso algunos docker-compose, pero no me había llamado la atención del todo hasta el comentario de Germán.

La verdad es que este servicio es alucinante. Es una fusión entre traefik, poder levantar todos tus servicios con su certificado desde un archivo de texto plano y sencillez como Nginx Proxy Manager.

*** Qué es Caddy

Caddy 2 es un potente servidor web de código abierto desarrollado en go.

Simplifica su infraestructura y se encarga de las renovaciones de certificados.

Funciona muy bien en contenedores porque no tiene dependencias.

Aunque la mayoría de la gente lo usa como servidor web o proxy, es una excelente opción tambien para:

- Servidor web
- proxy inverso
- proxy de sidecar
- equilibrador de carga
- Puerta de enlace API
- controlador de ingreso
- administrador de sistemas
- supervisor de proceso
- programador de tareas
- (cualquier proceso de larga duración)

** Creando el docker

Caddy requiere acceso de escritura a dos ubicaciones: un directorio de datos y un directorio de configuración .

Recuerda que para generar los certificados de [[https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwij7ueukfbuAhVxTxUIHVI8C94QFjAAegQIBxAE&url=https%3A%2F%2Fletsencrypt.org%2Fes%2F&usg=AOvVaw34k3QK_hY17BkhtCZGROEJ][Let's Encrypt]], Caddy necesita tener abiertos los puertos 80 y 443.

#+BEGIN_SRC sh
version: "3.7"
services:
caddy:
image: caddy
ports:
- "80:80"
- "443:443"
volumes:
- ./Caddyfile:/etc/caddy/Caddyfile:ro
- ./data/caddy/data:/data
- ./data/caddy/config:/config
restart: unless-stopped
container_name: caddy
#+END_SRC

Cómo es multiarquitectura, podremos utilizarlo en ARM, amd64,...

** Caddyfile

Creamos el archivo *Caddyfile*, donde irá la configuración de nuestro proxy inverso.

Voy a exponer estos 3 servicios. En el puerto 8080, tengo un servidor nginx con una web estática, 8096 para jellyfin y 4533 para navidrome.

Caddy se encargará de exponer estos servicios a la red generando el certificado con [[https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwij7ueukfbuAhVxTxUIHVI8C94QFjAAegQIBxAE&url=https%3A%2F%2Fletsencrypt.org%2Fes%2F&usg=AOvVaw34k3QK_hY17BkhtCZGROEJ][Let's Encrypt]].

#+BEGIN_EXAMPLE
midominio.duckdns.org {
                        reverse_proxy http://192.168.1.100:8080
                      }


jellyfin.midominio.duckdns.org {
                                 reverse_proxy http://192.168.1.100:8096
                               } 


navidrome.midominio.duckdns.org {
                                  reverse_proxy http://192.168.1.100:4533
                                }
#+END_EXAMPLE

** Todo de una vez

Voy a crear de ejemplo un docker-compose con shaarli y caddy, para que me genere el certirficado de shaarli.


#+BEGIN_SRC sh
version: "3.7"
 services:
   caddy:
     image: caddy
     ports:
       - "80:80"
       - "443:443"
     volumes:
       - ./Caddyfile:/etc/caddy/Caddyfile:ro
       - ./data/caddy/data:/data
       - ./data/caddy/config:/config
     restart: unless-stopped
     container_name: caddy

    shaarli:
      image: shaarli/shaarli
      container_name: shaarli
      restart: unless-stopped
#+END_SRC


Como veis, no he tenido que exponer los puertos de shaarli, ya que shaarli va ha  estar dentro de la misma red de Caddy y este mediante el archivo de configuración *Caddyfile*, Caddy se encargará de enlazar el servicio y crear el certificado.

*** Caddyfile

Mediante =reverse_proxy  shaarli:=, indicaremos a Caddy que este es el servicio que quiero utilizar como proxy inverso y que la url que quiero utilizar para acceder a este servicio, generandome también el certificado [[https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&cad=rja&uact=8&ved=2ahUKEwij7ueukfbuAhVxTxUIHVI8C94QFjAAegQIBxAE&url=https%3A%2F%2Fletsencrypt.org%2Fes%2F&usg=AOvVaw34k3QK_hY17BkhtCZGROEJ][Let's Encrypt]] de esta dirección, sea =shaarli.midominio.duckdns.org=.

#+BEGIN_EXAMPLE
shaarli.midominio.duckdns.org {
                                reverse_proxy  shaarli:
                              }
#+END_EXAMPLE

** Fuentes

- [[https://hub.docker.com/_/caddy]]
- https://caddyserver.com/
- [[https://crapts.org/2020/05/28/use-caddy-as-a-reverse-proxy-with-local-ca/]]
- https://github.com/Johni0702/mumble-web
 
* TODO Instalación de Nextcloud 21 con docker Oficial
:PROPERTIES:
:TITLE: Instalación de Nextcloud 21 con docker Oficial
:EXPORT_FILE_NAME: instalacion-de-nextcloud-21-con-docker-oficial
:DESCRIPTION: Después de estar dando vueltas por diferentes nubes, al final vuelvo a Nextcloud y te explico porque.
:EXPORT_DATE: 2021-02-25 17:56
:CATEGORY: nextcloud
:TAG: nube,webdav,docker
:IMAGE: ./images-blog/nextcloud_hub.png
:END:

Después de estar dando vueltas por diferentes nubes, al final vuelvo a Nextcloud y te explico porque.

#+HTML: <center>
[[./images-blog/nextcloud_hub.png]]
#+HTML: </center>

Los puntos fuertes de Nextcloud son:

- Un gran número de aplicaciones disponibles
- Aplicaciones móviles y de Escritorio de buenísima calidad
- Multiusuario y trabajo colaborativo
- 100% Open Source y gratuito

El contra, como ya es bien conocido y siempre he comentado, es no sobrecargar la nube de aplicaciones innecesarias ya que esto va a producir una ralentización del servicio.

Voy a explicaros cómo montar el Docker, con docker-compose para arquitectura amd64, ARM64 y Raspberry Pi.

** Docker-compose
*** amd64 y arm64

#+BEGIN_SRC sh
    version: '2'

    volumes:
      nextcloud:
      db:

    services:
      db:
        image: mariadb
        container_name: nextclouddb
        command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW
        restart: always
        volumes:
          - db:/var/lib/mysql
        environment:
          - MYSQL_ROOT_PASSWORD=vfgku8ufg56 #Cambiar esto
          - MYSQL_PASSWORD=vbbyu76f6967 #Cambiar esto
          - MYSQL_DATABASE=nextcloud
          - MYSQL_USER=nextcloud

      app:
        image: nextcloud
        container_name: nextcloud
        ports:
          - 8080:80
        links:
          - db
        volumes:
          - $HOME/docker/nextcloud:/var/www/html #Cambie 'nextcloud' a su volumen de unidad externa si está disponible
                - /almacenamiento_local:/almacenamiento_local
        restart: always
#+END_SRC

*** Raspberry Pi y ARM 32bits

Para montar el docker compose con su base de datos en mariadb para Raspberry Pi o ARM:

#+BEGIN_SRC sh
    version: '2'

    volumes:
      nextcloud:
      db:

    services:
      db:
        image: yobasystems/alpine-mariadb:latest
        container_name: nextclouddb
        command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW
        restart: always
        volumes:
          - db:/var/lib/mysql
        environment:
          - MYSQL_ROOT_PASSWORD=vfgku8ufg56 #Cambiar esto
          - MYSQL_PASSWORD=vbbyu76f6967 #Cambiar esto
          - MYSQL_DATABASE=nextcloud
          - MYSQL_USER=nextcloud

      app:
        image: nextcloud
        container_name: nextcloud
        ports:
          - 8080:80
        links:
          - db
        volumes:
          - $HOME/docker/nextcloud:/var/www/html #Cambie 'nextcloud' a su volumen de unidad externa si está disponible
                - /almacenamiento_local:/almacenamiento_local
        restart: always
#+END_SRC

** Instalación
En el ejemplo que he utilizado, Nextcloud será accesible por el puerto *8080*.

Pon el usuario y contraseña del que será el administrador, seleciona como base de datos *mariadb**, escribe la contraseña del usuario de mariadb y resto de datos como aparece en la imágen e inicia la instalación.

#+HTML: <center>
[[./images-blog/nextcloud2.png]]
#+HTML: </center>

** Forzar conexión https y dominios de confianza

Para forzar a Nextcloud a utilizar *https* en su conexión y utilice esta como raíz de todas las páginas, editaremos el archivo *config.php*.

En mi caso, utilizaré nano para editar el archivo.

#+BEGIN_SRC sh
nano ~/docker/nextcloud/config/config.php
#+END_SRC

Hay que modificar:

- overwriteprotocol = Forzar a utilizar *https*.
- trusted_domains = Dominios de confianza

Vamos añadir 3 dominios de confianza, para poder acceder a Nextcloud

#+BEGIN_SRC sh
'overwriteprotocol' => 'https',
'trusted_domains' =>
array (
0 => '192.168.1.100:90','nextcloud.midominio.duckdns.org','next.midominio.duckdns.org'
#+END_SRC

** Idioma por defecto, región telefónica,...

Nextcloud nos pedirá que añadamos nuestra región telefónica para el registro de usuarios mediante teléfono. Vamos a a añadir también, igual que en el paso anterior, estos valores al archivo *config.php*.

- force_language = Idioma por defecto. Si quieres que sean los usuarios los que determinen su propia lengua, pon el valo
- default_locale = Determinar región
- forcd_locale = forzar una configuración regional para todos los usuarios
- default_phone_region = Esto establece la región predeterminada para los números de teléfono en su servidor Nextcloud

#+BEGIN_SRC sh
'force_language' => 'es',
'default_locale' => 'es_ES',
'force_locale' => 'es_ES',
'default_phone_region' => 'ES',
#+END_SRC

- https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/config_sample_php_parameters.html

** Corrigiendo errores que nos muestra Nexcloud con Caddy

Una vez iniciado Nextcloud, accederemos en el menú de la parte superior derecha, accederemos a la opción *Configuración -> Vista generas*.

Ahora Nextcloud analizará nuestra configuración y nos propondrá que tenemos que arreglar para que todo esté correctamente configurado, si no lo está.

Yo estoy utilizando *Caddy* como proxy inverso. En mi caso, para solucionar todos los problemas he añadido al archivo *Caddyfile* la siguiente configuración:

#+BEGIN_SRC sh
nextcloud.midominio.duckdns.org {

redir /.well-known/carddav /remote.php/carddav 301
redir /.well-known/caldav /remote.php/caldav 301
reverse_proxy http://192.168.1.102:92 {
}
encode gzip
header {
Strict-Transport-Security max-age=31536000;
Referrer-Policy no-referrer-when-downgrade
}
}
#+END_SRC

Con esta configuración, Nextcloud me ha dicho que todo está perfecto

** Conclusión

Ahora solo que disfrutar de Nextcloud.



* TODO Actualizando imagen de Nextcloud y solucionando posibles problemas con docker-compose
:PROPERTIES:
:TITLE: Actualizando imagen de Nextcloud y solucionando posibles problemas con docker-compose
:EXPORT_FILE_NAME: actualizando-imagen-de-nextcloud-y-solucionando-posibles-problemas-con-docker-compose
:DESCRIPTION: Después de la última instalación Nextcloud que he hecho mediante Docker, ha llegado la primera actualización de la imagen.
:EXPORT_DATE: 2021-03-01 20:30
:CATEGORY: docker
:TAG: nextcloud
:IMAGE: ./images-blog/nextcloud.png
:END:


Después de la última instalación Nextcloud que he hecho mediante Docker, ha llegado la primera actualización de la imagen.
#+HTML: <center>
[[./images-blog/nextcloud.png]]
#+HTML: </center>

Me he llevado un susto, porque al reiniciarse el docker de *Nextcloud,* ha dejado de exponer los puertos y no podía acceder al servicio.

Si te pasa algo parecido a mí, no te pongas nervioso/a, la solución es más simple de lo que parece.

Accede al directorio donde tienes tu docker-compose y levanta de nuevo el servicio con:

#+BEGIN_SRC sh
docker-compose up -d
#+END_SRC

Yo he actualizado las imágenes con *ouroboros*. Si recuerdas, *ouroboros* descarga las imágenes nuevas si las hay, detiene de contenedor, levanta el contenedor con la nueva imagen y elimina la imagen antigua.
* TODO Trabajos en segundo plano de Nextcloud y ownCloud
:PROPERTIES:
:TITLE: Trabajos en segundo plano de Nextcloud y ownCloud
:EXPORT_FILE_NAME: trabajos-en-segundo-plano-de-nextcloud-y-owncloud
:DESCRIPTION: Un sistema como Nextcloud a veces requiere que las tareas se realicen de forma regular sin la necesidad de interacción del usuario ni obstaculizar el rendimiento de Nextcloud. Para ese
:EXPORT_DATE: 2021-03-02 20:02
:CATEGORY: nextcloud
:TAG: owncloud,docker
:IMAGE: ./images-blog/nextcloud.png
:END:


Un sistema como Nextcloud a veces requiere que las tareas se realicen de forma regular sin la necesidad de interacción del usuario ni obstaculizar el rendimiento de Nextcloud. Para ese propósito, como administrador del sistema, puede definir trabajos en segundo plano (para ejemplo, limpiezas de bases de datos) que se ejecutan sin necesidad de que el usuario Interacción.
#+HTML: <center>
[[./images-blog/nextcloud.png]]
#+HTML: </center>


Disponemos de tres tipos de configuraciones cron:
- AJAX
- Webcron
- Cron

** Ajax
Programación AJAX es la opción predeterminada. Desafortunadamente, sin embargo, es también el menos confiable. Cada vez que un usuario visita la página de Nextcloud, un solo se ejecuta el trabajo en segundo plano.

** Webcron
Tendríamos que seleccionar esta opción en el apartado *Configuración -> Ajustes básicos* y remotamente, accediendo a una url, actualizaríamos *cron*. La url sería:

#+BEGIN_SRC sh
https://nextcloud.midominio.duckdns.org/cron.php
#+END_SRC

** Cron
Genaremos con crontab una tarea que se ejecute cada cierto tiempo, =www-data=o =wwwrun=

#+BEGIN_SRC sh
docker exec --user www-data nextcloud  php -f /var/www/html/cron.php
#+END_SRC

*** Programa con crontab

En la maquina host, añadiremos el siguiente cron:

#+BEGIN_SRC sh
*/5  * * * * docker exec --user www-data nextcloud  php -f /var/www/html/cron.php
#+END_SRC

Ahora cada 5 minutos, ejecutará *cron.php*.
* TODO Paquetes instalados en tu sistema
:PROPERTIES:
:TITLE: Paquetes instalados en tu sistema
:EXPORT_FILE_NAME: paquetes-instalados-en-tu-sistema
:DESCRIPTION: He instalado tantas cosas para probar, que no recuerdo exactamente que. Vamos a ver los paquetes instalados en nuestro debian y derivadas, para borrar todo aquello que sobra. *Importante borrar
:EXPORT_DATE: 2021-03-06 20:30
:CATEGORY: bash
:TAG: zsh,fish,snap,flatpak
:IMAGE: ./images-blog/bash.png
:END:

He instalado tantas cosas para probar, que no recuerdo exactamente que. Vamos a ver los paquetes instalados en nuestro debian y derivadas, para borrar todo aquello que sobra. *Importante borrar solo aquello que conozcas* ya que si borras algún paquete importante, puedes romper el sistema, dejar de funcionar el WiFi, etc...
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

** Listar paquetes instalados con apt

Para ver el listado de todos los paquetes y dependencias (con todas sus librerías necesarias) instalados por *apt* o archivos *.deb*. Utilizaremos el siguiente comando

=apt list --installed=

En este ejemplo, he filtrado por aquellos paquetes o aplicaciones que llevan la palabra *i3*.

=apt list --installed | grep "i3"=

** Listar los paquetes instalados con dpkg

También podemos listar los paquetes con *dpkg*, pero desde mi punto de vista, es menos práctico. Aún así, es interesante conocerlo

=dpkg-query -l=

o

=dpkg -l=

** Listar paquetes snap

Para listar todos los paquetes snap instalados, en caso de utilizar snap.

=snap list=

** Listar paquetes Flatpak

Para listar los paquetes Flatpak instalados:

=flatpak list=

** registros del sistema

Linux registra todo lo que sucede en nuestro sistema. Vamos a ver los registros.

*** Ver registros del sistema

Para ver los registros del sistema, filtrados una vez más con grep, mediante la palabra install: =grep " install " /var/log/dpkg.log=

*** Registros de programas instalados mediante apt

=grep " install " /var/log/apt/history.log=
* TODO Cambiar el hostname Ubuntu, Debian, Raspberry OS...
:PROPERTIES:
:TITLE: Cambiar el hostname Ubuntu, Debian, Raspberry OS...
:EXPORT_FILE_NAME: cambiar-el-hostname-ubuntu-debian-raspberry-os--
:DESCRIPTION: Si utilizas una Raspberry, por defecto el hostname es *pi*. Si tienes muchos dispositivos que administrar y por ejemplo utilizan *Ubuntu*, puede que el hostname sea *ubuntu*.
:EXPORT_DATE: 2021-03-07 20:48
:CATEGORY: bash
:TAG: ubuntu,debian,raspberry
:IMAGE: ./images-blog/bash.png
:END:


Si utilizas una Raspberry, por defecto el hostname es *pi*. Si tienes muchos dispositivos que administrar y por ejemplo utilizan *Ubuntu*, puede que el hostname sea *ubuntu*.
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Esto puede ser un locura, así que es interesante poner un nombre a cada dispositivo para poder identificarlos.

Vamos a ver como hacer esto en *Ubuntu*, *Raspberry*, *Debian* y derivadas...

** hostname actual

Para ver el hostname que estamos utilizando actualmente:

=hostname=

** Cambiar el hostname

Tecleamos el siguiente comando:

=sudo hostname nuevo_hostname=

En Debian, además tenemos que editar los archivos /etc/hostname y /etc/hosts.

Sustituye hostname antiguo por el nuevo :

=sudo nano /etc/hostname=

=sudo nano /etc/hosts=

Ahora reiniciamos y comprobaremos si se ha modificado el hostname.

=sudo reboot now=

=hostname=
* TODO vim. Resaltado de sintaxis
:PROPERTIES:
:TITLE: vim. Resaltado de sintaxis
:EXPORT_FILE_NAME: vim-resaltado-de-sintaxis
:DESCRIPTION: Cuando creo un script en bash u otro lenguaje de programación, me gusta que el editor que utilizo resalte la sintaxis, ya que de este modo puedo encontrar errores. Ahora
:EXPORT_DATE: 2021-03-08 10:50
:CATEGORY: vim
:TAG: sintaxis
:IMAGE: ./images-blog/vim.png
:END:

Cuando creo un script en bash u otro lenguaje de programación, me gusta que el editor que utilizo resalte la sintaxis, ya que de este modo puedo encontrar errores. Ahora que estoy empezando a utilizar *vim*, vamos a ver como resaltar la sintaxis por defecto.

#+HTML: <center>
[[./images-blog/vim.png]]
#+HTML: </center>

** Archivo de configuración vimrc

Para hacer esto posible, añadiremos al archivo de configuración de vim, .vimrc, lo siguiente:

#+BEGIN_SRC sh
vim ~/.vimrc
#+END_SRC

Esto es lo que tenemos que copiar

#+BEGIN_SRC sh
syntax on
#+END_SRC

de este modo, cada vez que abramos *vim*, de forma automática, *vim* resaltará la sintaxis.

Si quieres habilitar este modo solo cuando tu lo desees, una vez abierto el script a editar, ejecutaremos:

#+BEGIN_SRC sh
:syntax on
#+END_SRC

Para deshabilitarlo, ejecutaremos:

#+BEGIN_SRC sh
:syntax off
#+END_SRC

** Plantillas de colores

Es probable que la plantilla por defecto no te guste. Si deseas cambiarla, podemos encontrar varias de diferentes colores en la ruta =/usr/share/vim/vim*/colors/=

#+BEGIN_SRC sh
ls /usr/share/vim/vim*/colors/
#+END_SRC

Vamos a probar una de las plantilla. Por ejemplo, *vim blue.vim*.

#+BEGIN_SRC sh
:colorscheme blue
#+END_SRC

Ahora voy a añadir esta plantilla al archivo de configuración, para utilizarla siempre por defecto:

#+BEGIN_SRC sh
colorscheme blue
#+END_SRC

Podemos encontrar más plantillas [[https://www.vim.org/scripts/script_search_results.php?keywords=&script_type=color+scheme&order_by=creation_date&direction=descending&search=search][en la siguiente página de vim]].

** Lineas Numeradas

Para numerar las líneas, tan sencillo como ejecutar en *vim* una vez abierto el script:

#+BEGIN_SRC sh
:set number
#+END_SRC

También podemos utilizar

#+BEGIN_SRC sh
:set nu
#+END_SRC

Si queremos que por defecto siempre aparezcan las líneas, añadiremos =set number= o =set nu=en el archivo de configuración *.vimrc*.

Para deshabilitar la numeración, utilizaremos lo haremos con el comando:

#+BEGIN_SRC sh
:set nu!
#+END_SRC

Si estamos editando y probando todo el rato un script en la misma línea y quiero acceder ella directamente, lo haríamos del siguiente modo:

#+BEGIN_SRC sh
vim +183 script.sh
#+END_SRC

** Fuentes

- https://www.ochobitshacenunbyte.com/2019/01/02/habilitar-resaltado-de-sintaxis-en-los-editores-vi-y-vim/
