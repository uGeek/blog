
#+SEQ_TODO: TODO(t) PROGRAM(p) BLOG(n) NEXT(n) DESARROLLO(r) ESPERA(e) | DONE(d)


* DONE Instalar el cliente Mumble por Snap y Flatpak
:PROPERTIES:
:TITLE: Instalar el cliente Mumble por Snap y Flatpak
:EXPORT_FILE_NAME: Instalar el cliente Mumble por Snap y Flatpak
:DESCRIPTION: Ya os he explicado como instalar el servidor de mumble en vuestra Raspberry o Servidor con Docker. Ahora vamos a disfrutar de la última versión del cliente, gracias a los
:EXPORT_DATE: 2019-10-07 20:44
:CATEGORY: app
:TAG: servidor,ubuntu,debian
:IMAGE: ./images-blog/mumble.png
:END:

Ya os he explicado como instalar el servidor de mumble en vuestra Raspberry o Servidor con Docker. Ahora vamos a disfrutar de la última versión del cliente, gracias a los paquetes *snap* o *flatpak*.

#+HTML: <center>
[[./images-blog/mumble.png]]
#+HTML: </center>

Esta última versión del cliente para escritorio, no tiene nada que ver con las versiones anteriores. La interfaz se ve mucho mas moderna.

** Flatpak
*** Instalación
Instalación por Flatpak
#+BEGIN_SRC 
flatpak install flathub info.mumble.Mumble
#+END_SRC

*** Ejecutar la aplicación 
#+BEGIN_SRC 
flatpak run info.mumble.Mumble
#+END_SRC
** Snap
Instalación por snap
#+BEGIN_SRC 
sudo snap install mumble
#+END_SRC
#+HTML: <iframe src="https://snapcraft.io/mumble/embedded?button=black" frameborder="0" width="100%" height="330px" style="border: 1px solid #CCC; border-radius: 2px;"></iframe>

** PPA para Ubuntu
Si tienes ubuntu y te gustan más los PPA:
#+BEGIN_SRC 
sudo add-apt-repository ppa:mumble/release
sudo apt-get update
sudo apt-get install mumble
#+END_SRC
Para el resto de aplicaciones, visita la [[https://wiki.mumble.info/wiki/Installing_Mumble][wiki]]. 
** Fuentes
- https://snapcraft.io/mumble
- https://flathub.org/apps/details/info.mumble.Mumble
- https://wiki.mumble.info/wiki/Installing_Mumble
- https://www.mumble.info/
* DONE Instalar el cliente Mumble por Snap y Flatpak
:PROPERTIES:
:TITLE: Instalar el cliente Mumble por Snap y Flatpak
:EXPORT_FILE_NAME: Instalar el cliente Mumble por Snap y Flatpak
:DESCRIPTION: Ya os he explicado como instalar el servidor de mumble en vuestra Raspberry o Servidor con Docker. Ahora vamos a disfrutar de la última versión del cliente, gracias a los
:EXPORT_DATE: 2019-10-07 20:44
:CATEGORY: app
:TAG: servidor,ubuntu,debian
:IMAGE: ./images-blog/mumble.png
:END:

Ya os he explicado como instalar el servidor de mumble en vuestra Raspberry o Servidor con Docker. Ahora vamos a disfrutar de la última versión del cliente, gracias a los paquetes *snap* o *flatpak*.

#+HTML: <center>
[[./images-blog/mumble.png]]
#+HTML: </center>

Esta última versión del cliente para escritorio, no tiene nada que ver con las versiones anteriores. La interfaz se ve mucho mas moderna.

** Flatpak
*** Instalación
Instalación por Flatpak
#+BEGIN_SRC 
flatpak install flathub info.mumble.Mumble
#+END_SRC

*** Ejecutar la aplicación 
#+BEGIN_SRC 
flatpak run info.mumble.Mumble
#+END_SRC
** Snap
Instalación por snap
#+BEGIN_SRC 
sudo snap install mumble
#+END_SRC
#+HTML: <iframe src="https://snapcraft.io/mumble/embedded?button=black" frameborder="0" width="100%" height="330px" style="border: 1px solid #CCC; border-radius: 2px;"></iframe>

** PPA para Ubuntu
Si tienes ubuntu y te gustan más los PPA:
#+BEGIN_SRC 
sudo add-apt-repository ppa:mumble/release
sudo apt-get update
sudo apt-get install mumble
#+END_SRC
Para el resto de aplicaciones, visita la [[https://wiki.mumble.info/wiki/Installing_Mumble][wiki]]. 
** Fuentes
- https://snapcraft.io/mumble
- https://flathub.org/apps/details/info.mumble.Mumble
- https://wiki.mumble.info/wiki/Installing_Mumble
- https://www.mumble.info/
* NEXT Instalando Flatpak en Debian, Ubuntu y Raspbian
:PROPERTIES:
:TITLE: Instalando Flatpak en Debian, Ubuntu y Raspbian
:EXPORT_FILE_NAME: Instalando Flatpak en Debian, Ubuntu y Raspbian
:DESCRIPTION: La paquetería Flatpak es genial, porque te permite ejecutar aplicaciones a la última versión, sin necesidad de ser root y de un modo seguro ya que la aplicación corre de
:EXPORT_DATE: 2019-10-07 21:17
:CATEGORY: flatpak
:TAG: debian,ubuntu
:IMAGE: ./images-blog/flatpak.png
:END:

La paquetería Flatpak es genial, porque te permite ejecutar aplicaciones a la última versión, sin necesidad de ser root y de un modo seguro ya que la aplicación corre de un modo independiente al sistema operativo.

#+HTML: <center>
[[./images-blog/flatpak.png]]
#+HTML: </center>

Vamos a ver como instalarlo en Debian, Ubuntu y Raspbian. El resto de las distros las encontrarás en la página oficial. Encontraras la url en las fuentes de este artículo.

** Debian

Accedemos como *root*.
#+BEGIN_SRC 
su root
#+END_SRC

El paquete flatpak está disponible en Debian Buster o superior
#+BEGIN_SRC 
apt install flatpak
#+END_SRC

Si tienes GNOME, sería buena idea instalar el plugin de Flatpak para GNOME Software 
#+BEGIN_SRC 
apt install gnome-software-plugin-flatpak    
#+END_SRC 
Añadimos el repositorio de Flathub
 
Flathub es el mejor lugar para obetener Flatpaks. Para habilitarlo:
#+BEGIN_SRC 
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
#+END_SRC
    
** Ubuntu
Instalamos flatpak
#+BEGIN_SRC 
sudo apt install flatpak
#+END_SRC

Añadimos el Plugin
#+BEGIN_SRC 
sudo apt install gnome-software-plugin-flatpak
#+END_SRC
Añadimos el repositorio
#+BEGIN_SRC 
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
#+END_SRC
** Raspbian

Instalamos
#+BEGIN_SRC 
apt install flatpak
#+END_SRC
Añadimos el repositorio
#+BEGIN_SRC 
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
#+END_SRC
** Instalación el resto de distros
Para instalar en el resto de distros, [[https://flatpak.org/setup/][acceder a la página oficial]].
** Fuentes
- https://flatpak.org/setup/
* NEXT Docker: My Tiny Todo. El Wunderlist de tu servidor
:PROPERTIES:
:TITLE: Docker: My Tiny Todo. El Wunderlist de tu servidor
:EXPORT_FILE_NAME: Docker: My Tiny Todo. El Wunderlist de tu servidor
:DESCRIPTION: Uno de mis servicios favoritos, para generar listas de tareas fué WunderList. La verdad es que nunca lo utilicé en profundidad porque no quería que me creara autodependencia.
:EXPORT_DATE: 2019-10-07 22:22
:CATEGORY: notas
:TAG: servidor, raspberry
:IMAGE: ./images-blog/mytinytodo.png
:END:

Uno de mis servicios favoritos, para generar listas de tareas fué WunderList. La verdad es que nunca lo utilicé en profundidad porque no quería que me creara autodependencia.

#+HTML: <center>
[[./images-blog/mytinytodo.png]]
#+HTML: </center>


** Instalación
#+HTML: <center>
[[./images-blog/mytinytodo1.png]]
#+HTML: </center>


#+HTML: <center>
[[./images-blog/mytinytodo2.png]]
#+HTML: </center>


#+HTML: <center>
[[./images-blog/mytinytodo3.png]]
#+HTML: </center>

* DONE Docker: Bitwarden. Un servidor de contraseñas en tu Raspberry Pi
:PROPERTIES:
:TITLE: Docker: Bitwarden. Un servidor de contraseñas en tu Raspberry Pi
:EXPORT_FILE_NAME: docker-bitwarden-un-servidor-de-contrasenas-en-tu-raspberry-pi
:DESCRIPTION: Hace un tiempo utilizaba como gestor de contraseñas Keepass, pero desde que descubrí Bitwarden, no dudé en dar el cambio.
:EXPORT_DATE: 2019-10-09 20:09
:CATEGORY: docker
:TAG: servidor,raspberry
:IMAGE: ./images-blog/bitwarden.png
:END:

Hace un tiempo utilizaba como gestor de contraseñas Keepass, pero desde que descubrí Bitwarden, no dudé en dar el cambio.

#+HTML: <center>
[[./images-blog/bitwarden.png]]
#+HTML: </center>

Uno de mis requisitos, era que funcionara en mi raspberry. Como siempre os comento, tener todos mis servicios en una placa que tan solo consume unos 4(w), en el caso de la Raspberry 4, me permite tener muchos servicios por muy bajo coste.

No encontraba un contenedor que funcionara bien en mi Raspberry, hasta que Carlos del [[https://elblogdelazaro.gitlab.io/][Blog de Lazaro]], me recomendó este.

El servidor de Bitwarden funciona muy bien también en la Raspberry 3, es un servicio muy ligero, así que vale la pena utilizarlo.

Mediante el cliente de Android, Plugin de Firefox o Google Chrome,... me permite tener las contraseñas en todos mis dispositivos. El Plugin del navegador es genial. Te sugiere el guardar una contraseña si no la tienes guardada o auto escribir el usuario y contraseña, cada vez que accedes a un servicio, si este tienes la contraseña guardada.


Recuerda que este contenedor no es oficial, pero el Dockerfile está disponible en un repositorio de GitHub.
** Docker Raspberry Pi
El puerto en el que corre el servicio en este ejemplo, es el puerto 80. Si quisieramos exponerlo en el puerto 90, por ejemplo, utilizariamos: *-p 90:80*.
#+BEGIN_SRC 
docker run -d --name bitwarden -v $HOME/docker:/data/ -p 80:80 mprasil/bitwarden:raspberry
#+END_SRC
** Docker ARM 64bits
Si tienes una placa ARM con procesador de 64bits, también tiene una versión exclusiva. Visita la [[https://hub.docker.com/r/mprasil/bitwarden/tags][sección de Tags]].
#+BEGIN_SRC 
docker run -d --name bitwarden -v $HOME/docker:/data/ -p 80:80 mprasil/bitwarden:aarch64
#+END_SRC



** Fuente
- https://hub.docker.com/r/mprasil/bitwarden/
- https://github.com/mprasil/bitwarden_rs

* DONE Editor de Texto Nano
:PROPERTIES:
:TITLE: Editor de Texto Nano
:EXPORT_FILE_NAME: editor-de-texto-nano
:DESCRIPTION: #+HTML: <center>
:EXPORT_DATE: 2019-11-10 15:10
:CATEGORY: notas
:TAG: ssh,terminal
:IMAGE: ./images-blog/nano.png
:END:

#+HTML: <center>
[[./images-blog/nano.png]]
#+HTML: </center>


** Atajos
*Ctrl+g* o  *F1*, muestra la ayuda y no solo nos explica el funcionamiento de nano, sino también todos los atajos. Vamos a ver algunos de los atajos más útiles.

- Ctrl-c : cancela comando actual
- Ctrl-s : Guardar el documento actual
- Ctrl-x o F2: Salir y guardar o no documento

- Ctrl-w o F6: Buscar
- Alt-r o Ctrl-\ : Buscar y remplazar texto

- Ctrl-_  o Ctrl-Shift--: Ir a un determinado número de línea

- Ctrl-r : Insertar otro archivo de texto en el que esté abierto en ese momento
- Ctrl-l : Actualizar el buffer, en el caso que dos personas esten editando el documento


*** Rehacer - Deshacer
- Alt-u : Deshacer
- Alt-e : Rehacer

*** Copiar, Cortar, Pegar y seleccionar un texto
- Alt-a : Seleccionamos un texto que desdeamos copiar o cortar. Pulsa *Alt-a* una vez has seleccionado el texto
- Ctrl-k : Cortar
- Alt-6  : Copiar
- Ctrl-u : Pegar

*** Otros
- Alt-i : Habilitar y deshabilitar el auto identado
- Alt-m : Habilitar el uso del ratón


** Corrector Ortográfico
*** Instalación 
#+BEGIN_SRC 
sudo apt install spell
#+END_SRC

Ahora para poder corregir el texto mediante *nano*, pulsaremos las teclas *Ctrl-t*. Nano se desplazará hasta la palabra con error de ortografía para que sustituyamos el texo.

** Todos los Atajos
- ^ es igual a la tecla *Ctrl*
- *M* es igual a la tecla *Alt*


#+BEGIN_SRC 
ATAJOS          DESCRIPCIÓN

^G    (F1)      Mostrar esta ayuda
^X    (F2)      Cerrar el búfer actual / Salir de nano
^O    (F3)      Escribir el búfer actual (o la región marcada) a disco
^R    (Ins)     Insertar otro fichero en el búfer actual (o en un nuevo búfer)

^W    (F6)      Buscar hacia delante una cadena o expresión regular
^\    (M-R)     Reemplazar una cadena o expresión regular
^K    (F9)      Cortar la línea actual (o la región marcada) y guardarla en el cutbuffer
^U    (F10)     Pegar el cutbuffer en la línea actual

^J    (F4)      Justificar el párrafo actual
^T    (F12)     Invocar el corrector ortográfico (si está disponible)

^C    (F11)     Mostrar la posición del cursor
^_    (M-G)     Ir a una línea y columna

M-U             Deshacer la última operación
M-E             Rehacer la última operación deshecha

M-A   (^6)      Marcar texto desde la posición actual del cursor
M-6   (M-^)     Copiar la línea actual (o la región marcada) y guardarla en el cutbuffer

M-]             Ir a la llave correspondiente

^Q              Buscar hacia atrás una cadena o expresión regular
M-Q   (M-▲)     Seguir buscando hacia atrás
M-W   (M-▼)     Seguir buscando hacia delante

^B    (◀)       Ir hacia atrás un carácter
^F    (▶)       Ir hacia delante un carácter
^◀    (M-Space) Ir hacia atrás una palabra
^▶    (^Space)  Ir hacia delante una palabra
^A    (Home)    Ir al principio de la línea actual
^E    (End)     Ir al final de la línea actual

^P    (▲)       Ir a la línea anterior
^N    (▼)       Ir a la siguiente línea
M--   (M-_)     Desplazar el texto una línea arriba sin mover el cursor textualmente
M-+   (M-=)     Desplazar el texto una línea abajo sin mover el cursor textualmente

^▲    (M-7)     Ir al bloque de texto anterior
^▼    (M-8)     Ir al siguiente bloque de texto
M-(   (M-9)     Ir al principio del párrafo; después, al del párrafo anterior
M-)   (M-0)     Ir al final del párrafo; después, al del párrafo siguiente

^Y    (PgUp)    Ir una pantalla hacia arriba
^V    (PgDn)    Ir una pantalla hacia abajo
M-\   (^Home)   Ir a la primera línea del fichero
M-/   (^End)    Ir a la última línea del fichero

M-◀   (M-<)     Cambiar al búfer de fichero anterior
M-▶   (M->)     Cambiar al siguiente búfer de fichero

^I    (Tab)     Insertar un carácter de tabulación en la posición del cursor
^M    (Enter)   Insertar un retorno de carro en la posición del cursor

^H    (Bsp)     Borrar el carácter a la izquierda del cursor
^D    (Del)     Borrar el carácter bajo el cursor
Sh-^Del         Cortar hacia atrás desde cursor a principio de palabra
^Del            Cortar desde cursor a principio de siguiente palabra
M-T             Cortar desde el cursor hasta el final de línea

M-J             Justificar el fichero completo
M-D             Contar el número de palabras, líneas y caracteres
M-V             Insertar la próxima pulsación literalmente

^L              Redibujar la pantalla actual
^Z              Suspender el editor (si la suspensión está activada)

M-}   (Tab)     Sangrar la línea actual (o las líneas marcadas)
M-{   (Sh-Tab)  Quitar sangrado de la línea actual (o las líneas marcadas)

M-3             Comentar/descomentar la línea actual (o las líneas marcadas)
^]              Intenta completar la palabra actual

M-:             Iniciar/parar grabación de macro
M-;             Ejecutar la última macro grabada

M-Del           Desechar la línea actual (o la región marcada)

M-B             Invocar el corrector de sintaxis (si está disponible)

^S              Guardar fichero sin preguntar

M-X             Modo de ayuda activar/desactivar
M-C             Muestra constante de la posición del cursor activar/desactivar
M-S             Desplazamiento suave activar/desactivar
M-$             Ajuste suave de líneas largas activar/desactivar
M-#             Numeración de líneas activar/desactivar
M-P             Muestra los blancos activar/desactivar
M-Y             Coloreado de sintaxis activar/desactivar

M-H             Tecla de inicio inteligente activar/desactivar
M-I             Auto-sangrado activar/desactivar
M-K             Cortado desde el cursor hasta el final de línea activar/desactivar
M-L             Ajuste estricto de líneas largas activar/desactivar
M-O             Conversión de pulsaciones de tabulador a espacios activar/desactivar

M-M             Soporte para ratón activar/desactivar
M-Z             Suspensión activar/desactivar
#+END_SRC
** Archivo de configuración de nano
El archivo de configuración de nano esta situado en *~/.nanorc* o */etc/nanorc*.

Por defecto no viene creado y si queremos utilizar una configuración personalizada, debemos crearlo.

#+BEGIN_SRC 
nano ~/.nanorc
#+END_SRC

** Mostrar número de líneas

Editamos el archivo de configuración, por ejemplo, mediante *nano*:
#+BEGIN_SRC 
nano ~/.nanorc
#+END_SRC


Añadimos el siguiente texto al archivo de configuración *~/.nanorc*




#+BEGIN_SRC 
set linenumbers
#+END_SRC

Ahora cada vez que abramos *nano*, aparecerá en la parte izquierda de la pantalla el número de línea

** Definir el número de espacios en el tabulado
Por defecto el numero de espacios en el tabulado son 8. Mediante el archivo de configuración, podemos definir cuantos espacios.

Editamos el archivo de configuración
#+BEGIN_SRC 
nano ~/.nanorc
#+END_SRC

Por ejemplo, aquí estoy definiendo que sean 4 espacios por tabulado.
#+BEGIN_SRC 
set tabsize 4
#+END_SRC
*** Tabulado en espacios
Si lo que deseamos es sustituir la tecla tabulado, para que nano entenenda esta tecla como espacio, añadiriamos al archivo de confuguración
#+BEGIN_SRC 
set tabstospaces
#+END_SRC
** Guardar automáticamente archivo sin preguantar
Esta opción es muy útil. Una de las cosas que más rabia me da de nano, es cuando te pregunta si deseas guardar el archivo modificado.
Añadiendo *set tempfile* a nuestro archivo de configuración, ya no nos lo volverá a pregunatar.

Editamos el archivo de configuración
#+BEGIN_SRC 
nano ~/.nanorc
#+END_SRC
Añadimos
#+BEGIN_SRC 
set tempfile
#+END_SRC
** Backup del archivo


** Reslatar sitaxis
Los archivos para resaltar sintaxis están situados en la carpeta */usr/share/nano/*.

** Multibuffer

Añadimos en nuestro archivo de configuración
#+BEGIN_SRC 
set multibuffer
#+END_SRC

Despues con *Alt-,*, podremos ir cambiando entre las diferentes pantallas

** Fuentes
- https://www.atareao.es/software/programacion/nano-un-editor-de-texto-para-la-terminal/
- https://github.com/Tanai3/mynanorc/blob/master/.nanorc
- https://freethegnu.wordpress.com/2007/06/23/nano-shortcuts-syntax-highlight-and-nanorc-config-file-pt1/
- https://github.com/scopatz/nanorc
- 





* TODO Wine en Ubuntu 18.04
** Habilitar arquitectura 32bits
#+BEGIN_SRC 
sudo dpkg --add-architecture i386
#+END_SRC

** Importar claves
#+BEGIN_SRC 
wget -nc https://dl.winehq.org/wine-builds/Release.key
sudo apt-key add Release.key
#+END_SRC
** Añadimos el repositorio

#+BEGIN_SRC 
sudo apt-add-repository https://dl.winehq.org/wine-builds/ubuntu/

sudo apt-add-repository 'deb https://dl.winehq.org/wine-builds/ubuntu/ artful main'
#+END_SRC


* TODO Linea de Tiempo desde un archivo OrgMode
:PROPERTIES:
:TITLE: Linea de Tiempo desde un archivo OrgMode
:EXPORT_FILE_NAME: Linea de Tiempo desde un archivo OrgMode
:DESCRIPTION:
:EXPORT_DATE: 2019-08-27 21:42
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: https://raw.githubusercontent.com/uGeek/org-timeline/master/example/example.png
:END:

Me declaro Fan de las líneas de tiempo y mucho mas, si parten de una archivo orgmode.

El css desarrollado por [[https://github.com/elisescu][elisescu]], nos permite exportar nuestro archivo orgmode a una página html con una línea de tiempo. Vamos a probar crear la nuestra línea de Tiempo.

#+HTML: <center>
[[https://raw.githubusercontent.com/uGeek/org-timeline/master/example/example.png]]
#+HTML: </center>



En el Post vamos a crear un archivo orgmode, que será donde iremos añadiendo todo lo que saldrá en la línea de tiempo, crearemos un archivo css y finalmente, exportaremos el archivo orgmode a html utilizando el archivo css que hemos creado.

** Crear archivo OrgMode
Crea un archivo .org y copia el siguiente contenido. Podemos añadir imágenes, cajetillas de código... 

#+begin_src 
#+OPTIONS: p:nil prop:nil f:nil d:t num:nil toc:nil html-style:nil

# Timeline styling css inclusion
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="timeline.css" />

# Insertar a CSS class on a headline, with <C-X-p> HTML_CONTAINER_CLASS
# Exportar con <C-c C-e h h>, or <M-x> org-html-export-to-html

** Encabezado de la línea de tiempo
  :PROPERTIES:
  :HTML_CONTAINER_CLASS: timeline-head
  :END:
Ejemplo de página html con la línea de tiempo

** Linea de Tiempo
  :PROPERTIES:
  :HTML_CONTAINER_CLASS: timeline-container
  :END:
** 2019-08-28 Miercoles
*** Creando Post de Línea de Tiempo
Hoy he comenzado a crear el Post

[[./imagen.png]]

** 2019-03-29 Jueves
*** Publicando el Podcast
Podcast de Docker
** 2019-04-30 Viernes
*** Publicación de Otro Post
Preparando otro post y podcast para la publiciación
#+end_src

** Crear archivo css
El archivo css, es el que da el estilo linea de tiempo cuando hacemos la exportación de nuestro archivo. Le llamaremos *timeline.css* y copiaremos el siguiente contenido:

#+begin_src 
@import url("https://fonts.googleapis.com/css?family=Oswald|Roboto:400,700");

body {
    font-size: 1rem;
    line-height: 1.5;
    color: rgba(0, 0, 0, 0.7);
}

h1, h2, h3, h4, h5, h6 {
    font-family: 'Oswald', sans-serif;
}

h1 {
    font-size: 2rem;
    margin-bottom: .5em;

}

ul > li, p {
    font-family: 'Roboto', sans-serif;
    font-size: 1rem;
}

ul > li {
    font-size: 1rem;

}

.timeline-container {
    max-width: 1024px;
    width: 60%;
    padding-left: 4px;
    /* margin: 0 auto; */
}

.timeline-container .outline-3 {
    padding: 3em 2em 2em;
    position: relative;
    color: rgba(0, 0, 0, 0.7);
    border-left: 2px solid rgba(0, 0, 0, 0.3);
}
.timeline-container .outline-3 p {
    font-size: 1rem;
}

/* #org7bd6ea1 > span > span */
/* #org0d003e5 > span:nth-child(1) > span:nth-child(1) */
/* html body div#content div#outline-container-orgb327e62.outline-2.timeline-container div#outline-container-org25a5b0a.outline-3.timeline-item div#outline-container-org0d003e5.outline-4 h4#org0d003e5 span.timestamp-wrapper span.timestamp */

.timeline-container .outline-3 h3 {
    /* content: attr(date-is); */
    position: absolute;
    left: 2em;
    font-weight: bold;
    top: 0.2em;
    display: block;
    font-family: 'Roboto', sans-serif;
    font-weight: 700;
    font-size: .785rem;
}

.timeline-container .outline-3::before {
    width: 10px;
    height: 10px;
    display: block;
    top: 1em;
    position: absolute;
    left: -8px;
    border-radius: 10px;
    content: ' ';
    border: 2px solid rgba(0.4, 0.4, 0.4, 1);
    background: white; /*rgba(0.8, 0.8, 0.8, 1);*/
}

.timeline-container .outline-3:last-child {
    -o-border-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3) 60%, transparent) 1 100%;
    border-image: -webkit-linear-gradient(top, rgba(0, 0, 0, 0.3) 60%, transparent) 1 100%;
    border-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.3) 60%, transparent) 1 100%;
}

/* Postable - where the author, date, etc is */
#postamble {
    visibility: hidden;
}
#+end_src



** Creando la línea de tiempo
Ahora teniendo el archivo orgmode y css en la misma carpeta, exportaremos el archivo orgmode a html.

La línea:

#+BEGIN_SRC 
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="timeline.css" />
#+END_SRC
Especifica que el archivo timeline.css, está en la misma carpeta que el archivo donde estará el html.

** Exportar a html
Ahora exportaremos a *.html* nuestro archivo *.org* y teniendo el archivo *.css* en la misma carpeta que el archivo *.html*,

** Fuente
- https://github.com/elisescu/org-timeline



* TODO Aplicaciones gráficas via ssh
:PROPERTIES:
:TITLE: Aplicaciones gráficas via ssh
:EXPORT_FILE_NAME: Aplicaciones gráficas via ssh
:DESCRIPTION:
:EXPORT_DATE: 2019-08-17 13:45
:CATEGORY: emacs
:TAG: raspberry,ssh,emacs, bash
:IMAGE: 
:END:

El tener la Raspberry 4, que tiene mas potencia que sus predecesoras, me ofrece la posibilidad de ejecutar aplicaciones remotamente que están ella sin necesidad de ejecutar un escritorio gráfico.

Es el caso de Emacs. Para generar este blog me conecto remotamente via ssh y utilizo *Emacs* con interfaz gráfica con toda su potencia.

De todas maneras, podremos abrir cualquier programa mediante x11 que tengamos en la Raspberry. Por ejemplo, Firefox, Chrome,...

** Accediendo
Nos situaremos en nuestro escritorio y accederemos nuestra Raspberry, Servidor,... mediante ssh y añadiendo el parámetro *-X*.

Ejemplo:
#+BEGIN_SRC 
ssh -X angel@192.168.1.100
#+END_SRC
** Ejecutar una aplicación en segundo plano y cerrar la terminal
Voy a utilizar el ejemplo de Emacs.

#+BEGIN_SRC 
ssh  -X angel@192.168.1.100 emacs /home/angel/orgmode/agenda.org &
#+END_SRC
* TODO Aplicaciones gráficas via ssh
:PROPERTIES:
:TITLE: Aplicaciones gráficas via ssh
:EXPORT_FILE_NAME: Aplicaciones gráficas via ssh
:DESCRIPTION:
:EXPORT_DATE: 2019-08-16 13:45
:CATEGORY: emacs
:TAG: raspberry,ssh,emacs, bash
:IMAGE: 
:END:

El tener la Raspberry 4, que tiene mas potencia que sus predecesoras, me ofrece la posibilidad de ejecutar aplicaciones remotamente que están ella sin necesidad de ejecutar un escritorio gráfico.

Es el caso de Emacs. Para generar este blog me conecto remotamente via ssh y utilizo *Emacs* con interfaz gráfica con toda su potencia.

De todas maneras, podremos abrir cualquier programa mediante x11 que tengamos en la Raspberry. Por ejemplo, Firefox, Chrome,...

** Accediendo
Nos situaremos en nuestro escritorio y accederemos nuestra Raspberry, Servidor,... mediante ssh y añadiendo el parámetro *-X*.

Ejemplo:
#+BEGIN_SRC 
ssh -X angel@192.168.1.100
#+END_SRC
** Ejecutar una aplicación en segundo plano y cerrar la terminal
Voy a utilizar el ejemplo de Emacs.

#+BEGIN_SRC 
ssh  -X angel@192.168.1.100 emacs /home/angel/orgmode/agenda.org &
#+END_SRC

* TODO Procesos en segundo plano o background en la terminal
:PROPERTIES:
:TITLE: Procesos en segundo plano o background en la terminal
:EXPORT_FILE_NAME: Procesos en segundo plano o background en la terminal
:DESCRIPTION:
:EXPORT_DATE: 2019-08-16 13:45
:CATEGORY: bash
:TAG: ssh, terminal
:IMAGE: 
:END:

En un Podcast os hablé se screen, una aplicación que nos permite el dejar ejecutando procesos en segundo plano. Hoy os voy ha hablar de otro método que no necesitamos instalar nada, ya que viene por defecto en el sistema.

Ejecutaremos cualquier aplicación, comando o servicio y lo enviaremos a segundo plano. Esto puede ser útil cuando ejecutamos un script que está constantemente ejecutándose en bucle, eternamente y que como sabéis, si ejecutamos *Ctrl+c*, matamos el proceso y este deja de ejecutarse.

** Lanzar a segundo plano
Si lo quieres hacer de forma automatizada, por ejemplo el caso del scritp, utilizaremos *&* para enviar al segundo plano:
#+BEGIN_SRC 
./script.sh &
#+END_SRC
Con estos dos métodos, el script ha pasado a segundo plano, background.

** Suspender el proceso
Ejecutamos el comando y lo dejamos suspendido con =Ctrl+z=.



** Ver procesos en segundo plano
Con *jobs*, veremos todos los procesos ejecutándose en segundo plano, precedidos de un numero. 
#+BEGIN_SRC 
jobs
#+END_SRC
** Resumen

| COMANDO   | ACCIÓN                        |
| comando & | Enviar a segundo plano        |
| jobs      | Ver procesos en segundo plano |
|           |                               |




* TODO Procesos en segundo plano o background en la terminal
:PROPERTIES:
:TITLE: Procesos en segundo plano o background en la terminal
:EXPORT_FILE_NAME: Procesos en segundo plano o background en la terminal
:DESCRIPTION:
:EXPORT_DATE: 2019-08-16 13:45
:CATEGORY: bash
:TAG: ssh, terminal
:IMAGE: 
:END:

En un Podcast os hablé se screen, una aplicación que nos permite el dejar ejecutando procesos en segundo plano. Hoy os voy ha hablar de otro método que no necesitamos instalar nada, ya que viene por defecto en el sistema.

Ejecutaremos cualquier aplicación, comando o servicio y lo enviaremos a segundo plano. Esto puede ser útil cuando ejecutamos un script que está constantemente ejecutándose en bucle, eternamente y que como sabéis, si ejecutamos *Ctrl+c*, matamos el proceso y este deja de ejecutarse.

** Lanzar a segundo plano
Si lo quieres hacer de forma automatizada, por ejemplo el caso del scritp, utilizaremos *&* para enviar al segundo plano:
#+BEGIN_SRC 
./script.sh &
#+END_SRC
Con estos dos métodos, el script ha pasado a segundo plano, background.

** Suspender el proceso
Ejecutamos el comando y lo dejamos suspendido con =Ctrl+z=.



** Ver procesos en segundo plano
Con *jobs*, veremos todos los procesos ejecutándose en segundo plano, precedidos de un numero. 
#+BEGIN_SRC 
jobs
#+END_SRC
** Resumen

| COMANDO   | ACCIÓN                        |
| comando & | Enviar a segundo plano        |
| jobs      | Ver procesos en segundo plano |
|           |                               |
* TODO Org-Bash-Blog: Crear, Programar y Previsualizar Posts
:PROPERTIES:
:TITLE: Org-Bash-Blog: Crear, Programar y Previsualizar Posts
:EXPORT_FILE_NAME: org
:DESCRIPTION:
:EXPORT_DATE: 2019-08-16 18:10
:CATEGORY: org-bash-blog
:TAG: ssh, terminal
:IMAGE: 
:END:
** Accediendo a Org-Bash-Podcast desde todas las carpeta
Primero crearemos un alias de nuestro script Org-Bash-Podcast, para que sea accesible desde todos los lugares de nuestro sistema.
Ademas no tendremos que utilizar comando como:
- bash org-bash-blog
- ./org-bash-blog
- sh org-bash-blog
...

Con este método, estemos donde estemos. escribiendo *org-bash-blog*, se ejecutará el script en el lugar donde estemos de nuestro sistema.
*** Configurando 
Si utilizamos Bash:
#+BEGIN_SRC 
nano .bashrc
#+END_SRC
Si utilizamos Zsh:
#+BEGIN_SRC 
nano .zshrc
#+END_SRC
Y añadiremos el alias para que estemos donde estemos, cada vez que escribamos *org-bash-blog*, ejecute el script.
#+BEGIN_SRC 
# Alias de org-bash-blog
alias org-bash-blog='/home/git/blog/org-bash-blog'
#+END_SRC
Ahora cerramos la terminal y abrimos otra sesión para que tenga efecto.

** Carpetas
Todos los archivos que vamos a tratar en este Post, se mueven entre las carpetas *program* y *.temp*.

*** .temp
Carpeta oculta de archivos temporales.

*** program 


Dentro de la carpeta *program*, crearemos el archivo *program.org*.
#+BEGIN_SRC 
touch program.org
#+END_SRC
o simplemente, situándonos dentro de la carpeta, ejecutaremos:
#+BEGIN_SRC 
emacs program.org
#+END_SRC
*** Copiar el archivo config
Dentro de la carpeta *program


** Previsualización
- esta en el config
- lo desabilito remotamente
- midori es la opción mas optima para acceder remotamente desde la raspberry
- puedes abrir todas las midori *.html

---


* TODO Org-Bash-Blog: Crear, Programar y Previsualizar Posts
:PROPERTIES:
:TITLE: Org-Bash-Blog: Crear, Programar y Previsualizar Posts
:EXPORT_FILE_NAME: org
:DESCRIPTION:
:EXPORT_DATE: 2019-08-16 18:10
:CATEGORY: org-bash-blog
:TAG: ssh, terminal
:IMAGE: 
:END:
** Accediendo a Org-Bash-Podcast desde todas las carpeta
Primero crearemos un alias de nuestro script Org-Bash-Podcast, para que sea accesible desde todos los lugares de nuestro sistema.
Ademas no tendremos que utilizar comando como:
- bash org-bash-blog
- ./org-bash-blog
- sh org-bash-blog
...

Con este método, estemos donde estemos. escribiendo *org-bash-blog*, se ejecutará el script en el lugar donde estemos de nuestro sistema.
*** Configurando 
Si utilizamos Bash:
#+BEGIN_SRC 
nano .bashrc
#+END_SRC
Si utilizamos Zsh:
#+BEGIN_SRC 
nano .zshrc
#+END_SRC
Y añadiremos el alias para que estemos donde estemos, cada vez que escribamos *org-bash-blog*, ejecute el script.
#+BEGIN_SRC 
# Alias de org-bash-blog
alias org-bash-blog='/home/git/blog/org-bash-blog'
#+END_SRC
Ahora cerramos la terminal y abrimos otra sesión para que tenga efecto.

** Carpetas
Todos los archivos que vamos a tratar en este Post, se mueven entre las carpetas *program* y *.temp*.

*** .temp
Carpeta oculta de archivos temporales.

*** program 


Dentro de la carpeta *program*, crearemos el archivo *program.org*.
#+BEGIN_SRC 
touch program.org
#+END_SRC
o simplemente, situándonos dentro de la carpeta, ejecutaremos:
#+BEGIN_SRC 
emacs program.org
#+END_SRC
*** Copiar el archivo config
Dentro de la carpeta *program


** Previsualización
- esta en el config
- lo desabilito remotamente
- midori es la opción mas optima para acceder remotamente desde la raspberry
- puedes abrir todas las midori *.html


* TODO Rclone. GUI (experimental)
:PROPERTIES:
:TITLE: Rclone. GUI (experimental)
:EXPORT_FILE_NAME: Rclone. GUI (experimental)
:DESCRIPTION:
:EXPORT_DATE: 2019-08-27 21:42
:CATEGORY:
:TAG:
:IMAGE:
:END:
** Lanzar la Gui
#+BEGIN_SRC 
rclone rcd --rc-web-gui
#+END_SRC

Ejecutar con el usuario y contraseña. En este caso, ambos son *gui*.
#+BEGIN_SRC 
rclone rcd --rc-web-gui --rc-user gui --rc-pass gui
#+END_SRC
Actualizar la Api:
#+BEGIN_SRC 
rclone rcd --rc-web-gui --rc-user gui  --rc-pass gui  --rc-web-gui-update
#+END_SRC


Al lanzar la GUI, sucede lo siguiente:

- Rclone se inicia pero solo ejecuta la API de control remoto ("rc").
- La API está vinculada a localhost con un nombre de usuario y contraseña generados automáticamente.
- Si falta el paquete de API, rclone lo descargará.
- rclone comenzará a servir los archivos del paquete API a través del mismo puerto que la API
- rclone abrirá el navegador con un login_tokenpara que pueda iniciar sesión directamente.


** Usando la GUI
Una vez que se abre la GUI, verás el panel que tiene una descripción general.

En el lado izquierdo verá una serie de botones de vista en los que puede hacer clic:

Panel de control: descripción general principal
Configuraciones: examine y cree nuevas configuraciones
Explorer: vea, descargue y cargue archivos en los sistemas de almacenamiento en la nube
Backend: vea o modifique la configuración del backend
Cerrar sesión


** Explorer
Ponemos el nombre de la nube que registramos en Rclone y podremos acceder a un navegador de archivos.


Pulsando *Side by side*, podremos explorar por varias nubes.
* SMPlayer y SMTube. Utilizando Youtube fuera del navegador
** Instalación
Es muy importante instalar la última versión de SMPlayer, ya que como he comentado muchas veces, Youtube constantemente va cambiando la api, de manera que si tienes una versión que no está actualizada, puede que no te funcione.
#+BEGIN_SRC 
sudo add-apt-repository ppa:rvm/smplayer 
sudo apt-get update 
sudo apt-get install smplayer smplayer-themes smplayer-skins smtube
#+END_SRC


* DONE Docker: Nextcloud
:PROPERTIES:
:TITLE: Docker: Nextcloud
:EXPORT_FILE_NAME: Docker Nextcloud
:DESCRIPTION:
:EXPORT_DATE: 2019-09-15 17:55
:CATEGORY: docker
:TAG: nextcloud
:IMAGE: ./images-blog/nextcloud.png
:END:

Instalar Nextcloud podemos hacerlo de muchas maneras, mediante snap, instalando un servidor web y clonando un repositorio o como os voy a explicar aquí, que considero que es el método mas optimo, mediante docker.

#+HTML: <center>
[[./images-blog/nextcloud.png]]
#+HTML: </center>

Para montar nextcloud, utilizaremos el docker de la comunidad LinuxServer.io, que ha sido el contenedor más optimizado que he probado y lo enlazaremos con un contenedor de mariadb que he creado yo mediante un Dockerfile, que es muy ligero y parte de un Alpine Linux


** Montar el Contenedor

#+BEGIN_SRC 
docker create   --name=nextcloud \
  -e PUID=1000 \
  -e PGID=1000 \
  -e TZ=Europe/Madrid  \
  -p 443:443  \
  -v $HOME/docker/nextcloud/config:/config \
  -v $HOME/docker/nextcloud/data:/data \
   linuxserver/nextcloud
#+END_SRC

* TODO Donde está el comando ifconfig y como instalarlo
:PROPERTIES:
:TITLE: Donde está el comando ifconfig y como instalarlo
:EXPORT_FILE_NAME: Donde está el comando ifconfig y como instalarlo
:DESCRIPTION:
:EXPORT_DATE: 2019-09-22 13:22
:CATEGORY: bash
:TAG: debian,raspbian,ubuntu
:IMAGE: ./images-blog/bash.png
:END:

El comando ifconfig ha quedado en desuso y ya no está disponible en los repositorios de las versiones de Debian, Raspbian,...

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Ahora para examinar la configuración de red de nuestra Debian, utilizaremos el comando *ip*.

** Uso
Para examinar la configuración de red de nuestra Debian, utilizaremos el siguiente comando:
#+BEGIN_SRC 
ip address
#+END_SRC
Más fácil de recordar:
#+BEGIN_SRC 
ip a
#+END_SRC

** Instalar ifconfig
Si deseas utilizar *ifconfig* en lugar de *ip*, debemos instalar los paquetes de *net-tools*.
#+BEGIN_SRC 
sudo apt-get install net-tools
#+END_SRC
Ahora si que podrás utilizar de nuevo *ifconfig*.
#+BEGIN_SRC 
ifconfig
#+END_SRC


* DONE Docker: Nuevo docker en ñate ánld
:PROPERTIES:
:TITLE: Docker: Nuevo docker en ñate ánld
:EXPORT_FILE_NAME: Docker--Nuevo-docker-en-nate-anld
:DESCRIPTION:
:EXPORT_DATE: 2019-10-09 02:06
:CATEGORY: aa
:TAG: aa
:IMAGE: ./images-blog/a
:END:

#+HTML: <center>
[[./images-blog/a]]
#+HTML: </center>



* TODO Cambiar el hostname en Linux
:PROPERTIES:
:TITLE: Cambiar el hostname en Linux
:EXPORT_FILE_NAME: cambiar-el-hostname-en-linux
:DESCRIPTION:
:EXPORT_DATE: 2019-10-12 15:41
:CATEGORY: bash
:TAG: terminal
:IMAGE: ./images-blog/bash.png
:END:

Si tienes una Raspberry, el hostname que aparecerá será *raspberry*. Si tienes varias, quizás quieras cambiar el nombre de este.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Vamos a ver como hacerlo

** Saber el nombre del servidor

#+BEGIN_SRC 
uname -a

hostname
#+END_SRC

** Modificar archivo /etc/hosts

Vamos a modificar en el archivo */etc/hosts*, el nombre del hostname por el nuevo nombre

#+BEGIN_SRC 
sudo nano /etc/hosts
#+END_SRC


** Modificar archivo /etc/hostname

Modificamos el archivo */etc/hostname* y lo sustituimos por el nuevo mombre también

#+BEGIN_SRC 
sudo nano /etc/hostname
#+END_SRC


** Último paso
Ponemos el nuevo nombre siguiendo este comando

#+BEGIN_SRC 
hostname <NUEVO NOMBRE>
#+END_SRC

Ejemplo:
#+BEGIN_SRC 
hostname mi_servidor
#+END_SRC
* TODO Bloquear publicidad en internet y acceso a web modificando el archivo hosts
:PROPERTIES:
:TITLE: Bloquear publicidad en internet y acceso a web modificando el archivo hosts
:EXPORT_FILE_NAME: bloquear-publicidad-en-internet-y-acceso-a-web-modificando-el-archivo-hosts
:DESCRIPTION:
:EXPORT_DATE: 2019-10-19 19:56
:CATEGORY: servidor
:TAG: raspberry
:IMAGE: ./images-blog/prohibido
:END:

#+HTML: <center>
[[./images-blog/prohibido]]
#+HTML: </center>



** Listas de Hosts
- https://github.com/StevenBlack/hosts/
- 

** Descargar archivo hosts
#+BEGIN_SRC 
0 */12 * * curl -o /etc/hosts https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts ; cat /etc/hosts.bkp >> /etc/hosts
#+END_SRC

* TODO Docker: Nextcloud
:PROPERTIES:
:TITLE: Docker: Nextcloud
:EXPORT_FILE_NAME: docker-nextcloud
:DESCRIPTION:
:EXPORT_DATE: 2019-10-26 16:58
:CATEGORY: docker
:TAG: nextcloud,nube
:IMAGE: ./images-blog/nextcloud.png
:END:

#+HTML: <center>
[[./images-blog/nextcloud.png]]
#+HTML: </center>


** Monta el contenedor
* TODO Alias
:PROPERTIES:
:TITLE: Alias
:EXPORT_FILE_NAME: alias
:DESCRIPTION:
:EXPORT_DATE: 2019-10-27 00:02
:CATEGORY: bash
:TAG: zsh
:IMAGE: ./images-blog/bash.png
:END:

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>



** Crear Alias

Para crear una *alias*, necesitamos añadir estos alias al archivo que encontramos en la carpeta $HOME/, *.bashrc*, si tienes bash o *.zshrc*, si tienes zsh.

Vamos a utilizar por ejemplo nano como editor de texto, pero puedes utilizar cualquier otro. 

*** Si utilizas Bash

#+begin_src 
cd ; nano .bashrc
#+end_src

*** Si utilizas Zsh

#+begin_src 
cd ; nano .zshrc
#+end_src

Aquí añadiremos el alias que deseemos. 

A mi por ejemplo que utilizo mucho emacs, cuando lo abro desde la terminal quiero que se me abra escribiendo solo la letra *e*.
Para hacer esto, añado al anterior archivo el alias siguiendo esta estructura:
#+begin_src 
alias e='emacs -q -nw'
#+end_src

Siempre utilizamos comillas simples para crear nuestros alias.

*** Dotfile de tus alias

Podemos crear una carpeta donde poner nuestros alias permanentes. Yo utilizo  la carpeta *~/dotfile/alias/raspberry*, como carpeta donde pondremos nuestro alias de la raspberry.

Nos iremos a la raíz de la carpeta del usuario y añadiremos a nuestro archivo *.bashrc*, si tienes bash o *.zshrc,* si tienes zsh, la siguientes líneas.
#+begin_src 
if [ -f ~/dotfile/alias/raspberry ]; then
. ~/dotfile/alias/raspberry
fi
#+end_src
Estas líneas comprueban si existe el archivo =~/dotfile/alias/raspberry=, y si es así, lo carga como si fuera parte de *.bashrc* o *.zshrc*.

Esto está muy bien porque nos permite el crear alias sin tener que tocar el archivo de configuración. Simplemente añadiendo estas tres líneas, tendremos habilitado nuestro propio archivo de configuración que podemos mover de un PC o Servidor a otro..

*Para que los cambios tengan efecto, debemos reiniciar la terminal*. Si no deseeas hacerlo, siempre puedes ejecutar el archivo de forma manual:

#+begin_src 
source ~/dotfile/alias/raspberry
#+end_src
o
#+begin_src 
. ~/dotfile/alias/raspberry/
#+end_src

** Deshabilitar Alias

Para deshabilitar un alias durante la sesión actual, ejecutaremos:
#+begin_src 
unalias nombre_alias
#+end_src

** Alias temporal

#+begin_src 
alias alias='comando'
#+end_src

** Ver todos los alias

#+begin_src 
alias
#+end_src
o
#+begin_src 
alias -p
#+end_src

** Fuentes

- https://adictec.com/como-crear-y-eliminar-alias-en-linux/


* TODO Cifrado con EncFs
:PROPERTIES:
:TITLE: Cifrado con EncFs
:EXPORT_FILE_NAME: cifrado-con-encfs
:DESCRIPTION:
:EXPORT_DATE: 2019-10-27 00:36
:CATEGORY: cifrado
:TAG: bash,zsh
:IMAGE: ./images-blog/encfs.png
:END:

#+HTML: <center>
[[./images-blog/encfs.png]]
#+HTML: </center>


** Instalación

=sudo apt install encfs=

En el momento de la instalación, aparecerá un mensaje donde nos informa que encfs puede ser vulnerable a posibles ataques.

** Creando las carpetas

Creámos las carpetas donde pondremos nuestro datos tanto cifrados y la unidad de montaje.

=mkdir ~/directorio_cifrado=
=mkdir ~/directorio_montaje=

** Iniciando encfs

=encfs ~/directorio_cifrado ~/directorio_montaje=

La opción *p*, modo paranoico, es uno de los más seguros ya que cuenta con cifrado AES de 256 bits y un bloque de 1024 bytes.

Nos pedirá la contraseña.

*Ya está montado nuestro nuevo directorio*

** Desmontar volumen montado

=fusermount -u ~/directorio_montaje=

** Modificar la contraseña

=encfsctl passwd ~/directorio_cifrado=

** Crear servicio con automontaje

Crearemos una archivo donde contendrá la clave:
#+BEGIN_SRC 
echo "CONTRASEÑA" > ~/ruta_del_archivo_con_contraseña 
chmod 700  ~/ruta_del_archivo_con_contraseña
#+END_SRC

Montar con el archivo:
=cat .encfs | encfs -S ~/.02_Org/ ~/02_Org/=


Crear un script:
#+begin_src 
PASSWORD=$(whiptail --passwordbox "Introduce tu contraseña" 8 78 --title "Contraseña" 3>&1 1>&2 2>&3)
echo $PASSWORD | encfs -S ~/.02_Org ~/02_Org
clear
#+end_src

** Programar el montaje y desmontaje

=crontab -e=

=24 21 * * * echo "contraseña" | encfs -S ~/.02_Org/ ~/02_Org/=

=24 21 * * * fusermount -u ~/02_Org=

** Extraer el fichero encfs6.xml fuera de la carpeta de sincronización

En archivo encfs6.xml, no contiene la contraseña en texto plano, aun así, puede que te sientas mejor guardándola fuera de esta carpeta:
#+BEGIN_SRC 
mv ~/.name/encfs6.xml ~/.
ENCFS6_CONFIG=~/encfs6.xml encfs ~/.name ~/name
#+END_SRC

** Fuente

- https://www.solvetic.com/tutoriales/article/5483-como-encriptar-datos-con-encfs-en-ubuntu-18-04-linux/
- https://techblog.jeppson.org/2018/07/mount-encfs-folder-on-startup-with-systemd/
- https://wiki.archlinux.org/index.php/EncFS

* TODO Cifrado Cesar
:PROPERTIES:
:TITLE: Cifrado Cesar
:EXPORT_FILE_NAME: cifrado-cesar
:DESCRIPTION:
:EXPORT_DATE: 2019-10-27 00:39
:CATEGORY: cifrado
:TAG: bash
:IMAGE: ./images-blog/encfs.png
:END:

#+HTML: <center>
[[./images-blog/encfs.png]]
#+HTML: </center>




Cifrado Cesar

Cifrado Cesar con el comando tr en Linux
Scripts de cifrado

A modo de ejemplo de algoritmo de sustitución, podemos ejecutar el siguiente comando para cifrar mediante codificación Cesar un archivo de texto plano.

Para ello vamos a partir de un archivo que hemos creado previamente llamado documento 

Vamos a realizar los siguientes pasos:

cat documento

Visualizamos el contenido del archivo llamado documento con el comando cat.

=cat documento | tr [a-z] [d-zabc] | tr [A-Z] [D-ZABC] > documento_cesar=


=echo "hola" | tr [a-z] [d-zabc] | tr [A-Z] [D-ZABC]=

Con el comando cat abrimos el documento.
Con las tuberías (pipes) | concatenamos los comandos.
Con el comando tr realizamos una sustitución carácter a carácter.
Especificamos al comando tr el método de sustitución de las minúsculas [a-z]... y las mayúsculas [A-Z]...
Con el carácter > redirigimos el contenido creado a un nuevo documento llamado documento_cesar.

cat documento_cesar

Visualizamos el nuevo documento cifrado 

Para descifrar el contenido basta con invertir los parámetros que especificamos en el comando tr.

=cat documento_cesar | tr [d-zabc] [a-z] | tr [D-ZABC] [A-Z] > documento_cesar2=
* TODO Combinar titulares de rss en Python y con feedparser
:PROPERTIES:
:TITLE: Combinar titulares de rss en Python y con feedparser
:EXPORT_FILE_NAME: combinar-titulares-de-rss-en-python-y-con-feedparser
:DESCRIPTION:
:EXPORT_DATE: 2019-10-27 01:11
:CATEGORY: python
:TAG: rss
:IMAGE: ./images-blog/python.png
:END:

#+HTML: <center>
[[./images-blog/python.png]]
#+HTML: </center>

** Instalación de feedparser
#+BEGIN_SRC 
pip install feedparser
#+END_SRC
** Script
#+BEGIN_SRC 
import feedparser
 
# Function to fetch the rss feed and return the parsed RSS
def parseRSS( rss_url ):
    return feedparser.parse( rss_url ) 
    
# Function grabs the rss feed headlines (titles) and returns them as a list
def getHeadlines( rss_url ):
    headlines = []
    
    feed = parseRSS( rss_url )
    for newsitem in feed['items']:
        headlines.append(newsitem['title'])
    
    return headlines
 
# A list to hold all headlines
allheadlines = []
 
# List of RSS feeds that we will fetch and combine
newsurls = {
    'atareao.es':          'https://atareao.es/feed',
    'Blog de Lazaro':      'https://elblogdelazaro.gitlab.io/index.xml',
    'ochobitshacenunbyte':        'https://www.ochobitshacenunbyte.com/feed',
    'Linuxito':            'https://www.linuxito.com/?format=feed&type=rss'
}
 
# Iterate over the feed urls
for key,url in newsurls.items():
    # Call getHeadlines() and combine the returned headlines with allheadlines
    allheadlines.extend( getHeadlines( url ) )
 
 
# Iterate over the allheadlines list and print each headline
for hl in allheadlines:
    print(hl)
 
 
# end of code 
#+END_SRC
** Fuente
- https://jcutrer.com/python/python-tutorial-howto-parse-rss-headlines
* TODO Formatear un Pendrive o Tarjeta SD en Fat32
:PROPERTIES:
:TITLE: Formatear un Pendrive o Tarjeta SD en Fat32
:EXPORT_FILE_NAME: formatear-un-pendrive-o-tarjeta-sd-en-fat32
:DESCRIPTION:
:EXPORT_DATE: 2019-10-27 12:30
:CATEGORY: bash
:TAG: raspberry
:IMAGE: ./images-blog/sd.png
:END:

#+HTML: <center>
[[./images-blog/sd.png]]
#+HTML: </center>


** Localizar nuestra SD o USB
Primero localizaremos la unidad que hemos conectado
#+BEGIN_SRC 
df -h
#+END_SRC
** Desmontar unidad
Para formatear, lo primero que tenemos que hacer es *desmontar* el Pendrive o SD.
Por ejemplo, en mi caso, la unidad que deseo formatear y está montada como *sdb1*.
#+BEGIN_SRC 
sudo umount  /dev/sdb1
#+END_SRC
** Formatear en Fat32
Vamos a formatear a Fat32. Para ello escribiremos en la terminal
#+BEGIN_SRC 
sudo mkfs.vfat -F 32 -n "NOMBRE DE LA UNIDAD" /dev/sdb1
#+END_SRC



* TODO Servidor OpenVPN en 5 minutos
:PROPERTIES:
:TITLE: Servidor OpenVPN en 5 minutos
:EXPORT_FILE_NAME: servidor-openvpn-en-5-minutos
:DESCRIPTION:
:EXPORT_DATE: 2019-11-05 19:04
:CATEGORY: vpn
:TAG: bash,raspberry,ubuntu
:IMAGE: ./images-blog/openvpn.png
:END:

#+HTML: <center>
[[./images-blog/openvpn.png]]
#+HTML: </center>


** Instalar el script
Para instalar OpenVPN mediante el script de *pivpn*, es tan sencillo como escribir en nuestra terminal:

#+BEGIN_SRC 
curl -L https://install.pivpn.io | bash
#+END_SRC

** Crear usuario

#+BEGIN_SRC 
pivpn add
#+END_SRC

Ahora el script nos preguntará:
- Introduce el nombre de usuario
- Durante cuantos dias tendrá validez el certificado
- Introduce la contraseña


* TODO UFW. El cortafuegos de Linux, facil de adminstrar
:PROPERTIES:
:TITLE: UFW. El cortafuegos de Linux, facil de adminstrar
:EXPORT_FILE_NAME: ufw-el-cortafuegos-de-linux-facil-de-adminstrar
:DESCRIPTION:
:EXPORT_DATE: 2019-11-08 22:05
:CATEGORY: cortafuegos
:TAG: ssh,bash,terminal
:IMAGE: ./images-blog/ufw.png
:END:

#+HTML: <center>
[[./images-blog/ufw.png]]
#+HTML: </center>

** Instalación
#+BEGIN_SRC 
sudo apt install ufw
#+END_SRC
** Habilitar ufw
#+BEGIN_SRC 
ufw enable
#+END_SRC
Podemos ver uno poco el estado actual del cortafuegos y los puertos habilitados mediante *status verbose*.

#+BEGIN_SRC 
ufw status verbose
#+END_SRC

** Bloqueo de tráfico entrante o saliente


Permitir todo el tráfico saliente
#+BEGIN_SRC 
sudo ufw default allow outgoing
#+END_SRC

Bloquear el tráfico entrante
#+BEGIN_SRC 
sudo ufw default deny incoming
#+END_SRC

Bloquear el tráfico saliente
#+BEGIN_SRC 
sudo ufw default deny outgoing
#+END_SRC

** Listar Aplicaciones disponibles
Si no recordamos el puerto de cada aplicación instalada, podemos utilizar el nombre de la aplicación. Para conocer todas las aplicaciones disponibles, utilizaremos:

#+BEGIN_SRC 
ufw app list
#+END_SRC
Añadir los puertos de syncthing
#+BEGIN_SRC 
sudo ufw allow syncthing
#+END_SRC


** Permitir o denegar trafico a través de  puertos 
*** Habilitar un puerto  
Para seguir con la configuración de ufw y no perdamos el enlace con nuestro servidor, si estamos utilizando ssh por su puerto por defecto, debemos habilitar el puerto 22.
#+BEGIN_SRC 
sudo ufw allow 22
#+END_SRC

Voy a habilitar también el puerto 80 y 443 (http y https) que utilizo para el acceso a mi servidor web y permitir el trafico al servidor en proxi inverso de letsencript
#+BEGIN_SRC 
sudo ufw allow 80
sudo ufw allow 443
#+END_SRC

Denegar el tráfico al puerto 80
#+BEGIN_SRC 
sudo ufw deny 80
#+END_SRC
** Especificando el protocolo TCP o UDP
Por ejemplo, vamos a utilizar el puerto de OpenVPN y el protocolo UPD.
#+BEGIN_SRC 
sudo ufw allow 1194/udp
#+END_SRC
Permitir el acceso al puerto 80 y los dos protocolos de ejemplo:
#+BEGIN_SRC 
sudo ufw allow 80
sudo ufw allow 80/tcp
sudo ufw allow 80/udp
#+END_SRC

** Denegar el tráfico
Denegar el tráfico del puerto 100
#+BEGIN_SRC 
sudo ufw deny 100
#+END_SRC
** Permitir el acceso a determinadas IP's
Permitir el acceso a través del puerto 22, servidor SSH, solo a la IP 192.168.1.100. El mismo ejemplo serviría para IP's públicas
#+BEGIN_SRC 
sudo ufw allow from 192.168.1.100 22
#+END_SRC

** Proteger tu Servidor SSH ataques de fuerza bruta
Si alguien intenta iniciar 6 o más conexiones en los últimos 30 segundos, introduciendo mal la contraseña, *ufw* bloqueará el acceso.
#+BEGIN_SRC 
sudo ufw limit ssh
#+END_SRC
** Rango de puertos
Ejemplos que permiten un rango de puertos
#+BEGIN_SRC 
sudo ufw allow 80:100/tcp
sudo ufw allow 80:100/udp
#+END_SRC

Limitar del puerto 0 al 29999 y del 30006 al 65535.
#+BEGIN_SRC 
ufw limit from any to any port 0:29999,30006:65535
#+END_SRC
** Modificar las reglas creadas
#+BEGIN_SRC 
sudo ufw status numbered
#+END_SRC
Mediante este comando, la terminal nos mostrará todas las reglas creadas, precedidas de un número.

Borraremos la regla número *10*.
#+BEGIN_SRC 
sudo ufw delete 10
#+END_SRC
** Restaurar configuración inicial
#+BEGIN_SRC 
sudo ufw reset
#+END_SRC
* TODO Configura Jellyfin para que no se detenga el contenedor
:PROPERTIES:
:TITLE: Configura Jellyfin para que no se detenga el contenedor
:EXPORT_FILE_NAME: configura-jellyfin-para-que-no-se-detenga-el-contenedor
:DESCRIPTION:
:EXPORT_DATE: 2019-10-31 19:55
:CATEGORY: jellyfin
:TAG: docker,multimedia
:IMAGE: ./images-blog/jellyfin.png
:END:

Si tienes instalado Jellyfin mediante un
#+HTML: <center>
[[./images-blog/jellyfin.png]]
#+HTML: </center>



** Desactiva la monitorización en tiempo real

Activar la monitorización en tiempo real
Los cambios se procesarán inmediatamente, en sistemas de archivo que lo soporten.


* DONE Docker: Mariadb
:PROPERTIES:
:TITLE: Docker: Mariadb
:EXPORT_FILE_NAME: Docker: Mariadb
:DESCRIPTION:
:EXPORT_DATE: 2019-09-15 17:55
:CATEGORY: docker
:TAG: mariadb
:IMAGE: ./images-blog/mariadb.png
:END:

Mariadb es una base de datos que hemos utilizado para muchos servicios y que podemos instalarla desde un docker. Hay dockers de mariadb tanto oficial, de la comunidad LinuxServer,... Pero yo he optado por crear uno yo mismo.

El Docker que creé lo subí al DockerHub, y dos meses después ya supera mucho más de 10.000 descargas.


#+HTML: <center>
[[./images-blog/mariadb.png]]
#+HTML: </center>

El objetivo erá utilizar un mariadb muy ligero que partiera de un Alpine Linux.

** Montar el Docker
El puerto por defecto de mariadb, que es el 3306, yo en le ejemplo lo estoy desviando al 3307. Puedes utilizar el que tu desees.

Recuerda poner la contraseña de la base de datos, poniéndola en lugar de =my-secret-pw=.

Si creas el contenedor como está aquí:
- usuario -> root
- ip -> La del servidor
- Puerto -> 3307
- Contraseña -> my-secret-pw

Las carpetas que están en *-v*, son las carpetas de configuración de mariadb.

*** Para ARM
#+BEGIN_SRC 
docker run --name mariadb \
-p  3307:3306 \
-v $HOME/docker/mariadb/config:/var/lib/mysql \
-v $HOME/docker/mariadb/conf.d:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=my-secret-pw -d \
ugeek/mariadb:arm
#+END_SRC

*** Para amd64 
Arquitectura 64bits
#+BEGIN_SRC 
docker run --name mariadb \
-p  3307:3306 \
-v $HOME/docker/mariadb/config:/var/lib/mysql \
-v $HOME/docker/mariadb/conf.d:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=my-secret-pw -d \
ugeek/mariadb:amd64
#+END_SRC


** Crea la base de datos 
Entramos dentro del contenedor:
#+BEGIN_SRC 
docker exec -i -t mariadb sh
#+END_SRC
Una vez dentro, ejecutaremos los siguiente comandos. 

*** Ejecutamos mariadb
#+BEGIN_SRC 
mysql -u root -p
#+END_SRC
*** Creamos la base de datos
#+BEGIN_SRC 
CREATE DATABASE IF NOT EXISTS <name>; 
#+END_SRC
Damos privilegios para que acceda el servicio:
#+BEGIN_SRC 
GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost';
#+END_SRC
#+BEGIN_SRC 
flush privileges;
#+END_SRC
Salimos de mariadb:
#+BEGIN_SRC 
\q
#+END_SRC
Salimos del contenedor:
#+BEGIN_SRC 
exit
#+END_SRC
* TODO i3wm. Instalando la última versión en Debian o Ubuntu
:PROPERTIES:
:TITLE: i3wm. Instalando la última versión en Debian o Ubuntu
:EXPORT_FILE_NAME: i3wm-instalando-la-ultima-version-en-debian-o-ubuntu
:DESCRIPTION:
:EXPORT_DATE: 2019-11-13 20:21
:CATEGORY: i3
:TAG: i3wm,debian,ubuntu
:IMAGE: ./images-blog/i3.png
:END:

#+HTML: <center>
[[./images-blog/i3.png]]
#+HTML: </center>



* DONE Remmina. De los mejores Clientes VNC
:PROPERTIES:
:TITLE: Remmina. De los mejores Clientes VNC
:EXPORT_FILE_NAME: remmina-de-los-mejores-clientes-vnc
:DESCRIPTION:
:EXPORT_DATE: 2019-12-18 17:57
:CATEGORY: vnc
:TAG: servidor,escritorio
:IMAGE: ./images-blog/remmina.png
:END:


Utilizo VNC para conectarme a mis servidores o PC's remotos con interfaz gráfica. Hay muchos clientes de VNC, pero *remmina* es uno de mis favoritos, porque puedo acceder a mis escritorios desde el icono en la bandeja de entrada situado en mi escritorio.

Os recomiendo este cliente, ya que en linux tenemos muchos clientes buenísimos y livianos, pero pocos tan sencillos e intuitivos como este.

#+HTML: <center>
[[./images-blog/remmina.png]]
#+HTML: </center>


Es una aplicación que tiene constantes actualizaciones

** Instalación
*** Desde Repositorios 
#+BEGIN_SRC 
sudo apt install remmina
#+END_SRC
*** Snap

#+begin_src 
sudo snap install remmina
#+end_src

*** Flatpak

#+begin_src 
flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
flatpak install --user flathub org.remmina.Remmina
flatpak run --user org.remmina.Remmina
#+end_src

*** PPA todas las distros
Visita la web: https://remmina.org/how-to-install-remmina/
** Archivos de configuración
Puedes guardar tu configuración para exportarlo a otra máquina, copiando los archivos de configuración en las siguientes rutas:
*** Repositorios o PPA
Si has instalado desde repositorios o PPA:
#+BEGIN_SRC 
/home/usuario/.local/share/remmina/ 
/home/usuario/.remmina/
#+END_SRC

*** Flatpak
#+BEGIN_SRC 
~/.var/app/org.remmina.Remmina/data/remmina/
#+END_SRC
*** Snap
#+BEGIN_SRC 
~/snap/remmina/
#+END_SRC
** Icono en bandeja de entrada
Escribe en tu terminal:
#+begin_src 
Remmina -i
#+end_src

Si utilizas un escritorio como *i3wm*, puedes hacer que inicie al arranque del escritorio, escribiendo en tu archivo de configuración:
#+BEGIN_SRC 
exec --no-startup-id remmina -i
#+END_SRC
** Ayuda 

La terminal nos muestra muchas de las posibilidades de *remmina*. Para acceder a esta ayuda, escribe en tu terminal: =remmina -h=

#+BEGIN_SRC 
  org.remmina.Remmina [OPCIÓN…] FILE

Opciones de ayuda:
  -h, --help                  Mostrar opciones de ayuda
  --help-all                  Muestra todas las opciones de ayuda
  --help-gapplication         Mostrar las opciones de GApplication
  --help-gtk                  Mostrar opciones GTK+

Opciones de la aplicación:
  -a, --about                 Mostrar la ventana Acerca de
  -c, --connect=FILE          Connect to desktop described by file (.remmina or type supported by plugin)
  -e, --edit=FILE             Edit desktop connection described by file (.remmina or type supported by plugin)
  -k, --kiosk                 Start Remmina in Kiosk mode
  -n, --new                   Crear un perfil de conexión nuevo
  -p, --pref=PAGENR           Mostrar página de diálogo de preferencias
  -x, --plugin=PLUGIN         Ejecutar el complemento
  -q, --quit                  Salir de la aplicación
  -s, --server=SERVER         Usar nombre de servidor predeterminado (para --nuevo)
  -t, --protocol=PROTOCOL     Usar protocolo predeterminado (para --nuevo)
  -i, --icon                  Iniciar como icono de la bandeja
  -v, --version               Mostrar la versión de la aplicación
  -V, --full-version          Show the application’s version, including the plugin versions
  --display=VISOR             Visor [display] X que usar
#+END_SRC

** Fuente
- https://remmina.org

** Fuentes

- https://remmina.org/
- https://snapcraft.io/remmina
* TODO Instalar Wine 4 en Debian Buster
:PROPERTIES:
:TITLE: Instalar Wine 4 en Debian Buster
:EXPORT_FILE_NAME: instalar-wine-4-en-debian-buster
:DESCRIPTION:
:EXPORT_DATE: 2019-12-22 13:16
:CATEGORY: windows
:TAG: bash,virtualización
:IMAGE: ./images-blog/wine.png
:END:

#+HTML: <center>
[[./images-blog/wine.png]]
#+HTML: </center>

Wine es un software de código abierto que le permite ejecutar aplicaciones de Windows en Linux. Permite compilar aplicaciones de Windows para ayudar a portarlas a sistemas similares a Unix.

Vamos a ver la instalación en Debian Buster, como vereis, es muy sencillo.

** Instalación desde Repositorios
Tan simple como:

*** Rama Estable
#+BEGIN_SRC 
sudo apt install wine-stable
#+END_SRC

*** Rama Desarrolladores
#+BEGIN_SRC 
sudo apt install wine-development
#+END_SRC


** Instalación

*** Habilitar arquitectura de 32bits
Si tu máquina tiene arquitectura 64bits, debes de habilitar la arquietectura de 32bits.
#+BEGIN_SRC 
sudo dpkg --add-architecture i386 
#+END_SRC

*** Agregando el repositorio WineHQ

#+BEGIN_SRC 
wget -qO - https://dl.winehq.org/wine-builds/winehq.key | sudo apt-key add -
#+END_SRC


#+BEGIN_SRC 
sudo apt-add-repository https://dl.winehq.org/wine-builds/debian/
#+END_SRC

#+BEGIN_SRC 
sudo apt update
#+END_SRC

*** Instalando Wine 4. Rama estable
Vamos a actualizar el sistema y posteriormente, instalaremos wine en su rama estable


#+BEGIN_SRC 
sudo apt install winehq-stable
#+END_SRC

*** Instalando Wine 4. Rama Desarrollo
Para instalar la rama de desarrollo

#+BEGIN_SRC 
sudo apt install winehq-devel
#+END_SRC

* TODO Utilizando Wine
:PROPERTIES:
:TITLE: Utilizando Wine
:EXPORT_FILE_NAME: utilizando-wine
:DESCRIPTION:
:EXPORT_DATE: 2019-12-22 13:40
:CATEGORY: windows
:TAG: bash,virtualización
:IMAGE: ./images-blog/wine.png
:END:

#+HTML: <center>
[[./images-blog/wine.png]]
#+HTML: </center>



- https://www.atareao.es/tutorial/linux-mint-cinnamon/aplicaciones-windows-en-linux/
* TODO Restaurar el Backup de Google Fotos
:PROPERTIES:
:TITLE: Restaurar el Backup de Google Fotos
:EXPORT_FILE_NAME: restaurar-el-backup-de-google-fotos
:DESCRIPTION:
:EXPORT_DATE: 2019-12-22 21:43
:CATEGORY: fotos
:TAG: google,bash
:IMAGE: ./images-blog/googlefotos.png
:END:

Después de tanto tiempo con Google Fotos, ha llegado el momento de descargar todo el backup que está en la nube y ver si realmente se está haciendo correctamente.

#+HTML: <center>
[[./images-blog/googlefotos.png]]
#+HTML: </center>

Si hay algo que me gusta de Google, es que a diferencia de otros servicios alojados en servidores ajenos, Google te facilita el descargar el contenido de todos sus servicios.

** Descargar los archivos
Para descargar las fotos, accederemos a la página https://takeout.google.com/settings/takeout, que es una página que pone a nuestra disposición para poder descargar todo el contenido de todos los servicios que tengamos en google, y accederemos al apartado de *Google Fotos*.

Existe la p

** Descomprimir todos los archivos 

#+BEGIN_SRC 
unzip "*.zip"
#+END_SRC


Descomprimir si lo hemos dejado en otras subcarpetas:

#+BEGIN_SRC 
find . -name "*.zip" -exec unzip {} \;
#+END_SRC





** Fuentes
- https://photos.google.com/
- https://takeout.google.com/settings/takeout

* TODO RetroPie. Convierte tu consola en una máquina recreativa
:PROPERTIES:
:TITLE: RetroPie. Convierte tu consola en una máquina recreativa
:EXPORT_FILE_NAME: retropie-convierte-tu-consola-en-una-maquina-recreativa
:DESCRIPTION:
:EXPORT_DATE: 2019-12-23 12:30
:CATEGORY: juegos
:TAG: raspberry
:IMAGE: ./images-blog/retropie.png
:END:

#+HTML: <center>
[[./images-blog/retropie.png]]
#+HTML: </center>



** Instalar ROMs
*** Webs
http://www.emuparadise.me
http://www.coolrom.com

*** Juegos
BEST OF THE BEST - ¡Retropie & Windows! ~9GB GDrive, [20.12.19 11:59]
[Forwarded from Nportillo]
---DESCARGAS---
1⃣6⃣  Imagen Raspberry 16GB (incluye juegos PSX sin intros/banda sonora)
   http://tiny.cc/BOB_RETROPIE (12.1GB)

💻  Lo mismo para Windows + SEGA Saturn + Gamecube + Wii + PS2 +DOS/WIN + 3do, no necesita instalación (portable)
Opción 1: http://tiny.cc/BOB_WINDOWS (Google drive)
Opción 2: http://tiny.cc/BOB_WINDOWS_ALTERNATIVO (archive.org, descarga directa o torrent)
Opción 3: http://tiny.cc/BOB_TORRENT 


3⃣2⃣ Raspberry 32GB = 1⃣6⃣ + 📓 + 📕 (selección)
   http://tiny.cc/BOB32_1
   http://tiny.cc/BOB32_2


6⃣4⃣ Raspberry 64GB = 1⃣6⃣ + 📓+📔+📕+♦️+🔶
   http://tiny.cc/BOB64_1 
   http://tiny.cc/BOB64_2
   http://tiny.cc/BOB64_3
   http://tiny.cc/BOB64_4

8⃣ Edición Compacta Raspberry para microSD de 8GB. Simplemente menos juegos, pero mismos sistemas.
http://tiny.cc/BOB_8GB_RETROPIE (5GB)


---PACKS OPCIONALES para complementar---
📕 Pack Best 50 PSX games ever con sagas y los 37 juegos completos http://tiny.cc/BOB_BEST_50_PSX

📗 Pack best 30 Dreamcast games http://tiny.cc/BOB_BEST_30_DREAMCAST

📙 Pack best 25 SEGA Saturn http://tiny.cc/BOB_BEST_25_SATURN

📘 Pack best 20+ Game Cube
http://tiny.cc/BOB_BEST_20_GAMECUBE

📒 Pack Romset NAOMI/Atomiswave http://tiny.cc/BOB_NAOMI_AW

📓 Pack PCEngine CD http://tiny.cc/BOB_PCECD

📔  Pack NeoGeoCD: http://tiny.cc/BOB_NEOGEOCD

♦️  Pack Daphne: http://tiny.cc/BOB_DAPHNE

🔷 Pack 3do: http://tiny.cc/BOB_3DO

🔶 Pack SEGACD: http://tiny.cc/BOB_SEGACD


** Fuentes
- https://retropie.org.uk
- https://omniretro.com/emuladores/como-instalar-y-configurar-retropie-en-raspberry-pi
* DONE test
** esto es un prueba
** test
* DONE Convertir texto a voz con espeak
:PROPERTIES:
:TITLE: Convertir texto a voz con espeak
:EXPORT_FILE_NAME: convertir-texto-a-voz-con-espeak
:DESCRIPTION:
:EXPORT_DATE: 2019-12-23 16:01
:CATEGORY: tts
:TAG: bash
:IMAGE: ./images-blog/espeak.png
:END:

Este medio día, he visto nuevamente un clásico, Juegos de Guerra (War Games) y la voz del Súper ordenador me ha recordado a mi Raspberry con espeak.  

Mediante la terminal, podemos hacer que nuestro GNU/Linux hable como un robot y lea todo el texto que introduzcamos en nuestra terminal, archivo, etc...

#+HTML: <center>
[[./images-blog/espeak.png]]
#+HTML: </center>

Espeak es un tts (text to speech), que precisamente no reproduce una voz muy real. Hoy en día la voz tts de google suena muchísimo mejor, pero puede ser muy útil para algún proyecto sencillo en nuestra Raspberry.


** Instalación
Espeak esta en los respositorios de todas las distros. La instalación de ubuntu, debian,raspbian,... es tan sencilla como:
#+BEGIN_SRC 
sudo apt-get install espeak
#+END_SRC
** Funcionamiento
Tan sencillo como:
#+BEGIN_SRC 
espeak 'Hello! How are you!'
#+END_SRC
** Idiomas
Por defecto, *espeak* habla en inglés. Así que si quieres que lea el texto con pronunciación en castellano, tendremos que indicarle que así lo haga.

Para ver todos los idiomas disponibles:
#+BEGIN_SRC 
espeak --voices
#+END_SRC
*** Castellano

Primero, indicaremos mediante *-v*, que vamos a utilizar un nuevo idioma.

Para indicaremos que es castellano, escribiremos *es*.

El resultado final será: *-ves*.
#+BEGIN_SRC 
espeak -ves 'Hola, ahora hablo castellano'
#+END_SRC
*** Catalán
También podemos utilizar el catalán entre otros idiomas. Nos ayudaremos de *grep* para ver si está disponible el catalan
#+BEGIN_SRC 
espeak --voices | grep catalan
#+END_SRC
Probemos que tal suena:
#+BEGIN_SRC 
espeak -vca 'Bon dia'
#+END_SRC

** Listar voces disponibles
#+BEGIN_SRC 
espeak --voices=variant
#+END_SRC
Para indicar la voz, tenemos que añadir *+* acompañado de la voz que deseemos. Hay varias opciones, *m* corresponde a una voz masculina y *f* a una femenina.

Voces disponibles en Debian Buster:

#+BEGIN_SRC 
Pty Language Age/Gender VoiceName          File          Other Languages
 5  variant        F  female2              !v/f2         
 5  variant        F  female3              !v/f3         
 5  variant        F  female4              !v/f4         
 5  variant        F  female5              !v/f5         
 5  variant        F  female_whisper       !v/whisperf   
 5  variant        -  klatt                !v/klatt      
 5  variant        -  klatt2               !v/klatt2     
 5  variant        -  klatt3               !v/klatt3     
 5  variant        -  klatt4               !v/klatt4     
 5  variant        M  male2                !v/m2         
 5  variant        M  male3                !v/m3         
 5  variant        M  male4                !v/m4         
 5  variant        M  male5                !v/m5         
 5  variant        M  male6                !v/m6         
 5  variant        M  male7                !v/m7         
 5  variant        M  whisper              !v/whisper    
 5  variant      70F  female1              !v/f1         
 5  variant      70M  croak                !v/croak      
 5  variant      70M  male1                !v/m1 
#+END_SRC

Vamos a ver un ejemplo:
#+BEGIN_SRC 
espeak -ves+f2 'Esto es una pruba de voz desde mi Raspberry'
#+END_SRC
** Velocidad
Podemos variar la velocidad de reproducción de la voz. Para eso utilizaremos la opción *-s*.

El valor por defecto es *160*. 

Veamos un ejemplo:
#+BEGIN_SRC 
espeak -ves+f2 -s130 'Ahora hablo más lento' 
#+END_SRC
** Tono
Para personalizar aun más la voz elegida, utilizaremos *-p*.

Por defecto, el todo de voz está a *50.

#+BEGIN_SRC 
espeak -ves+f2 -s130 -p80 'Ahora he cambiado un poco mi tono de voz'
#+END_SRC

** Leer un archivo de texto
Ya hemos decidido el idioma, velocidad, voz,... Ejecutar *espeak* mediante *echo*, está bien como respuestas a scripts. Si queremos que lea un archivo de texto:
#+BEGIN_SRC 
espeak -f archivo.txt
#+END_SRC
Siguiendo la configuración previa:
#+BEGIN_SRC 
espeak -ves+f2 -s130 -p80 -f archivo.txt
#+END_SRC

** Guardar la voz en un archivo de audio 
En lugar de escucharlo por nuestros altavoces, podemos hacer que todo lo que lea espeak lo guarde en un archivo de audio tipo wav, ogg o mp3.

Para ello haremos uso de la opción *-w*.

Espeak por defecto, solo tiene la opción para exportar a *wav*, así que para obtener un archivo *mp3* o *ogg*, tendremos que convertirlo.

*** Wav
Voy a exportar el archivo a *.wav*.
#+BEGIN_SRC 
espeak -ves+f2 -s130 -p80 -f archivo.txt -w 'archivo de audio.wav'
#+END_SRC
*** Ogg
Instalaremos vorbis-tools
#+BEGIN_SRC 
sudo apt install vorbis-tools
#+END_SRC
Convertir el archivo wav en ogg.
#+BEGIN_SRC 
oggenc 'archivo de audio.wav'
#+END_SRC


*** mp3

Para convertir de wav a mp3, utilizaremos *lame*.

Primero lo instalaremos
#+BEGIN_SRC 
sudo apt install lame
#+END_SRC
Ahora convertimos:
#+BEGIN_SRC 
lame archivo.wav archivo.mp3
#+END_SRC
** Versión gráfica de espeak
Si no te gusta la terminal, podemos utilizar una aplicación gráfica llamada gespeaker
#+BEGIN_SRC 
sudo apt install gespeaker
#+END_SRC

** Ayuda
#+BEGIN_SRC 
espeak -h
#+END_SRC
** Fuente
- http://espeak.sourceforge.net/
- https://debianfacil.wordpress.com/2009/03/10/espeak-convertir-texto-en-voz/
* TODO Servidor de Wireguard
:PROPERTIES:
:TITLE: Servidor de Wireguard
:EXPORT_FILE_NAME: servidor-de-wireguard
:DESCRIPTION:
:EXPORT_DATE: 2019-12-26 20:26
:CATEGORY: vpn
:TAG: wireguard,debian,ubuntu,raspbian
:IMAGE: ./images-blog/wireguard.png
:END:

Vamos a instalar un servidor Wireguard en una debian, ubuntu,... Y nos vamos a conectar desde un PC remoto o móvil.

#+HTML: <center>
[[./images-blog/wireguard.png]]
#+HTML: </center>


** Instalación
Podemos instalar el servidor-cliente disponibles para cualquier distro en https://www.wireguard.com/install/

*** Ubuntu 19.10
A partir de la versión de ubuntu 19.10 ya viene en los repositorios oficiales con un simple:

#+BEGIN_SRC 
sudo apt install wireguard
#+END_SRC
*** Debian Buster

En debian, por ejemplo, tenemos que instalarlo mediante PPA:

#+BEGIN_SRC 
echo "deb http://deb.debian.org/debian/ unstable main" > /etc/apt/sources.list.d/unstable.list
printf 'Package: *\nPin: release a=unstable\nPin-Priority: 90\n' > /etc/apt/preferences.d/limit-unstable
apt update
apt install wireguard
#+END_SRC


** Configurar Servidor
Ya tenemos instalado wireguard en nuestra máquina y ahora comenzaremos con la configuración. 

*** Creando el archivo de configuración
Vamos a crear la carpeta */etc/wireguard/* en el caso que no esté creada. En debian Buster, cuando ejecuté por primera vez *wg* ya estaba creada. La creamos y accedemos a la carpeta.
#+BEGIN_SRC 
mkdir /etc/wireguard 
cd /etc/wireguard
#+END_SRC
Creamos el archivo de configuración *wg0.conf*.
#+BEGIN_SRC 
bash -c 'umask 077; touch wg0.conf'
#+END_SRC

*** Interfaz de Red e ip Privada

Creamos la intefaz de red wg0 y estableceremos una ip privada
#+BEGIN_SRC 
ip link add dev wg0 type wireguard
ip addr add dev wg0 10.0.0.1/24
#+END_SRC*
*** Levantar el servicio 
Levantamos el servicio generando la llave privada, que solo estará en el servidor. La llave pública es la que compartiremos con los clientes:

#+BEGIN_SRC 
wg set wg0 listen-port 51820 private-key <(wg genkey)
#+END_SRC

Si todo está funcionando correctamente, con este comando vamos a guardar la configuración actual
#+BEGIN_SRC 
wg-quick save wg0
#+END_SRC
Vamos a ver la configuración que todo esté correcto
#+BEGIN_SRC 
cat wg0.conf 
#+END_SRC

*** Ver llave pública
Mediante el comando *wg*, nos va a mostrar la llave pública que podemos añadir en los clientes. También nos mostrará el estado actual del servidor.
#+BEGIN_SRC 
wg
#+END_SRC
*** Creando el servicio
Para que cada vez que iniciemos nuestra máquina, inicie el servicio, vamos crearlo con systemd.
#+BEGIN_SRC 
systemctl enable wg-quick@wg0.service
#+END_SRC
** Las IP's de Wireguard
En este ejemplo, hemos creado una interfaz de Red para el servidor *10.0.0.1/24*. 

Ahora por cada cliente, vamos a crear una interfaz de red que conocerá nuestro servidor, por ejemplo: *10.0.0.2/24*, *10.0.0.3/24*,...

** Archivo de Configuración

Archivo wg0 de nuestro servidor. *Interface* es el cliente y cada *Peer* es un cliente.

#+BEGIN_SRC 
[Interface]
Address = 10.0.0.1/24
ListenPort = 51820
PrivateKey = hqh89p34y8rgqh8ovhq8èhvhq3418y43tg1hg8herv=

[Peer]
PublicKey = asdvhaioiovbq807134qorh8yvr1q3049uy1hvohq89Y=
Endpoint = 10.0.0.2:51820
AllowedIPs = 0.0.0.0/0, ::/0#              
#+END_SRC
* DONE Bullet Journal Digital en OrgMode
:PROPERTIES:
:TITLE: Bullet Journal Digital en OrgMode
:EXPORT_FILE_NAME: bullet-journal-digital-en-orgmode
:DESCRIPTION:
:EXPORT_DATE: 2019-12-30 18:56
:CATEGORY: emacs
:TAG: orgmode,notas,diario,bulletjournal
:IMAGE: ./images-blog/bujo.png
:END:


Si eres un amante del Bullet Journal y OrgMode, estas de suerte. Hace algo más de un año, hice un script en bash para crear la plantilla de lo que sería una libreta Bullet Journal, pero en formato digital.

#+HTML: <center>
[[./images-blog/bujo.png]]
#+HTML: </center>


Como no puede ser de otra manera, vamos a utilizar OrgMode como formato, para tener todas las tareas, trackers y la gestión del día a día en este Bullet Journal.

En la parte final del OrgMode, he añadido un diario con todos los días, donde podremos escribir en unas breves líneas, todo aquello que vamos haciendo en forma de diario.


Ahora conozco más *bash* y podría mejorarlo, pero la verdad es que funciona muy bien y quizás no vale la pena.


Vamos a crear nuestro Bullet Journal!!!
** Clonando el Repositorio
Primero vamos a clonar el repositorio que tengo en GitHub
#+BEGIN_SRC 
git clone https://github.com/uGeek/bujo-digital.git
#+END_SRC
** Creando el Bullet Journal
Una vez clonado el repositorio, encontraremos dos scritps, *bujo.sh* y *bujo-ca.sh*, traducido al catalán por Alfons.

Ejecuta bujo.sh
#+BEGIN_SRC 
./bujo.sh
#+END_SRC
El script te preguntará para que año quieres generar este Bullet Journal. En este caso, 2020.

Encontrarás en esta misma carpeta, el archivo *bujo-2020.org*.

Ya tienes tu Bullet Journal 2020 y Diario para Org Mode!!!. Ahora puedes utilizarlo con Emacs, Orgzly, etc...


#+HTML: <center>https://raw.githubusercontent.com/uGeek/bujo-digital/master/images/bujo-ca.gif </center>

#+HTML: <center>
[[./images-blog/bujo.png]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/bujo.png]]
#+HTML: </center>
* DONE Supysonic 0.5.0. Total compatibilidad con todos los clientes Subsonic
:PROPERTIES:
:TITLE: Supysonic 0.5.0. Total compatibilidad con todos los clientes Subsonic
:EXPORT_FILE_NAME: supysonic-0-5-0-total-compatibilidad-con-todos-los-clientes-subsonic
:DESCRIPTION:
:EXPORT_DATE: 2019-12-31 16:39
:CATEGORY: supysonic
:TAG: subsonic,servidor,musica,raspberry
:IMAGE: ./images-blog/subsonic.png
:END:

Como os comenté en el podcast y artículo sobre Supysonic, una de las limitaciones que tenía, es la limitación de su *api*, que hacia que no fuera 100% compatible con la totalidad de clientes para Subsonic disponibles. Eso hacía que aplicaciones como *Clementine* en escritorio o la propia aplicación oficial de *Subsonic*, no funcionaran con este servidor.

*Esto ha llegado a su fin!!!*

#+HTML: <center>
[[./images-blog/subsonic.png]]
#+HTML: </center>

Con la nueva actualización del servidor de Supysonic versión 0.5.0, actualizada hace solo 6 dias, ha mejorado y actualizado su *api* y ahora podrás utilizarlo con el cliente que desees.

Como podrás imaginar, no me he podido resistir a actualizar [[https://hub.docker.com/r/ugeek/supysonic][el docker]].

Ahora mientras estoy utilizando mi PC, estoy escuchando música en streaming con [[https://www.clementine-player.org/es/][Clementine]], gracias al docker montado con el servidor Supysonic en mi Raspberry.

*Si tienes una versión anterior de Supysonic, el volumen de configuración es incompatible con esta nueva versión, tendrás que crear un volumen de configuración nuevo*.

Otra diferencia, es que algunos comandos de supysonic-cli, en esta versión han cambiado y son diferentes a versiones anteriores.

** Montar Docker Versión 0.5.0
*** Raspberry o ARM 32bits
#+BEGIN_SRC 
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:arm-0.5.0
#+END_SRC
Una vez se monte, se ejecutará el servidor, para salir tendremos que teclear en la terminal *Ctrl+c*.


*** amd64
#+BEGIN_SRC 
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:amd64-0.5.0
#+END_SRC
Una vez se monte, se ejecutará el servidor, para salir tendremos que teclear en la terminal *Ctrl+c*.


** Iniciando Supysonic

Iniciamos el docker
#+BEGIN_SRC 
docker start supysonic
#+END_SRC
Entramos dentro del contenedor para crear el administrador
#+BEGIN_SRC 
docker exec  -it supysonic sh
#+END_SRC
También podemos acceder a la interfaz web de adminstración a http://tu_ip:8080

*** Crear usuario

Dentro ya del conenedor
#+BEGIN_SRC 
supysonic-cli user add angel -p mi_contraseña
#+END_SRC
A este usuario, voy ha hacerlo administrador, para añadir mi biblioteca musical
#+BEGIN_SRC 
supysonic-cli user  setroles -A angel
#+END_SRC
Si queremos cambiar la contraseña
#+BEGIN_SRC 
supysonic-cli user changepass angel nueva_contraseña
#+END_SRC

*** Añadir Biblioteca

Para añadir la biblioteca musical utilizaremo: *supysonic-cli folder add <name> <path>*

La carpeta */media/*, viene añadida por defecto. Si quieres añadir varias subcarpetas y escanerarla por separado como yo, tienes que eliminar esta carpeta por defecto, ya que no puede escanear carpetas subcarpetas que están dentro de una carpeta.

Tengo una carpeta donde añado las novedades, la carpeta *new*.
#+BEGIN_SRC 
supysonic-cli folder add New /media/new/
#+END_SRC
Escanera la biblioteca con nombre *New*, en la carpeta */media/new/*
#+BEGIN_SRC 
supysonic-cli folder scan -f New
#+END_SRC
Escanear simultáneamente dos subcarpetas que tengo, la carpeta *new* y *favoritos*.

#+BEGIN_SRC 
supysonic-cli folder scan -f New Favoritos
#+END_SRC

*** Mas opciones
Siguiendo los ejemplos anteriores, añado la ayuda disponible en [[https://github.com/spl0k/supysonic/blob/master/docs/cli.md][GitHub]].

**** Interfaz de línea de comandos
La interfaz de línea de comandos (a menudo abreviada CLI) es una interfaz que permite operaciones de administración sin el uso de la interfaz web. Puede ejecutarse en modo interactivo ( supysonic-cli) o emitir un solo comando ( supysonic-cli <argumentos>).

Si ejecuta sin argumentos, supysonic-cli abrirá un mensaje interactivo. Puede usar la herramienta de línea de comandos para hacer algunas cosas:

*** Comandos de ayuda
Cuando estas perdido...
#+BEGIN_SRC 
Usage:
    supysonic-cli help
    supysonic-cli help user
    supysonic-cli help folder

Arguments:
    user                        Display the help message for the user command
    folder                      Display the help message for the folder command
#+END_SRC
**** Comandos de gestión de usuarios
#+BEGIN_SRC 
Usage:
    supysonic-cli user add <user> [-p <password>] [-e <email>]
    supysonic-cli user delete <user>
    supysonic-cli user changepass <user> <password>
    supysonic-cli user list
    supysonic-cli user setroles [-a|-A] [-j|-J] <user>

Arguments:
    add                         Add a new user
    delete                      Delete the user
    changepass                  Change the user's password
    list                        List all the users
    setroles                    Give or remove rights to the user

Options:
  -p --password <password>      Specify the user's password
  -e --email <email>            Specify the user's email
  -a --noadmin                  Revoke admin rights
  -A --admin                    Grant admin rights
  -j --nojukebox                Revoke jukebox rights
  -J --jukebox                  Grant jukebox rights
#+END_SRC

**** Comandos de gestión de carpetas
#+BEGIN_SRC 
Usage:
    supysonic-cli folder add <name> <path>
    supysonic-cli folder delete <name>
    supysonic-cli folder list
    supysonic-cli folder scan [-f] [--background | --foreground] [<name>...]

Arguments:
    add                         Add a new folder
    delete                      Delete a folder
    list                        List all the folders
    scan                        Scan all or specified folders

Options:
  -f --force                    Force scan of already known files even if they
                                haven't changed
  --background                  Scan in the background. Requires the daemon to
                                be running.
  --foreground                  Scan in the foreground, blocking the process
                                while the scan is running
#+END_SRC
*** Fuente
- https://github.com/spl0k/supysonic
- https://hub.docker.com/r/ugeek/supysonic

 
* DONE Controlando mis Contenedores desde Android
:PROPERTIES:
:TITLE: Controlando mis Contenedores desde Android
:EXPORT_FILE_NAME: controlando-mis-contenedores-desde-android
:DESCRIPTION:
:EXPORT_DATE: 2020-01-01 01:23
:CATEGORY: docker
:TAG: android,contenedores
:IMAGE: ./images-blog/dockermanagement.png
:END:

Buscando una aplicación practica para controlar mis contenedores desde el móvil, me topé con esta aplicación de acceso anticipado, que no se conecta a ningún servidor extraño, no tiene publicidad y tiene justo lo que buscaba, una aplicación para iniciar, detener y borrar mis contenedores e imágenes.

#+HTML: <center>
[[./images-blog/dockermanagement.png]]
#+HTML: </center>

Pero [[https://play.google.com/store/apps/details?id=com.nevishs.drawerdockerapp&hl=es_419][Docker Management]] hace mucho más

** Opciones
- conectarse a múltiples servidores
- enumerar, crear, iniciar, detener, reiniciar, eliminar, contenedores
- ver el uso de recursos de los contenedores
- ver registros de contenedores
- enumerar, construir, eliminar imágenes
- conectarse mediante contraseña o rsa

** Características principales 
- las credenciales están encriptadas
- la información del servidor se almacena solo en el teléfono (se borra si se elimina la aplicación)

#+HTML: <center>
[[./images-blog/dockermanagement1.png]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/dockermanagement2.png]]
#+HTML: </center>


** Conclusiones
Si tienes Android, no tienes nada que perder instalándola y dejándola, por si en algún momento tienes pereza de utilizar la terminal. Además, los permisos de la aplicación son los justos:
Información de la conexión Wi-Fi, ver conexiones wifi, ver conexiones de red, acceso completo a la red.

[[https://play.google.com/store/apps/details?id=com.nevishs.drawerdockerapp&hl=es_419][Instálala desde Google Play haciendo click aquí]]

** Fuente
- Desarrollador: nevis.applications@gmail.com Toronto, Canadá
* DONE Bat, el Cat enriquecido
:PROPERTIES:
:TITLE: Bat, el Cat enriquecido
:EXPORT_FILE_NAME: bat-el-cat-enriquecido
:DESCRIPTION:
:EXPORT_DATE: 2020-01-0 18:00
:CATEGORY: bash
:TAG: zsh,terminal,aplicación
:IMAGE: ./images-blog/bat.png
:END:


Bat es un *cat* enriquecido. Lo veo un poco como una mezcla de *cat* + *less*.

Permite el resaltado de sintaxis de una gran cantidad de lenguajes de programación y marcado, entre ellos el *orgmode*, *csv*, *markdown*, *html*, *bash*, *python*, ... 


#+HTML: <center>
[[./images-blog/bat.png]]
#+HTML: </center>



Muestra caracteres no imprimibles, canaliza su propia salida a *less* cuando la salida es demasiado grande para una pantalla. También se integra con git.

** Instalación
*** Raspberry

Descargamos el paquete *.deb*
#+BEGIN_SRC 
wget https://github.com/sharkdp/bat/releases/download/v0.12.1/bat_0.12.1_armhf.deb
#+END_SRC
Instalamos
#+BEGIN_SRC 
sudo dpkg -i bat_0.12.1_armhf.deb
#+END_SRC
*** Para amd64
Descargamos el paquete *.deb*
#+BEGIN_SRC 
wget https://github.com/sharkdp/bat/releases/download/v0.12.1/bat_0.12.1_amd64.deb
#+END_SRC
Instalamos
#+BEGIN_SRC 
sudo dpkg -i bat_0.12.1_armhf.deb
#+END_SRC
*** Restode paqueteria
[[https://github.com/sharkdp/bat/releases][Para Mac, windows,... encontrarás el resto de instalaciones en su repositorio en GitHub]].

** Funcionamiento 
El funcionamiento es exactamente igual que cat
*** Mostrar un solo archivo en el terminal
#+BEGIN_SRC 
bat README.md
#+END_SRC
*** Mostrar varios archivos a la vez 
#+BEGIN_SRC 
bat archivo1 archivo2
#+END_SRC

*** Mostrar Caracteres no imprimibles
Utilizando la opción *-A/ --show-all* muestra y resalta caracteres no imprimibles.
#+BEGIN_SRC 
bat -A archivo.org
#+END_SRC

*** Salir si el archivo es muy largo
Igual que muchas aplicaciones *cli*, inspiradas en *vi*, para salir de la visualización de un archivo muy largo, pulsaremos la tecla *q*.

*** Ayuda
Estas son las opciones que muestra *bat --help*.
#+BEGIN_SRC 
A cat(1) clone with syntax highlighting and Git integration.

USAGE:
    bat [OPTIONS] [FILE]...
    bat <SUBCOMMAND>

OPTIONS:
    -l, --language <language>         Set the language for syntax highlighting.
    -L, --list-languages              Display all supported languages.
    -m, --map-syntax <from:to>...     Map a file extension or name to an existing syntax.
        --theme <theme>               Set the color theme for syntax highlighting.
        --list-themes                 Display all supported highlighting themes.
        --style <style-components>    Comma-separated list of style elements to display (*auto*,
                                      full, plain, changes, header, grid, numbers, snip).
    -p, --plain                       Show plain style (alias for '--style=plain').
    -n, --number                      Show line numbers (alias for '--style=numbers').
    -A, --show-all                    Show non-printable characters (space, tab, newline, ..).
    -r, --line-range <N:M>...         Only print the lines from N to M.
    -H, --highlight-line <N>...       Highlight the given line.
        --color <when>                When to use colors (*auto*, never, always).
        --italic-text <when>          Use italics in output (always, *never*)
        --decorations <when>          When to show the decorations (*auto*, never, always).
        --paging <when>               Specify when to use the pager (*auto*, never, always).
        --wrap <mode>                 Specify the text-wrapping mode (*auto*, never, character).
        --tabs <T>                    Set the tab width to T spaces.
    -h, --help                        Print this help message.
    -V, --version                     Show version information.

ARGS:
    <FILE>...    File(s) to print / concatenate. Use '-' for standard input.

SUBCOMMANDS:
    cache    Modify the syntax-definition and theme cache
#+END_SRC
** Conclusión
Te animo a visitar [[https://github.com/sharkdp/bat][el repositorio de GitHub para ver la documentación y encontrar la utilidad más adaptada a tí]].
** Fuentes 
- https://github.com/sharkdp/bat


#+HTML: <center>
[[./images-blog/bat.svg]]
#+HTML: </center>
* DONE Descargando un directorio de git con gitdir
:PROPERTIES:
:TITLE: Descargando un directorio de git con gitdir
:EXPORT_FILE_NAME: descargando-un-directorio-de-git-con-gitdir
:DESCRIPTION:
:EXPORT_DATE: 2020-01-06 12:12
:CATEGORY: git
:TAG: git,repositorio,github,gitlab
:IMAGE: ./images-blog/git.png
:END:


Hoy ojeando *Reddit*, he visto esta magnífica utilidad que nos permite bajar una carpeta determinada de un repositorio de git. La aplicación está desarrollada en Python y como es natural, tenemos que tener instalado tanto *Python 3*, así como los *Pip3*.
#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>

** Instalación 
*** Desde Pip3
#+BEGIN_SRC 
pip3 install --user gitdir
#+END_SRC
En Debian y Raspbian, he tenido que buscar donde se había guardado *gitdir*. =/home/angel/.local/lib/python3.7/site-packages/gitdir/gitdir.py= 


Cambia *angel*, por tu usuario.
#+BEGIN_SRC 
python3 /home/angel/.local/lib/python3.7/site-packages/gitdir/gitdir.py  -h
#+END_SRC
La opción *-h*, es para ofrecernos la ayuda.

#+BEGIN_SRC 
usage: gitdir [-h] [--flatten] url

Download directories/folders from GitHub

positional arguments:
  url

optional arguments:
  -h, --help     show this help message and exit
  --flatten, -f  Flatten directory structures. Do not create extra directory
                 and download found files to current directory.
#+END_SRC

*** Clonando el Repositorios 
Voy a instalar *gitdir* clonando el repositorio de *GitHub*.
#+BEGIN_SRC 
git clone https://github.com/Bash-Projects/gitdir.git
#+END_SRC
Desde esta misma ruta, recién clonado el repositorio, ya podemos correr *gitdir*.
#+BEGIN_SRC 
python3 gitdir/gitdir/gitdir.py
#+END_SRC
Como veis, está en el directorio =gitdir/gitdir.py= dentro del repositorio.

** Creando un alias
He creado un alias para en cualquier lugar de mi máquina, cuando escriba *gitdir*, pueda utilizar esta aplicación.
#+BEGIN_SRC 
alias gitdir="python3 /home/angel/.local/lib/python3.7/site-packages/gitdir/gitdir.py"
#+END_SRC
** Fuentes
- https://www.reddit.com/r/commandline/comments/avbai1/gitdir_download_a_single_directoryfolder_from_a/
- https://github.com/sdushantha/gitdir
- He forqueado el Repositorio: https://github.com/Bash-Projects/gitdir
* DONE Todoist en Emacs
:PROPERTIES:
:TITLE: Todoist en Emacs
:EXPORT_FILE_NAME: todoist-en-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-01-06 19:52
:CATEGORY: emacs.png
:TAG: orgmode,tareas
:IMAGE: ./images-blog/emacs
:END:

Todoist es una aplicación muy conocida para crear y gestionar tus tareas. Con un paquete de Melpa, podremos acceder mediante la api de todoist a todas nuestras listas.

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

** Instalación

Podemos instalarlo desde los [[https://melpa.org/#/todoist][repositorios de Melpa]]
#+BEGIN_SRC 
M-x package-install todoist
#+END_SRC
También podemos añadir el archivo todoist.el, que encontraremos en el [[https://github.com/abrochard/emacs-todoist][repositorio del proyecto]].

** Copia tu Token

Todoist nos proporciona un Token para utilizar su api, vamos a [[https://todoist.com/Users/viewPrefs?page=integrations][acceder aquí para copiar nuestro Token]]

** Archivo de configuración
Copia en tu *.emacs* o *init.el*, la siguiente línea sustituyendo las "XXX...", por nuestro token 

#+BEGIN_SRC 
(setq todoist-token "XXXXXXXXXXXXXXXXXXXX")
#+END_SRC
Ejemplo. Este token es inventado.
#+BEGIN_SRC 
(setq todoist-token "13fc4b42rtrte370a7gqerg0880bae6f4909a71qerg7d")
#+END_SRC
** Ejecuta todoist

Vamos a acceder a todosit. Para ello tenemos que introducir en emacs
#+BEGIN_SRC 
M-x todoist
#+END_SRC
** Uso todoist

- *C-x t* => Abrir el menú de tareas. Crear, actualizar, borrar, cerrar.
- *C-x p* => Abrir el menú de proyectos Nuevo proyecto, actualizar y borrar proyecto

*** Utilizar como Orgmode

También podemos utilizarlo como el OrgMode. Simplemente añadimos una nueva tarea y para que suba a todoist, teclearemos el siguiente atajo =C-x t u=.
** Conclusión
Es una muy buena opción para quien comparte tareas con otros usuarios o está muy habituado a utilizar *Todoist*. Aún así, el orgmode como gestión de tareas, aporta muchísimas más opciones. Pero esta es una demostración más que Emacs es un pequeño sistema operativo.

** Fuentes
- https://github.com/abrochard/emacs-todoist



#+HTML: <center>
[[./images-blog/todoist.png]]
#+HTML: </center>
* DONE W3M. Navegador para Terminal y Emacs
:PROPERTIES:
:TITLE: W3M. Navegador para Terminal y Emacs
:EXPORT_FILE_NAME: w3m-navegador-para-terminal-y-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-01-10 17:55
:CATEGORY: emacs
:TAG: orgmode,bash
:IMAGE: ./images-blog/w3m.png
:END:

W3M es un navegador para terminal muy liviano, con el que no solo podremos ver cualquier web en modo texto, sino que además podremos ver también las imágenes. 

Aunque como sabéis, soy pro atajos de teclado y evitar al máximo el ratón, si no se nos da muy bien, también podremos utilizar el ratón en la terminal para abrir los enlaces que van apareciendo en las webs.

W3M también podremos utilizarlo dentro de Emacs, permitiéndonos copiar webs en orgmode, etc,... pero esto lo dejo para otro artículo.

El Objetivo del artículo de hoy, es instalar W3M y conocer los atajos básicos para emacs.


#+HTML: <center>
[[./images-blog/w3m.png]]
#+HTML: </center>

** instalación
Dependiendo de la distro que utilices, busca los paquetes *w3m* y *w3m-img*.

En Debian y derivadas
#+begin_src 
sudo apt install w3m w3m-img
#+end_src
** Uso
Para abrir w3m y conectarse a google, es tan sencillo como:
#+begin_src 
w3m google.com
#+end_src
Para salir, utilizaremos la tecla *q*.


** W3M en Emacs

Para abrir W3m en Emacs, tendremos que introducir:
#+BEGIN_SRC 
M-x w3m
#+END_SRC
** Atajos en Emacs o Terminal
La primera vez que utilizas *w3m* en Emacs, puede ser un poco complicado. Vamos a conocer algunos atajos.

- U -> Ir a una url
- TAB  -> Saltar de un Link a otro
- Enter -> Pulsando sobre el enlace de la imágen, podremos ver esa imágen. Para ocultar, vuelve a pulsar Enter
- T -> Mostrar o ocultar todas las imágenes de la web
- B -> Página Anterior
- N -> Página Siguiente
- J -> Scroll una línea hacia abajo
- K -> Scroll una línea hacia arriba
- M -> Navegador externo
- H -> Ayuda


- B -> (w3m-view-preview-page) Ir a la pagina anterior
- N -> (w3m-view-next-page) Ir a la página siguiente
- I -> (w3m-view-image) Ver imagen con una aplicación externa
- A -> (w3m-bookmark-add-current-url) Añadir la url activa a les direcciones de interés
- M-a -> (w3m-bookmark-add-this-url) Añadir una url a les direcciones de interés
- v -> (w3m-bookmark-view) Ver las direcciones de interés
- E -> (w3m-bookmark-edit) Visitar el archivo de las direcciones de interés
- C-k -> (w3m-bookmark-kill-entry) Quitar la url de las direcciones de interés

** Configuración personalizada en emacs
Podemos añadir en el archivo de configuración *.emacs* o *init.el*, estas líneas para acceder de un modo más rápido a w3m o navegar por w3m más sencillo.
*** Abrir w3m
Podemos abrir w3m con =M-x w3m=, pero también podemos crear un atajo personalizado.

Abrir w3m con el atajo *C-c w*.
#+BEGIN_SRC 
(global-set-key (kbd "C-c w") 'w3m)    
#+END_SRC
*** Enlaces numerados
Para moverte a máxima velocidad sin tener que desplazarte, enumerando cada enlace de la página web que estamos viendo, utilizamos: =M-x w3m-lnum-goto=

Vamos a crear un atajo, por ejemplo *C-c l*.
#+BEGIN_SRC 
(global-set-key (kbd "C-c l") 'w3m-lnum-goto)
#+END_SRC
*** Abrir w3m y buscar en google
Abrir de w3m con la búsqueda a google. Utilizo por ejemplo, el atajo *C-c g*.
#+BEGIN_SRC 
(global-set-key (kbd "C-c g") 'w3m-search)
#+END_SRC
*** Desplazarte por la página con las flechas del teclado
Para desplazarnos por la web, utiliza los mismo atajos que *vim*, (h,j,k,l). 
Si en su lugar quieres utilizar las flechas del teclado
#+BEGIN_SRC 
(add-hook 'w3m-mode-hook
      (lambda ()
        (local-set-key '[up] 'previous-line)
        (local-set-key '[down] 'next-line)
        ;(local-set-key '[left] 'backward-char)
        ;(local-set-key '[right] 'forward-char)))
#+END_SRC





* DONE html2txt. Convirtiendo un web a texto plano con w3m
:PROPERTIES:
:TITLE: html2txt. Convirtiendo un web a texto plano con w3m
:EXPORT_FILE_NAME: html2txt-convirtiendo-un-web-a-texto-plano-con-w3m
:DESCRIPTION:
:EXPORT_DATE: 2020-01-06 22:04
:CATEGORY: w3m
:TAG: bash,zsh
:IMAGE: ./images-blog/w3m.png
:END:

Ya hemos aprendido a utilizar w3m en Emacs y desde la terminal. Ahora vamos a convertir cualquier web o archivo *.html* a texto plano.

#+HTML: <center>
[[./images-blog/w3m.png]]
#+HTML: </center>

** Convertir a txt
Tan sencillo como escribir en la terminal:
#+BEGIN_SRC 
w3m URL > archivo.txt
#+END_SRC
w3m, es un navegador interactivo, con la opción *-dump*, hace que la página se vea de un modo *no interactivo*, en texto plano. El ancho del documento por defecto, se convierte a 80 letras.
#+BEGIN_SRC 
w3m -dump URL > archivo.txt
#+END_SRC
También podemos hacer lo propio, con alguna página web en formato *.html* que tengamos en nuestro disco duro.
#+BEGIN_SRC 
w3m -dump archivo.html > archivo.txt
#+END_SRC
** Cambiar ancho 
Con la opción *-cols*, podemos cambiar el ancho del documento al tamaño que queramos.

Por ejemplo, 100:
#+BEGIN_SRC 
w3m -dump -cols=100 URL > archivo.txt
#+END_SRC
** UTF-8
Si el texto de la url está en otro idioma, para que todas las letras salgan con sus acentos correctamente, etc... utilizaremos el formato UTF-8.
#+BEGIN_SRC 
w3m -dump -o display_charset=UTF-8 URL > archivo.txt
#+END_SRC
** Conclusión
Ahora podemos automatizar con scripts o desde nuestra terminal, la conversión de una web a texto plano. Con ello podremos tomar notas de aquellas web que nos interese.
* DONE Copiando una página web o parte de ella a OrgMode
:PROPERTIES:
:TITLE: Copiando una página web o parte de ella a OrgMode
:EXPORT_FILE_NAME: copiando-una-pagina-web-o-parte-de-ella-a-orgmode
:DESCRIPTION:
:EXPORT_DATE: 2020-01-06 22:29
:CATEGORY: emacs
:TAG: w3m,orgmode
:IMAGE: ./images-blog/w3m.png
:END:

Vamos a utilizar un paquete que nos va a permitir copiar el contenido de una página web o parte de él, con enlaces, etc... a orgmode

#+HTML: <center>
[[./images-blog/w3m.png]]
#+HTML: </center>

Este paquete no está en los repositorios de Melpa, así que crearlo en nuestro disco duro y cargarlo al inicio.

** Paquete org-w3m.el
Vamos a crear el archivo *org-w3m.el*, por ejemplo en la siguiente ruta =~/dotfile/emacs/paquetes/org-w3m.el=.

#+BEGIN_SRC 
nano ~/dotfile/emacs/paquetes/org-w3m.el
#+END_SRC

Copia el siguiente contenido.

#+BEGIN_SRC 
;; org-w3m.el --- Support from copy and paste from w3m to Org-mode

;; Copyright (C) 2008-2012 Free Software Foundation, Inc.

;; Author: Andy Stewart <lazycat dot manatee at gmail dot com>
;; Keywords: outlines, hypermedia, calendar, wp
;; Homepage: http://orgmode.org
;;
;; This file is part of GNU Emacs.
;;
;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:

;; This file implements copying HTML content from a w3m buffer and
;; transforming the text on the fly so that it can be pasted into
;; an org-mode buffer with hot links.  It will also work for regions
;; in gnus buffers that have been washed with w3m.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Acknowledgments:

;; Richard Riley <rileyrgdev at googlemail dot com>
;;
;;      The idea of transforming the HTML content with org-mode style is
;;      proposed by Richard, I'm just coding it.
;;

;;; Code:

(require 'org)

(defun org-w3m-copy-for-org-mode ()
  "Copy current buffer content or active region with `org-mode' style links.
This will encode `link-title' and `link-location' with
`org-make-link-string', and insert the transformed test into the kill ring,
so that it can be yanked into an Org-mode buffer with links working correctly."
  (interactive)
  (let* ((regionp (org-region-active-p))
         (transform-start (point-min))
         (transform-end (point-max))
         return-content
         link-location link-title
         temp-position out-bound)
    (when regionp
      (setq transform-start (region-beginning))
      (setq transform-end (region-end))
      ;; Deactivate mark if current mark is activate.
      (if (fboundp 'deactivate-mark) (deactivate-mark)))
    (message "Transforming links...")
    (save-excursion
      (goto-char transform-start)
      (while (and (not out-bound)                 ; still inside region to copy
                  (not (org-w3m-no-next-link-p))) ; no next link current buffer
        ;; store current point before jump next anchor
        (setq temp-position (point))
        ;; move to next anchor when current point is not at anchor
        (or (get-text-property (point) 'w3m-href-anchor) (org-w3m-get-next-link-start))
        (if (<= (point) transform-end)  ; if point is inside transform bound
            (progn
              ;; get content between two links.
              (if (> (point) temp-position)
                  (setq return-content (concat return-content
                                               (buffer-substring
                                                temp-position (point)))))
              ;; get link location at current point.
              (setq link-location (get-text-property (point) 'w3m-href-anchor))
              ;; get link title at current point.
              (setq link-title (buffer-substring (point)
                                                 (org-w3m-get-anchor-end)))
              ;; concat `org-mode' style url to `return-content'.
              (setq return-content (concat return-content
                                           (org-make-link-string
                                            link-location link-title))))
          (goto-char temp-position)     ; reset point before jump next anchor
          (setq out-bound t)            ; for break out `while' loop
          ))
      ;; add the rest until end of the region to be copied
      (if (< (point) transform-end)
          (setq return-content
                (concat return-content
                        (buffer-substring (point) transform-end))))
      (org-kill-new return-content)
      (message "Transforming links...done, use C-y to insert text into Org-mode file")
      (message "Copy with link transformation complete."))))

(defun org-w3m-get-anchor-start ()
  "Move cursor to the start of current anchor.  Return point."
  ;; get start position of anchor or current point
  (goto-char (or (previous-single-property-change (point) 'w3m-anchor-sequence)
                 (point))))

(defun org-w3m-get-anchor-end ()
  "Move cursor to the end of current anchor.  Return point."
  ;; get end position of anchor or point
  (goto-char (or (next-single-property-change (point) 'w3m-anchor-sequence)
		 (point))))

(defun org-w3m-get-next-link-start ()
  "Move cursor to the start of next link.  Return point."
  (catch 'reach
    (while (next-single-property-change (point) 'w3m-anchor-sequence)
      ;; jump to next anchor
      (goto-char (next-single-property-change (point) 'w3m-anchor-sequence))
      (when (get-text-property (point) 'w3m-href-anchor)
        ;; return point when current is valid link
        (throw 'reach nil))))
  (point))

(defun org-w3m-get-prev-link-start ()
  "Move cursor to the start of previous link.  Return point."
  (catch 'reach
    (while (previous-single-property-change (point) 'w3m-anchor-sequence)
      ;; jump to previous anchor
      (goto-char (previous-single-property-change (point) 'w3m-anchor-sequence))
      (when (get-text-property (point) 'w3m-href-anchor)
        ;; return point when current is valid link
        (throw 'reach nil))))
  (point))

(defun org-w3m-no-next-link-p ()
  "Whether there is no next link after the cursor.
Return t if there is no next link; otherwise, return nil."
  (save-excursion
    (equal (point) (org-w3m-get-next-link-start))))

(defun org-w3m-no-prev-link-p ()
  "Whether there is no previous link after the cursor.
Return t if there is no previous link; otherwise, return nil."
  (save-excursion
    (equal (point) (org-w3m-get-prev-link-start))))

;; Install keys into the w3m keymap
(defvar w3m-mode-map)
(defvar w3m-minor-mode-map)
(when (and (boundp 'w3m-mode-map)
           (keymapp w3m-mode-map))
  (define-key w3m-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
  (define-key w3m-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode))
(when (and (boundp 'w3m-minor-mode-map)
           (keymapp w3m-minor-mode-map))
  (define-key w3m-minor-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
  (define-key w3m-minor-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode))
(add-hook
 'w3m-mode-hook
 (lambda ()
   (define-key w3m-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
   (define-key w3m-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode)))
(add-hook
 'w3m-minor-mode-hook
 (lambda ()
   (define-key w3m-minor-mode-map "\C-c\C-x\M-w" 'org-w3m-copy-for-org-mode)
   (define-key w3m-minor-mode-map "\C-c\C-x\C-w" 'org-w3m-copy-for-org-mode)))

(provide 'org-w3m)

;;; org-w3m.el ends here
#+END_SRC

** Archivo de configuración

Ahora en el archivo *.emacs* o *init.el*, vamos a añadir la siguiente línea para cargar el paquete que acabamos de crear al arranca Emacs.
#+BEGIN_SRC 
(load-file "~/dotfile/emacs/paquetes/org-w3m.el")
#+END_SRC

** Copiar y Pegar en el archivo OrgMode 
1) Seleccionamos el texto a copiar
2) Pulsamos *C-c C-x C-w* o introducimos: *M-x org-w3m-copy-for-org-mode*
3) Pegamos en nuestro org


* TODO ESXi
:PROPERTIES:
:TITLE: ESXi
:EXPORT_FILE_NAME: esxi
:DESCRIPTION:
:EXPORT_DATE: 2020-01-07 19:23
:CATEGORY: esxi
:TAG: servidor
:IMAGE: ./images-blog/esxi.png
:END:

Es un hipervisor de virtualización, que permite ejecutar varios sistemas operativos simultáneamente. Se instala directamente en nuestro servidor, PC... sin necesidad de utilizar ningún sistema operativo. Tan solo ocupa 150 MB de espacio y necesita poco mas de 4Gb de ram. 

#+HTML: <center>
[[./images-blog/esxi.png]]
#+HTML: </center>


ESXi utiliza un núcleo Linux Red Hat Enterprise Linux modificado para permitir la ejecución del hipervisor vmkernel, por lo que tiene similitudes con sistemas GNU/Linux.

Para virtualizar servidores necesitamos:
- Host: Servidor, PC
- Hipervisor: Software que permite virtualizar máquinas virtuales
- Máquinas virtuales: Sistemas Operativos que instalaremos para crear servidores, escritorios,...


** Instalar ESXi

Instalar vmware ESXi

1) Accedemos a myvmware.com y nos registramos.
2) En el producto VMware vSphere y le damos *Download Free Trial*, para bajarnos el trial y registrar el trial.
3) Nos *Registramos* y una vez registrados, nos aparecerá *VMware vSphere Hypervisor (ESXi ISO) image (Includes VMware Tools)*. Pulsamos sobre *Manually Download*.
4) Grabamos la imagen descargada en un CD o USB.
5) Descargamos también la licencia (gratuita) para nuestra copia de ESXi


Si necesitamos funcionalidades más avanzadas como mover máquinas entre distintos hosts en función del rendimiento, alta disponibilidad,... Podemos ampliar la licencia a la que más nos convenga.

** VM.  Máquinas virtuales 

*** Creación
Para crear una máquina virtual:
- Subimos la imagen del Sistema Operativo al *datastore* (almacén de datos)
- Creamos una nueva máquina virtual que nos pedirá que asignemos una CPU, memoria ram, disco duro,...
- Arrancamos la máquina virtual iniciando desde el CD-ROM virtual donde tenemos la imagen del sistema operativo que queremos instalar.
- Una vez instalado, detener el inicio desde el CD-ROM virtual e iniciar.

*** Estructura 

Las *VM*, máquinas virtuales, son archivos que contienen la información del equipo virtualizado.

Cada máquina virtual, contiene los siguientes archivos.

- .vmx: Configuración.
- .vmdk: Disco virtual. (Disco duro)
- .nvram: archivo con la BIOS de la máquina. (Basic Imput/Output System)
- .log: archivo de registro (logs)

Estos son los archivos básicos, pero podría contener más. Todos estos archivos quedan dentro de un directorio, uno por cada máquina virtual que creemos y están en el *datastore* (almacén de datos). Si copiamos esta carpeta y la exportamos a otro Host, clonaríamos nuestra máquina virtual en otro servidor.




** Fuentes
- https://virtualizadesdezero.com/instalar-esxi-6-7-6-5-y-6-0/
* DONE Descargando el último archivo de lanzamiento de un repositorio git. Latest Releases
:PROPERTIES:
:TITLE: Descargando el último archivo de lanzamiento de un repositorio git. Latest Releases
:EXPORT_FILE_NAME: descargando-el-ultimo-archivo-de-lanzamiento-de-un-repositorio-git-latest-releases
:DESCRIPTION:
:EXPORT_DATE: 2020-01-14 21:43
:CATEGORY: git
:TAG: scripts,bash
:IMAGE: ./images-blog/git.png
:END:

Vamos a utilizar un script para descargar el último archivo de lanzamiento (latest releases) de un repositorio git.

#+HTML: <center>
[[./images-blog/git.png]]
#+HTML: </center>




Es muy sencillo. Tan simple como conectarnos al apartado *releases* del repositorio de git y desde ahí pulsamos para descargar el archivo.

Ahora mediante este scritp que he creado, vamos a automatizar la descarga y así no tener que vistar la web.

#+BEGIN_SRC 
#!/bash/bin                                                                                                                                                                                                        
#
# ugeek.github.io
# 14/01/20
#

echo "Escribe el nombre del repositorio"
echo "            Ejemplo: uGeek/script"
read URL
echo "¿Que tipo de archivo quieres descargar?, zip, deb, rpm,..."
read ARCHIVO

curl -s https://api.github.com/repos/$URL/releases/latest \
| grep "browser_download_url.*$ARCHIVO" \
| cut -d : -f 2,3 \
| tr -d \" \
| wget -qi -
#+END_SRC


* DONE Emacs en Android
:PROPERTIES:
:TITLE: Emacs en Android
:EXPORT_FILE_NAME: emacs-en-android
:DESCRIPTION:
:EXPORT_DATE: 2020-01-16 17:50
:CATEGORY: emacs
:TAG: termux,android
:IMAGE: ./images-blog/emacs-android.png
:END:

Podemos utilizar Emacs en Android gracias a Termux a través de la Terminal. La novedad es que desde hace mas o menos un mes, hay un nuevo paquete x11 para Termux llamado emacs-x. Gracias a la combinación de 3 aplicaciones, Termux, Hacker’s keyboard y XServer XSDL, podremos utilizar Emacs también de forma gráfica.


Esto abre la posibilidad de utilizar Emacs tanto en tablets, Android Tv… del mismo modo como lo haríamos en un PC.

#+HTML: <center>
[[./images-blog/emacs-android.png]]
#+HTML: </center>

** En Termux
Escribimos en Termux:

#+BEGIN_SRC 
pkg upgrade
pkg install x11-repo
pkg install emacs-x
#+END_SRC

** Iniciaremos XServer XSDL:
#+BEGIN_SRC 
export DISPLAY=:0
#+END_SRC
Recordar que al iniciar XServer XSDL, podremos configurar la posición vertical de la pantalla, teclado, etc…
Iniciamos Emacs:

#+BEGIN_SRC 
emacs
#+END_SRC
Si nos vamos a la aplicación de XServer XSDL y esperamos unos segundos, aparecerá Emacs en modo gráfico.

** Fuente https://www.reddit.com/r/emacs/comments/9m76ak/termux_package_emacsx/
* DONE Instalando la última versión de Firefox
:PROPERTIES:
:TITLE: Instalando la última versión de Firefox
:EXPORT_FILE_NAME: instalando-la-ultima-version-de-firefox
:DESCRIPTION:
:EXPORT_DATE: 2020-01-17 17:55
:CATEGORY: aplicaciones
:TAG: firefox
:IMAGE: ./images-blog/firefox.png
:END:


Voy a instalar la ultimísima versión de Firefox y no depender de la versión disponible en los repositorios de mi distro. Para ello, descargaremos la versión disponible en los repositorios de [[www.mozilla.org][mozilla]].
#+HTML: <center>
[[./images-blog/firefox.png]]
#+HTML: </center>

** Descargando
Descargaré la última versión en este momento, la *73.0b3* (recuerda que las versiones que llevan una *b*, forman parte del canal beta), pero puedes hacer exactamente lo mismo con la última versión disponible en el momento que leas este artículo.

Vamos a ver todas las versiones publicadas en https://download-installer.cdn.mozilla.net/pub/firefox/releases/

Descargamos la versión para y arquitectura *linux-x86_64*
#+BEGIN_SRC 
wget https://download-installer.cdn.mozilla.net/pub/firefox/releases/73.0b3/linux-x86_64/es-ES/firefox-73.0b3.tar.bz2
#+END_SRC
** Descomprimiendo
Descomprimimos el archivo
#+BEGIN_SRC 
tar xvf firefox-73.0b3.tar.bz2
#+END_SRC
** Moviendolo al directorio opt
Voy a mover a la carpeta =/opt/= la carpeta *firefox* que hemos descomprimido

#+BEGIN_SRC 
sudo mv firefox/ /opt/
#+END_SRC
** Ejecuta firefox con 
Ahora solo queda ejecutar Firefox.

Yo en i3wm, creo un atajo a este Firefox. También podrías crear un icono en tu escritorio para ejecutar este ejecutable
#+BEGIN_SRC 
/opt/firefox/firefox
#+END_SRC


* DONE Screen. Enviar scripts a segundo plano
:PROPERTIES:
:TITLE: Screen. Enviar scripts a segundo plano
:EXPORT_FILE_NAME: screen-enviar-scripts-a-segundo-plano
:DESCRIPTION:
:EXPORT_DATE: 2020-01-21 20:34
:CATEGORY: bash
:TAG: screen,zsh
:IMAGE: ./images-blog/bash.png
:END:

Aprovechando que Linux permite la multitarea, vamos a enviar un script corriendo a segundo plano.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Para ello vamos a utilizar *screen*. *Screen* mediante la opción *-S*, permite el crear un nombre de sesión. Ideal para recordar en que sesión se está ejecutando este script y así poder volver a esta.

** Enviar script a segundo plano
Vamos a enviar el *script.sh* a segundo plano. En este ejemplo la sesión se llamaría *nombre_sesion*.

#+BEGIN_SRC 
screen -dmS nombre_sesion script.sh
#+END_SRC
- -S -> Establecer un nombre de sesión
- -d -m -> Modo separado, crea una sesión aparte. Ideal para scripts de inicio del sistema.


** Volver a la sesión
Para volver a la sesión donde se está ejecutando *script.sh*, escribiremos:
#+BEGIN_SRC 
screen -r nombre_sesion
#+END_SRC

** Ver todas las sesiones
Si no recuerdas el nombre de sesión o simplemente, quieres ver cuantos procesos están corriendo en segundo plano con *screen*, escribiremos el siguiente comando
#+BEGIN_SRC 
screen -ls 
#+END_SRC
* DONE Nuevo firmware de la Raspberry 4 para bajar la temperatura
:PROPERTIES:
:TITLE: Nuevo firmware de la Raspberry 4 para bajar la temperatura
:EXPORT_FILE_NAME: nuevo-firmware-de-la-raspberry-4-para-bajar-la-temperatura
:DESCRIPTION:
:EXPORT_DATE: 2020-01-22 18:01
:CATEGORY: raspberry
:TAG: firmware
:IMAGE: ./images-blog/raspberry.png
:END:

Hasta que ha llegado la nueva versión de firmware *000137ab*, hemos visto como a nuestra Raspberry 4 se disparaba la temperatura. Desde prácticamente el día después de su lanzamiento, ya había un firmware que corregia en parte este problema, pero reducía muchisimo la velocidad de transmisión de datos del USB3.0. Vamos, que no se sabía muy bien hasta que punto valía la pena el actualizar a este firmware.

#+HTML: <center>
[[./images-blog/raspberry.png]]
#+HTML: </center>

Hoy, este problema ha sido del todo corregido y mediante una actualización, podemos conseguir una temperatura normal y disfrutar sin miedo de nuestra Raspberry 4.

Esta actualización de firmware, es útil para la Raspberry 4, pero no afecta en nada a las anteriores versiones, ya que el problema está en el USB3.0 y la Raspberry 4 es la única versión que lo tiene.

Con esta nueva actualización de firmware, también bajamos el consumo hasta casi 0,5 w.

** Flashear eeprom
Para actualizar el firmware, necesitamos flashear la memoria eeprom.  
Para hacer ello, necesitamos instalar *rpi-eeprom*.

Ya que estamos, actualizaremos Raspbian

#+BEGIN_SRC 
sudo apt update && sudo apt upgrade
#+END_SRC

Instalamos rpi-eeprom y rpi-eeprom-images
#+BEGIN_SRC 
sudo apt install rpi-eeprom rpi-eeprom-images 
#+END_SRC

Ahora reiniciamos Raspbian para que al iniciar el sistema operativo, cargue el nuevo firmware

** Ver versión de Firmware
Una vez instalado, vamos a comprobar la versión del firmware

#+BEGIN_SRC 
sudo rpi-eeprom-update
#+END_SRC

Si la versión de firmware es *000137ab* o superior, quiere decir que tu Raspberry tiene instalado correctamente esta última versión de firmware.

** Unirse al Canal Beta
También podemos unirnos al canal beta de actualizaciones de firmware de la Raspberry 4 y así estar a la última. Actualmente no es posible iniciar nuestra Raspberry desde un USB tal como hacíamos con la versión 3, pero si es posible iniciar con el arranque de red, una funcionalidad disponible solo en el canal beta.

Para instalar el Canal beta, editamos el archivo: 

#+BEGIN_SRC 
sudo nano /etc/default/rpi-eeprom-update
#+END_SRC

Cambiamos *critical* por *beta*
#+BEGIN_SRC 
FIRMWARE_RELEASE_STATUS="beta"
#+END_SRC

Volvemos a actualizar
#+BEGIN_SRC 
sudo rpi-eeprom-update
#+END_SRC

** Fuentes

- https://hackaday.com/2019/10/30/rpi4-now-overclocked-net-booted-and-power-sipping/
- https://www.tomshardware.com/features/raspberry-pi-4-firmware-cool-temps-network-boot
- https://raspberryparanovatos.com/noticias/arranque-red-firmware-raspberry-pi-4/
- https://raspberryparatorpes.net/raspbian-2/nuevo-firmware-para-raspberry-pi-4/
* TODO Docker: Airsonic
:PROPERTIES:
:TITLE: Docker: Airsonic
:EXPORT_FILE_NAME: docker-airsonic
:DESCRIPTION:
:EXPORT_DATE: 2020-01-25 19:35
:CATEGORY: docker
:TAG: musica,servidor
:IMAGE: ./images-blog/airsonic.png
:END:

#+HTML: <center>
[[./images-blog/airsonic.png]]
#+HTML: </center>


** Docker para ARM y amd64
#+BEGIN_SRC 
docker create \
--name=airsonic \
-v $HOME/docker/airsonic:/config \
-v $HOME/Musica/:/music \
-e PGID=1000 -e PUID=1000 \
-e TZ=Europe/Madrid \
-p 4040:4040 \
-p 8080:8080 \
lsioarmhf/airsonic
#+END_SRC

** Uso

Access WebUI at your-ip:4040.

- user: pass 
- admin: admin
* DONE Aprendiendo todo.txt. todotxt-cli
:PROPERTIES:
:TITLE: Aprendiendo todo.txt. todotxt-cli
:EXPORT_FILE_NAME: aprendiendo-todo-txt-todotxt-cli
:DESCRIPTION:
:EXPORT_DATE: 2020-01-27 20:11
:CATEGORY: todo.txt
:TAG: tareas,textoplano
:IMAGE: ./images-blog/todotxt.png
:END:

También puedes encontrar muchas aplicaciones para todos los sistemas operativos, navegadores, etc... Te adjunto [[http://todotxt.org/][la web de todo.txt]] donde encontrarás más información.

#+HTML: <center>
[[./images-blog/todotxt.png]]
#+HTML: </center>

Gina Trapani , editora fundadora de Lifehacker, creó esta sencilla aplicación para gestionar tus tareas mediante un scritp en bash.

[[https://lifehacker.com/todo-txt-cli-manages-your-tasks-from-the-command-line-5155450][Este artículo, casi es una traducción del propio publicado por Gina Trapani en Lifehacker]], a excepción de la instalación. He podido entender mejor que nunca el script de todo.txt para terminal y tal como lo iba probando, lo ido redactando.

Voy a darle nuevamente la oportunidad a todo.txt
** Instalación
todotxt-cli, está disponible en todas las distribuciones linux. Para instalarlo en Debian, Ubuntu, Raspbian,...

#+BEGIN_SRC 
sudo apt install todotxt-cli
#+END_SRC

** todo-txt
*** Comando
Para ejecutar todo.txt cli, escribiremos en la terminal
#+BEGIN_SRC 
todo-txt
#+END_SRC

*** Archivo todo.txt

¿Donde está el archivo todo.txt?
#+BEGIN_SRC 
todo-txt archive
   ~/.todo-txt/todo.txt
#+END_SRC

*** Cambiar la carpeta de tu archivo txt
Si quieres cambiar la ruta de la capeta de tu archivo *todo.txt*, crearemos un archivo de configuración.

Creamos la carpeta y directorio de configuración
#+BEGIN_SRC 
mkdir .todo/ ; nano ~/.todo/config
#+END_SRC

Sitúa la carpeta que contienen los archivo todo.txt. En este ejemplo, la carpeta =~/todo=.
#+BEGIN_SRC 
export TODO_DIR="$HOME/todo"
export TODO_FILE="$TODO_DIR/todo.txt"
export DONE_FILE="$TODO_DIR/done.txt"
export REPORT_FILE="$TODO_DIR/report.txt"
export TMP_FILE="/tmp/todo.tmp"
export TODOTXT_DEFAULT_ACTION=ls
#+END_SRC

*** Alias

Si quieres sencillez, puedes crear el alias *t*, para abreviar.

Añade a tu archivo de configuración .bashrc, .zshrc....
#+BEGIN_SRC 
alias t='todo-txt'
#+END_SRC

Ahora no tendrás que escribir necesariamente *todo-txt* cada vez que quieras utilizar todo.txt cli. Ya tenemos creado nuestro alias.
** Funcionamiento
*** Añadiendo una línea

A partir de ahora, el comando *todo-txt*, lo sustituiré por *t*, ya que he añadido mi alias 

Voy a añadir mi primer línea al archivo *todo.txt*.
#+BEGIN_SRC 
t add "mi primera tarea"
#+END_SRC

Para simplificarlo, también permite el sustituir *add* por *a*.
#+BEGIN_SRC 
t a "mi segunda tarea"
#+END_SRC
Mucho más fácil

*** Añadir una línea a otro todo.txt

#+BEGIN_SRC 
t addto quizas_despues.txt "Tercera tarea"
#+END_SRC

*** Listar tareas

Para listar todas las tareas de mi todo.txt y ver el número de línea
#+BEGIN_SRC 
t ls
#+END_SRC

También podemos utilizar, pero es más sencillo utilizar *ls*.
#+BEGIN_SRC 
t listfile
#+END_SRC

Listar tareas de otro *todo.txt*
#+BEGIN_SRC 
t ls done.txt
#+END_SRC

*** Añadir prioridad

La *1* (primera tarea) del *todo.txt*, voy a darle prioridad *A*.

#+BEGIN_SRC 
t pri 1 A 
#+END_SRC

*** Marcar como realizada una tarea

Voy a marcar como realizada, *done*, la tarea situada en la segunda línea.
#+BEGIN_SRC 
t do 2
#+END_SRC

*** Editar tareas

- replace: reemplazar -> reemplazar una tarea
- append:  agregar -> añadir a una nota existente
- prepend: anteponer 

Ejemplo, Añadir a una nota existente, realizado a las 3 de la tarde
#+BEGIN_SRC 
t append 2 "ready at 3PM"
#+END_SRC

Reemplazar segunda tarea
#+BEGIN_SRC 
t replace 2 "Nueva tarea"
#+END_SRC

Añadir al principio de la tarea. Añadirá la palabra *Importante* al principio de la tarea nº2.
#+BEGIN_SRC 
t prepend 2 "Importante"
#+END_SRC

*** Listar contextos 
Para listar los contextos
#+BEGIN_SRC 
t lsc
#+END_SRC

También podemos listarlos con
#+BEGIN_SRC 
t listcon
#+END_SRC

*** Listar proyectos 
Para listar proyectos
#+BEGIN_SRC 
 t ls prj
#+END_SRC

También podemos utilizar
#+BEGIN_SRC 
t  listproj
#+END_SRC
*** Mover tareas a otro todo.txt
La tarea nº10, ahora no la vamos a poder realizar, la moveremos a la lista *quizas_despues.txt*

#+BEGIN_SRC 
t move 10 quizas_despues.txt
#+END_SRC
*** Buscar en un todo.txt por una palabra
Voy a buscar en mi todo.txt, tareas que contengan la palabra *trabajo*.
#+BEGIN_SRC 
 t lf todo.txt trabajo
#+END_SRC

También podría hacer lo mismo con otro todo.txt
#+BEGIN_SRC 
 t lf done.txt trabajo
#+END_SRC


** Vídeo 
Gina Trapani explica en su artículo, que como una imagen vale más que mil palabras...
#+html: <iframe src="https://player.vimeo.com/video/3263629" width="640" height="483" frameborder="0" allow="autoplay; fullscreen" allowfullscreen></iframe>
#+html:<p><a href="https://vimeo.com/3263629">Todo.txt CLI 2.0 Demonstration</a> from <a href="https://vimeo.com/user1254136">Gina Trapani</a> on <a href="https://vimeo.com">Vimeo</a>.</p>
** Ayuda

#+BEGIN_SRC 
Usage: todo-txt [-fhpantvV] [-d todo_config] action [task_number] [task_description]

  Actions:
    add|a "THING I NEED TO DO +project @context"
    addm "THINGS I NEED TO DO
          MORE THINGS I NEED TO DO"
    addto DEST "TEXT TO ADD"
    append|app ITEM# "TEXT TO APPEND"
    archive
    command [ACTIONS]
    deduplicate
    del|rm ITEM# [TERM]
    depri|dp ITEM#[, ITEM#, ITEM#, ...]
    do ITEM#[, ITEM#, ITEM#, ...]
    help [ACTION...]
    list|ls [TERM...]
    listall|lsa [TERM...]
    listaddons
    listcon|lsc [TERM...]
    listfile|lf [SRC [TERM...]]
    listpri|lsp [PRIORITIES] [TERM...]
    listproj|lsprj [TERM...]
    move|mv ITEM# DEST [SRC]
    prepend|prep ITEM# "TEXT TO PREPEND"
    pri|p ITEM# PRIORITY
    replace ITEM# "UPDATED TODO"
    report
    shorthelp
#+END_SRC

** Fuentes

- https://github.com/todotxt/todo.txt-cli
- https://lifehacker.com/todo-txt-cli-manages-your-tasks-from-the-command-line-5155450
- https://github.com/nthorne/todo.txt-cli-again-addon
- https://www.tecmint.com/manage-todo-tasks-from-linux-terminal/
* DONE Integración total de todotxt en Emacs
:PROPERTIES:
:TITLE: Integración total de todotxt en Emacs
:EXPORT_FILE_NAME: integracion-total-de-todotxt-en-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-01-29 18:59
:CATEGORY: emacs
:TAG: todo.txt,tareas
:IMAGE: ./images-blog/todotxt.png
:END:

Utilizar org-mode con Emacs, no quiere decir que sea incompatible con el todo.txt. 

De hecho, con este artículo demostraré que ambos sistemas pueden ser complementario el uno del otro.
#+HTML: <center>
[[./images-blog/todotxt.png]]
#+HTML: </center>

Tengo que reconocer que este modo de gestión de tareas integrado dentro de Emacs,  me ha encantado y además da la sensación de volverte mucho más productivo. 

** Instalación

Vamos a instalar este paquete desde los repositorios de Melpa. 
#+BEGIN_SRC 
M-x package-install todotxt
#+END_SRC

** Configuración

Añadir al archivo de configuración de emacs, *init.el*.

#+BEGIN_SRC 
; Habilitar todotxt
(require 'todotxt)

; Ruta del archivo todo.txt
(set-variable 'todotxt-file "~/todo/todo.txt")

; Atajo C-c t para abrir el listado todo.txt
(global-set-key (kbd "C-c t") 'todotxt)
#+END_SRC

** Funcionamiento

Cuando utilicemos el atajo *C-c t*, se dividirá en 2 la pantalla de emacs, accediendo a nuestro archivo todo.txt y pudiendo gestionar nuestras tareas sin salir del buffer actual.

Para salir del modo todotxt, pulsaremos la tecla *q*.

*** Recopilación de Tareas

Para crear una tarea, es tan simple como abrir todotxt en emacs, pulsar la tacla *a*, escribir la tarea, pulsar la tecla *t* y asociarle un proyecto o contexto, pulsar *r* ya añadir la prioridad, por ejemplo ponemos *A*.

*** Agregar fecha de finalización

Nos situamos sobre la tarea, pulsamos la tecla *d* y en la parte superior de Emacs, se abrirá el calendario de Emacs. Selecciona el día en el calendario y este se agregará de modo automático en la tarea como fecha de finalización.

*** Atajos

- Listar - *l*
- Listar tareas incompletas - *i*
- Añadir tareas - *a*
- Completar tarea - *c*
- Etiquetar tarea - *t*
- Filtrar por proyectos o tareas - */*
- Buscar - Buscar igual que hacemos en Emacs. *C-s*
- Prioridad - *r*
- Editar tarea - *e*
- Guardar - *s*
- Archivar al archivo done.txt - *A*
- Deshacer - *u*
- Revetir en caso de que el todo.txt haya sido con editro externo - *g*
- Salir - *q*

** Fuentes

- https://github.com/rpdillon/todotxt.el
* DONE A python también le gusta el todo.txt. todotxt-machine
:PROPERTIES:
:TITLE: A python también le gusta el todo.txt. todotxt-machine
:EXPORT_FILE_NAME: a-python-tambien-le-gusta-el-todo-txt-todotxt-machine
:DESCRIPTION:
:EXPORT_DATE: 2020-01-31 17:56
:CATEGORY: todo.txt
:TAG: tareas,python
:IMAGE: ./images-blog/todotxt.png
:END:


Posiblemente una de mis aplicaciones favoritas de todo.txt es todotxt-machine. Una aplicación desarrollada en Python que su funcionamiento es más similar a SimpleTask con su potente filtrado de Contextos, Proyectos.

#+HTML: <center>
[[./images-blog/todotxt.png]]
#+HTML: </center>

** Instalación

#+BEGIN_SRC 
sudo pip3 install todotxt-machine
#+END_SRC

También si lo deseamos, podemos instalarlo desde los repositorios de GitHub
#+BEGIN_SRC 
git clone https://github.com/AnthonyDiGirolamo/todotxt-machine.git
cd todotxt-machine
./todotxt-machine.py
#+END_SRC

** Abrir un archivo todo.txt
Para abrir la aplicación con el archivo todo.txt
#+BEGIN_SRC 
todotxt-machine ~/todo/todo.txt
#+END_SRC

También podemos hacerlo incluyendo el done.txt
#+BEGIN_SRC 
todotxt-machine ~/todo/todo.txt ~/todo/done.txt
#+END_SRC

** Archivo de configuración
Si no quieres tener que poner el archivo *todo.txt* cada vez que abrimos todotxt-machine, crearemos un archivo de configuración
#+BEGIN_SRC 
nano ~/.todotxt-machinerc
#+END_SRC

#+BEGIN_SRC 
[settings]
file = ~/todo.txt
archive = ~/done.txt
#+END_SRC

Ahora si abrimos *todotxt-machine*, se nos abrirá nuestro *todo.txt* por defecto.

** Temas
Podemos personalizar el tema tanto como queramos. Hay 4 temas por defecto que puedes probar.
- base16-light
- base16-dark
- solarized-light
- solarized-dark

Ejemplo:
#+BEGIN_SRC 
[settings]
file = ~/todo.txt
archive = ~/done.txt
colorscheme = solarized-dark
#+END_SRC

** Funcionamiento
Pulsando la tecla *f*, nos abrirá a la derecha un módulo para poder filtrar por contextos o proyectos. Con la tecla *TABULADO*, no moveremos entre el listado y este módulo de filtros.

Para seleccionar los filtros, pulsaremos la tecla *Espacio*.

- *f* -> Filtrar por listas
- *t* -> Opciones de orden, crear bordes...
- *s* -> Ordenar
- *e* -> Estando sobre la línea, editar
- *b* -> Generar bordes en cada tarea
- *S* -> Grabar
- *D* -> Situado sobre la línea, borrarla
- *n* -> Nueva tarea
- *x* -> Tarea completada
- *X* -> Completar tarea y enviarla a done.txt
- *h* -> Ayuda



** Ayuda
#+BEGIN_SRC 
todotxt-machine

Usage:
  todotxt-machine
  todotxt-machine TODOFILE [DONEFILE]
  todotxt-machine [--config FILE]
  todotxt-machine (-h | --help)
  todotxt-machine --version
  todotxt-machine --show-default-bindings

Options:
  -c FILE --config=FILE               Path to your todotxt-machine configuraton file [default: ~/.todotxt-machinerc]
  -h --help                           Show this screen.
  --version                           Show version.
  --show-default-bindings             Show default keybindings in config parser format
                                      Add this to your config file and edit to customize

#+END_SRC

** Fuentes 
- https://github.com/AnthonyDiGirolamo/todotxt-machine
- https://pypi.org/project/todotxt-machine/
* DONE Marca de tiempo con Emacs
:PROPERTIES:
:TITLE: Marca de tiempo con Emacs
:EXPORT_FILE_NAME: marca-de-tiempo-con-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-02-05 18:25
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/emacs.png
:END:

Edito con Emacs en diferentes dispositivos. Eso implica entre otras cosas, sincronizar estos archivos tanto con Rclone como Syncthing.
#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

Estaba buscando un modo de que Emacs, cada vez que editara un archivo de texto, agregar a la fecha. Así estar tranquilo que realmente se hizo la última sincronización correctamente.

Buscando la documentación encontrado cómo hacerlo y además es muy sencillo.



** Funcionamiento
:PROPERTIES:
:CREADO:   [2020-02-05 Wed 13:05]
:END:

Añade en las 8 primeras líneas de tu archivo orgmode,  esta línea.

#+BEGIN_SRC 
Time-stamp: <>
#+END_SRC

Si no te gusta este formato, también puedes añadir esta.

#+BEGIN_SRC 
Time-stamp: " "
#+END_SRC

Introduces este comando, verás que se actualiza tanto la fecha y hora, como el nombre del dispositivo en el que estás editando el archivo.

#+BEGIN_SRC 
M-x time-stamp
#+END_SRC

Este sería el modo de actualizar de forma manual.

Ahora lo interesante, mediante la configuración, sería añadir un método automatizado.


** Archivo de configuración

Vamos a añadir esta opción en el archivo de configuración, que nos va a permitir que cada vez que grabemos el archivo que estemos editando, agregue la fecha, hora y dispositivo en el que lo estamos editando.

#+BEGIN_SRC 
(add-hook 'before-save-hook 'time-stamp)
#+END_SRC

** Fuentes

- https://www.gnu.org/software/emacs/manual/html_node/emacs/Time-Stamps.html
- https://www.emacswiki.org/emacs/TimeStamp
* DONE Wireguard en 2 minutos con wgc
:PROPERTIES:
:TITLE: Wireguard en 2 minutos con wgc
:EXPORT_FILE_NAME: wireguard-en-2-minutos-con-wgc
:DESCRIPTION:
:EXPORT_DATE: 2020-02-11 18:30
:CATEGORY: wireguard
:TAG: vpn,raspberry,debian,ubuntu
:IMAGE: ./images-blog/wireguard.png
:END:


Uno de los defectos que he encontrado a Wireguard,  es que aunque no es complicada su configuración de servidor y clientes, la verdad es que no es nada amigable  y eso al final puede hacer que te desanimes.
#+HTML: <center>
[[./images-blog/wireguard.png]]
#+HTML: </center>

¿Te imaginas montar un servidor y configuración de clientes en tan solo 2 minutos?

Gracias al pequeño script que he creado llamado wgc,  podras hacer tus sueños realidad.

Vamos a conocer su funcionamiento.

*** Descargar wgc

Creamos la carpeta =/etc/wireguard=
#+BEGIN_SRC 
mkdir -p /etc/wireguard ; cd /etc/wireguard
#+END_SRC

Descargamos *wgc*.
#+BEGIN_SRC 
wget https://raw.githubusercontent.com/uGeek/wgc/master/wgc
#+END_SRC

Damos permisos de ejecución
#+BEGIN_SRC 
sudo chmod +x wgc
#+END_SRC

Ejecutamos *wgc* y nos mostrará la ayuda
#+BEGIN_SRC 
./wgc
#+END_SRC

** Instalar Wireguard

Si no lo tienes instalado, *wgc* lo hará por tí.

**** Debian

#+BEGIN_SRC 
./wgc -id
#+END_SRC

**** Raspbian

#+BEGIN_SRC 
./wgc -ir
#+END_SRC

**** Ubuntu

#+BEGIN_SRC 
./wgc -iu
#+END_SRC

Recuerda que tras la instalación, tu sistema se reiniciará.

** Conocer mi interfaz de red y ip

Para conocer nuestra interfaz de red e ip, tenemos que ejecutar en la terminal:
#+BEGIN_SRC 
ip a
#+END_SRC

Nos mostrará algo parecido a esto
#+BEGIN_SRC 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens172: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:cb:b3:7e brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.111/24 brd 192.168.1.255 scope global dynamic ens192
       valid_lft 42939sec preferred_lft 42939sec
    inet6 fe80::22c:27ff:fecb:b57e/64 scope link 
       valid_lft forever preferred_lft forever
#+END_SRC

La interfaz de red, en mi caso, es la número 2, *ens172* y la ip *192.168.1.111*.

** Crear archivo de configuración del servidor
**** Para Debian o Ubuntu

#+BEGIN_SRC 
./wgc -d
#+END_SRC

**** Para Raspbian

#+BEGIN_SRC 
./wgc -r
#+END_SRC

Creará el archivo *wg0.conf* de configuración del servidor.
También creará 2 archivos más, la llave pública y privada del servidor.


*Wgc* nos devolverá la llave pública del servidor para que la añadas al propio *wgc*.

Utiliza tu editor de texto favorito. En mi caso, voy a utilizar *nano*.

#+BEGIN_SRC 
nano wgc
#+END_SRC

Ahora añadimos la *ip* pública, tipo ugeek.duckdns.org o en mi caso, voy a utilizar la privada, *192.168.1.111* y la llave pública que ha devuelto *wgc*.
** Crear Cliente

Para crear el cliente, utilizaremos el comando *wgc* seguido del nombre que daremos al cliente.

Yo tengo un Xiami A3, así que le pondré de nombre *A3*.

#+BEGIN_SRC 
./wgc A3 
#+END_SRC

Añadimos el número de cliente, este será el *1*, ya que es el primero que creamos.

- Nos mostrará un código *QR* para capturarlo con nuestro móvil, tablet,...
- Dos líneas para añadir en el servidor

*Ahora crea tantos Clientes como quieras!!!*

** Levantar el servidor

Para levantar el servidor, utilizaremos:
#+BEGIN_SRC 
sudo wg-quick up wg0
#+END_SRC

** Comprobar que Wireguard funciona correctamente

#+BEGIN_SRC 
sudo wg
#+END_SRC

** Detener el servidor

#+BEGIN_SRC 
sudo wg-quick down wg0
#+END_SRC

** Iniciar Wireguard al encender nuestra Raspberry, Servidor,...

Para ello, una vez más utilizaremos systemd.

#+BEGIN_SRC 
sudo systemctl enable wg-quick@wg0.service
#+END_SRC

Iniciamos
#+BEGIN_SRC 
sudo systemctl start wg-quick@wg0.service
#+END_SRC


* DONE Archivar tareas en OrgMode
:PROPERTIES:
:TITLE: Archivar tareas de tu OrgMode en Emacs
:EXPORT_FILE_NAME: archivar-tareas-de-tu-orgmode-en-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-02-12 18:30
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/emacs.png
:END:

 


Si utilizas el orgmode para crear tus tareas, o como es mi caso,  para crear los artículos que voy a publicar en el blog,  una vez finalizados y publicados, necesito quitarlo del archivo actual y desplazarlo a otro para tenerlo guardado.
#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

En el caso de las tareas, sería que una tarea que ya está totalmente finalizada, enviarla a un archivo llamado archivo.org, dónde están todas las tareas archivadas.

Vamos a ver esta posibilidad tan sencilla, que podemos tener integrada en nuestro flujo de trabajo diario con archivos orgmode y Emacs

** Configuración

1) *Creamos el archivo archivo.org*, el la misma ubicación donde tenemos *tareas.org*.

2) Al inicio del archivo orgmode tareas.org, añadiremos lo siguiente:

#+BEGIN_SRC 
#+ARCHIVE: archivo.org::
#+END_SRC

Puedes poner el nombre de archivo que quieras

Podríamos utilizar otra ruta
#+BEGIN_SRC 
#+ARCHIVE: ~/archivo.org::
#+END_SRC
Ahora, guardará las tareas archivadas en la carpeta HOME.

También podemos utilizar el comodín *%s*, para que añada el nombre del archivo orgmode actual que estamos editando, seguido de -archivo.org
#+BEGIN_SRC 
#+ARCHIVE: %s-archivo.org::
#+END_SRC

** Archivar

Con el comando =C-c C-x a=, añadirá la etiqueta *ARCHIVE*.
Además, el color quedará sombreado y el subárbol debajo se oculta.

** Mover tareas Archivadas

Si pulsamos el atajo =C-c C-x C-a=, enviará la entrada donde estamos situados, al archivo *archivo.org.*

Este atajo sería el equivalente a introducir el comando =M-x org-archive-subtree-default=.

*Esta tarea, es probable que sea escrita en el momento que salgamos de Emacs*

Para mover todo un subarbol, utilizaremos el atajos =C-c C-x C-s=.

** Fuentes

- https://orgmode.org/manual/Internal-archiving.html#Internal-archiving
- https://orgmode.org/manual/Moving-subtrees.html#Moving-subtrees



* DONE Instalando, Compilando el última versión de Rclone-Browser
:PROPERTIES:
:TITLE: Instalando, Compilando el última versión de Rclone-Browser
:EXPORT_FILE_NAME: instalando-compilando-el-ultima-version-de-rclone-browser
:DESCRIPTION:
:EXPORT_DATE: 2020-02-16 14:30
:CATEGORY: rclone
:TAG: backup
:IMAGE: ./images-blog/rclone.png
:END:

  
En los repositorios oficiales de Ubuntu, Debian,... Ya encontramos *Rclone-Browser*, de manera que con un simple =sudo apt install rclone-browser=, lo tendremos instalados. Pero la versión que hay en los repositorios, es la versión 1.2 de creador de la aplicación.
#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

A parte de ser una versión antigua, con las nuevas versiones de Ubuntu, Debian,... ya no podemos ver la barra del estado del archivo cuando lo subimos o bajamos.

[[https://github.com/kapitainsky][kapitainsky]] ha hecho un Fork y actualizado estas deficiencias, estando hoy ya en la versión 1.7.

Para poder disfrutar de esta versión, tendremos que compilar, pero veréis que es muy sencillo.

Para el resto de distros o sistemas operativos, te recomiendo vistar el repositorio de GitHub que encontrarás en las fuentes del artículo.

** Instalación
#+BEGIN_SRC 
sudo apt update && sudo apt -y install git g++ cmake make qtdeclarative5-dev
#+END_SRC

** Clonar Repositorio y compilar

#+BEGIN_SRC 
git clone https://github.com/kapitainsky/RcloneBrowser.git
#+END_SRC

Accedemos al interior de la carpeta
#+BEGIN_SRC 
cd RcloneBrowser
#+END_SRC


Crear nueva carpeta de compilación
#+BEGIN_SRC 
mkdir build && cd build
#+END_SRC
 
Ejecuta cmake desde la carpeta de compilación para crear un archivo MAKE

#+BEGIN_SRC 
cmake ..
#+END_SRC

Ejecute make desde la carpeta de compilación para crear binario
#+BEGIN_SRC 
make
#+END_SRC

Instalar sudo make install

#+BEGIN_SRC 
sudo make install
#+END_SRC

** Abriendo el Rclone-Browser
Vamos ahora a teclear en la terminal
#+BEGIN_SRC 
rclone-browser
#+END_SRC

Ya podemos disfrutar de esta última versión

** Fuente
- https://github.com/kapitainsky/RcloneBrowser#linux


#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

* Simplenote para terminal. Sncli
  :PROPERTIES:
  :ARCHIVE_TIME: 2020-02-26 mié 19:40
  :ARCHIVE_FILE: ~/docker/webdav/02_Org/tareas.org
  :ARCHIVE_OLPATH: Artículos
  :ARCHIVE_CATEGORY: tareas
  :END:

sncli es una aplicación desarrollada en Python que da acceso a tu cuenta Simplenote a través de la línea de comando. Puede acceder a tus notas a través de una GUI de consola personalizable que implementa atajos tipo vi o mediante una interfaz de línea de comandos simple que puedes escribir.

** Instalación

#+BEGIN_SRC 
sudo pip3 install sncli
#+END_SRC

** Archivo de configuración

Está en la ruta  =/home/angel/.snclirc=

La ruta del archivo por defecto es:
#+BEGIN_SRC 
nano /home/angel/.snclirc
#+END_SRC

Si queremos utilizar una ruta personalizada, utilizaremos la opción *-c*.
#+BEGIN_SRC 
sncli -c ~/emacs/snclirc
#+END_SRC


La plantilla de un archivo sería:
#+BEGIN_SRC 
[sncli]
cfg_sn_username = lebowski@thedude.com
cfg_sn_password = nihilist
#+END_SRC

** Caché

La notas quedan guardadas en local en =~/.sncli=

** Atajos

Los atajos son prácticamente los mismos que utilizamos en vim.

*** Movimiento

- j -> Moverse por el listado de notas hacia abajo
- k -> Moverse por el listado de notas hacia arriba
- J -> Estando dentro de una nota, ver la siguiente
- K -> Estando dentro de una nota, ver la anterior
- Space -> Página hacia abajo
- b -> Página hacia arriba
- s -> Ver el estado y cambiar el estado con el servidor (Online)
- l -> logs

*** Crea Notas, editar,...

- C -> Crear una nueva nota
- e -> Editar nota
- Enter -> Ver nota
- / -> Buscar
- d -> Ordenar por fecha
- A -> Limpiar búsqueda
- Ctrl + t -> Ordenar por etiquetas
- T -> Enviar una nota a la papelera (Te pide confirmación, antes de harcerlo).
- p -> Añadir pin a una nota
- m -> Marcar la nota como markdown
- t -> Añadir etiqueta a una nota

*** Navegar por las versiones

- < -> Versión anterior
- > -> Versión siguiente

*** Opciones para salir

Como en vim:

- :w -> Guardar
- :Q! -> Forzar la salida
- :q -> Salir
- :q! -> Forzar la salida
- :wq -> Grabar y salir

*** Ayuda

- h -> Ayuda

** Fuente

- https://github.com/insanum/sncli

* DONE Simplenote para terminal. Sncli
:PROPERTIES:
:TITLE: Simplenote para terminal. Sncli
:EXPORT_FILE_NAME: simplenote-para-terminal-sncli
:DESCRIPTION:
:EXPORT_DATE: 2020-02-26 19:45
:CATEGORY: notas
:TAG: simplenote,terminal,aplicaciones
:IMAGE: ./images-blog/simplenote.png
:END:

sncli es una aplicación desarrollada en Python que da acceso a tu cuenta Simplenote a través de la línea de comando. 
#+HTML: <center>
[[./images-blog/simplenote.png]]
#+HTML: </center>

Puedes acceder a tus notas a través de una GUI de consola personalizable que implementa atajos tipo vi o mediante una interfaz de línea de comandos simple que puedes escribir.

** Instalación

#+BEGIN_SRC 
sudo pip3 install sncli
#+END_SRC

** Archivo de configuración

Está en la ruta  =/home/angel/.snclirc=

La ruta del archivo por defecto es:
#+BEGIN_SRC 
nano /home/angel/.snclirc
#+END_SRC

Aquí estoy utilizando mi nombre de usuario *angel*.

Si queremos utilizar una ruta personalizada, utilizaremos la opción *-c*.
#+BEGIN_SRC 
sncli -c ~/emacs/snclirc
#+END_SRC


La plantilla de un archivo sería:
#+BEGIN_SRC 
[sncli]
cfg_sn_username = ugeekpodcast@gmail.com
cfg_sn_password = vamnoiqhr8p9yq3ugf7btijv
#+END_SRC

** Caché

La notas quedan guardadas en local en =~/.sncli=

** Atajos

Los atajos son prácticamente los mismos que utilizamos en vim.

*** Movimiento

- j -> Moverse por el listado de notas hacia abajo
- k -> Moverse por el listado de notas hacia arriba
- J -> Estando dentro de una nota, ver la siguiente
- K -> Estando dentro de una nota, ver la anterior
- Space -> Página hacia abajo
- b -> Página hacia arriba
- s -> Ver el estado y cambiar el estado con el servidor (Online)
- l -> logs

*** Crea Notas, editar,...

- C -> Crear una nueva nota
- e -> Editar nota
- Enter -> Ver nota
- / -> Buscar
- d -> Ordenar por fecha
- A -> Limpiar búsqueda
- Ctrl + t -> Ordenar por etiquetas
- T -> Enviar una nota a la papelera (Te pide confirmación, antes de harcerlo).
- p -> Añadir pin a una nota
- m -> Marcar la nota como markdown
- t -> Añadir etiqueta a una nota

*** Navegar por las versiones

- < -> Versión anterior
- > -> Versión siguiente

*** Opciones para salir

Como en vim:

- :w -> Guardar
- :Q! -> Forzar la salida
- :q -> Salir
- :q! -> Forzar la salida
- :wq -> Grabar y salir

*** Ayuda

- h -> Ayuda

** Fuente

- https://github.com/insanum/sncli


* DONE Telegram Desktop. Atajos de teclado
:PROPERTIES:
:TITLE: Telegram Desktop. Atajos de teclado
:EXPORT_FILE_NAME: telegram-desktop-atajos-de-teclado
:DESCRIPTION:
:EXPORT_DATE: 2020-02-27 21:13
:CATEGORY: telegram
:TAG: atajos
:IMAGE: ./images-blog/telegram.png
:END:

Siguiendo con mi objetivo de utilizar todas las aplicaciones de mi pc, únicamente con teclado, sin necesidad de utilizar el ratón, hoy toca el turno de Telegram Desktop.
#+HTML: <center>
[[./images-blog/telegram.png]]
#+HTML: </center>

De salida, puede dar la sensación que no se pueda utilizar Telegram Desktop con teclado, pero como veréis en este artículo, si se puede.

** Movernos por la pantalla principal
Por defecto, el cursor está en la cajetilla de búsqueda. *Si escribimos, se escribirá en la cajetilla de búsqueda*.

Para salir de un chat o donde sea que estemos *ESC*.

- Navegar por los chats -> arriba, abajo
- Seleccionar un Chat -> Enter
- Salir del Chat -> *ESC*

Ya nos podemos mover por los chats, entrar, salir,...

** Chats

Estando dentro de un chat...

- Saltar de un Chat al siguiente -> Alt + ↓  o  Alt + ↑
- Enviar un archivo -> Ctrl + O
- Editar último mensaje enviado -> arriba 
- Buscar en el chat -> Ctrl + f
- Desplazarte por el el historial del chat ->  ↓ o ↑
- Desplazarte por el el historial del chat, página a página -> Tecla de Pag sig. o Pag. anterior

** Chats Anclados

- Primer Chat anclado -> Ctrl + 1
- Segundo Chat anclado -> Ctrl + 2
- ...

** Enviar Emoji o Sticker

1) Escribimos *:* seguido del nombre del emoji en inglés.
2) Nos previsualizará emoji en función del nombre que vamos escribiendo, seleccionamos el que deseamos con *ENTER*. Si queremos enviar ese emoji, volveremos a pulsar *ENTER*.
3) Si quieres enviar un *Sticker*, Ahora nos previsualiza *Stickers* disponibles asociados a este *emoji*. Seleccionamos el que deseamos con las flechas y pulsamos *Enter*.

** Listado de Emoji


** General

- Minimizar telgram Desktop -> Ctrl + w
- Salir de Telegram Descktop -> Ctrl + q
- Bloquear si tienes contraseña -> Ctrl + l

** Fuente

- https://github.com/telegramdesktop/tdesktop/wiki/Keyboard-Shortcuts
- https://www.webfx.com/tools/emoji-cheat-sheet/
- https://gist.github.com/rxaviers/7360908
- https://gist.github.com/uGeek/9cccca4bb924aa0b59269a2ae7637527


* Fuentes
  :PROPERTIES:
  :ARCHIVE_TIME: 2020-03-09 lun 21:11
  :ARCHIVE_FILE: ~/docker/webdav/02_Org/tareas.org
  :ARCHIVE_OLPATH: Artículos/El mejor y más ligero cliente para tu Escritorio de Jellyfin. Jellyfin-cli
  :ARCHIVE_CATEGORY: tareas
  :END:
- https://github.com/marios8543/Jellyfin-CLI




* DONE El mejor y más ligero cliente para tu Escritorio de Jellyfin. Jellyfin-cli
:PROPERTIES:
:TITLE: El mejor y más ligero cliente para tu Escritorio de Jellyfin. Jellyfin-cli
:EXPORT_FILE_NAME: el-mejor-y-mas-ligero-cliente-para-tu-escritorio-de-jellyfin-jellyfin-cli
:DESCRIPTION:
:EXPORT_DATE: 2020-03-09 21:14
:CATEGORY: jellyfin
:TAG: servidor,multimedia
:IMAGE: ./images-blog/jellyfin.png
:END:

Para que Jellyfin sea del todo perfecto, sería necesario el poder reproducir el contenido multimedia desde mi Escritorio de un modo instantáneo y súper ligero.

Ya os hablé de una aplicación de Jellyfin desarrollada en Electron, pero Electron no se caracteriza por su ligereza.

#+HTML: <center>
[[./images-blog/jellyfin.png]]
#+HTML: </center>

Para mí, la aplicación perfecta sería aquella que hiciera uso de VLC o MPV para reproducir en streaming, del mismo modo que hago con mi Android TV y FireStick.

El desarrollador Griego [[https://github.com/marios8543][marios8543]], ha creado esta joya, *jellyfin-cli*.

Jellyfin-cli es un cliente para terminal escrito en Python con urwid.

Desde nuestra terminal, accedemos a través de los menús de Jellyfin hasta encontrar el contenido multimedia que queremos reproducir. MPV, VLC, o cualquier otro reproductor que permita la reproducción en streaming, se abrirá para reproducirlo.

Por ponerle un defecto, de momento no permite la reproducción de música y su desarrollador de momento no tiene pensado el implementar esta opción.

Tampoco se como ir hacia atrás por las bibliotecas. Para salir de Jellyfin-cli, *Ctrl+c*.

Aún así, para mi es ya mi aplicación de escritorio favorita de Jellyfin. 

Vamos a ver como instalarla, veréis que es muy sencillo.

** Instalación 
1) Clonamos el repositorio y accedemos al interior
#+BEGIN_SRC 
git clone https://github.com/marios8543/Jellyfin-CLI.git
#+END_SRC

#+BEGIN_SRC 
cd Jellyfin-CLI
#+END_SRC


2) Ahora vamos a instalar algunas dependencias de python necesarias:
#+BEGIN_SRC 
pip3 install --user jellyfin-cli
#+END_SRC

También podemos instalarlo como sudo. Lo instalaríamos así:

#+BEGIN_SRC 
sudo pip3 install -r requirements.txt
#+END_SRC
** Ejecutando jellyfin-cli
Vamos a ejecutar jellyfin-cli:
#+BEGIN_SRC 
python3 jellyfin-cli
#+END_SRC

Ahora Jellyfin-cli nos pedirá:
1) Url del servidor. En mi caso: http://192.168.1.100:8096
2) Usuario: angel
3) Contraseña: 1234

** Cambiar el reproductor por defecto
Para cambiar el reproductor por defecto, en mi caso VLC:
#+BEGIN_SRC 
PLAYER_PATH="/usr/bin/vlc"
#+END_SRC

Tengo que deciros que esta opción está en el repositorio de Jellyfin-cli, pero a mi no me ha funcionado.


** Fuentes
- https://github.com/marios8543/Jellyfin-CLI
#+HTML: <center>
[[./images-blog/jellyfin-cli.png]]
#+HTML: </center>
* DONE Escuchando música de mi servidor Jellyfin con jellycli
:PROPERTIES:
:TITLE: Escuchando música de mi servidor Jellyfin con jellycli
:EXPORT_FILE_NAME: escuchando-musica-de-mi-servidor-jellyfin-con-jellycli
:DESCRIPTION:
:EXPORT_DATE: 2020-03-10 20:04
:CATEGORY: jellyfin
:TAG: música,servidor,raspberry
:IMAGE: ./images-blog/jellifin.jpg
:END:

Esta una de esas aplicaciones que me encantan. Parece magia verla funcionar.
Y es que Jellycli es una aplicación desarrollada por el finlandés [[https://github.com/tryffel][Tero Vierimaa]], que nos permite el poder escuchar toda la biblioteca musical que tenemos en Jellyfin, en nuestro escritorio y a través de la terminal.
[[./images-blog/jellifin.jpg]]
#+HTML: <center>
#+HTML: </center>

Jellycli está desarrollada en Go y actualmente tiene las siguientes características:
- Reproducir canciones
- Reproducir álbumes
- Agregar canciones a la cola
- Controla (y ve) el estado de reproducción a través de la integración Dbus
Control desde otros clientes a través de websocket. Actualmente implementado:
- Reproducir / pausar / detener
- Regular volumen
- Siguiente pista
#+HTML: <center>
[[./images-blog/jellycli.png]]
#+HTML: </center>

Acaba de actualizar la aplicación a la versión 0.2.0 y gracias a una consulta/sugerencia que hice, el desarrollador ha implementado el que podamos tener un archivo de configuración y gracias a esto, el poder exportarlo a otra cliente o crear múltiples archivos de configuración para varios servidores.

** Instalar Go 
No voy a extenderme a explicar en este artículo como instalar Go ya que no es el propósito del mismo, pero si quieres instalarlo de un modo rápido y sin complicarte, podemos instalarlo con snap.
#+BEGIN_SRC 
sudo snap install go --classic
#+END_SRC

** Instalar Jellycli
Clonaremos el repositorio desde GitHub y vamos a construir el paquete
*** Con Go instalado en el sistema 

#+BEGIN_SRC 
git clone https://github.com/tryffel/jellycli.git
cd jellycli
go build .
./jellycli
#+END_SRC

*** Con Go instalado mediante snap

#+BEGIN_SRC 
git clone https://github.com/tryffel/jellycli.git
cd jellycli
/snap/bin/go build .
./jellycli
#+END_SRC


** Iniciando Jellycli
Vamos a iniciar la aplicación dentro del directorio, una vez construido el paquete de Jellycli y conectarlo con mi servidor Jellyfin, siguiendo mi ejemplo.

La primera vez que iniciamos, la aplicación solicita:
- El host Jellyfin: http://192.168.1.100:8096
- Nombre de usuario: angel
- Contraseña: 1234
- Número de Biblioteca donde está la música: En mi caso es el 1

** Archivo de Configuración
Una vez iniciada la sesión, se crea una archivo de configuración en la siguiente ruta =~/.config/jellycli/jellycli.yaml=. 

Puedes usar varios servidores con sus diferentes archivos de configuración, ejecutando:

#+BEGIN_SRC 
jellycli --config /home/angel/.config/jellycli/rp4.yaml
#+END_SRC

#+BEGIN_SRC 
jellycli --config /home/angel/.config/jellycli/debian.yaml
#+END_SRC

** Uso
Una vez abierta la aplicación, veremos que tenemos disponible la ayuda pulsando la tecla *F1*. 

Todas las funciones visibles de la aplicación, al lado tienen a que tecla corresponden.

Para movernos por los paneles, utilizaremos la tecla *TAB*, para seleccionar la tecla *ENTER* y para salir de la aplicación *Ctrl+c*.

Subir y bajar por las canciones, artistas,...  podemos utilizar tanto las flechas del teclado, así como los atajos de Vim.

- Subir y bajar -> j,k
- Arriba de la página o Abajo -> g,G
- Página arriba, página abajo -> Ctrl+F , Ctrl+B

** Alias
He creado un alias para no tener que acceder a la carpeta de jellycli cada vez que quiero utilizarlo. Así con un simple *jellycli*, estoy escuchando mi música favorita.

#+BEGIN_SRC 
alias jellycli='/home/angel/jellycli/jellycli'
#+END_SRC
  

** Fuentes
- https://github.com/tryffel/jellycli

#+HTML: <center>
[[./images-blog/jellycli]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/jellycli.png]]
#+HTML: </center>



* TODO Instalar Brave en Ubuntu, Debian, Mint
:PROPERTIES:
:TITLE: Instalar Brave en Ubuntu, Debian, Mint
:EXPORT_FILE_NAME: instalar-brave-en-ubuntu-debian-mint
:DESCRIPTION:
:EXPORT_DATE: 2020-03-12 17:40
:CATEGORY: navegador
:TAG: brave
:IMAGE: ./images-blog/brave.png
:END:
Brave es el navegador de moda. Vamos a ver como instalarlo en Debian, Ubuntu, Mint,...

#+HTML: <center>
[[./images-blog/brave.png]]
#+HTML: </center>

** Instalación en Debian, Ubuntu, Linux Mint

#+BEGIN_SRC 
sudo apt install apt-transport-https curl

curl -s https://brave-browser-apt-release.s3.brave.com/brave-core.asc | sudo apt-key --keyring /etc/apt/trusted.gpg.d/brave-browser-release.gpg add -

echo "deb [arch=amd64] https://brave-browser-apt-release.s3.brave.com/ stable main" | sudo tee /etc/apt/sources.list.d/brave-browser-release.list

sudo apt update

sudo apt install brave-browser
#+END_SRC

** Instalación resto de distros
Si utilizas otra distro o sistema operativo, puedes instalar Brave [[https://brave-browser.readthedocs.io/en/latest/installing-brave.html#linux][accediendo a esta url]].


** Añade extensiones
En Brave podemos instalar las extensiones de [[https://chrome.google.com/webstore/category/extensions?hl=es][Google Chrome]].

** Fuentes
- https://brave-browser.readthedocs.io
* TODO Creando una página web de tu proyecto en GitHub
:PROPERTIES:
:TITLE: Creando una página web de tu proyecto en GitHub
:EXPORT_FILE_NAME: creando-una-pagina-web-de-tu-proyecto-en-github
:DESCRIPTION:
:EXPORT_DATE: 2020-03-11 19:36
:CATEGORY: git
:TAG: github
:IMAGE: ./images-blog/github.png
:END:

Quizás tengas un repositorio en GitHub donde tengas un proyecto y quieras crear una sencilla web para mostrar una breve docuementación.
#+HTML: <center>
[[./images-blog/github.png]]
#+HTML: </center>

La página tendrá la dirección web =https://tu_usuario.github.io/nombre_repositorio=. 

Podríamos personalizar incluso el css de la página, pero eso lo dejamos para otro artículo.

Vamos a ver como se crea esta página web

** Crear GitHub Page del proyecto

No vamos a *settings* y buscamos en el apartado *GitHub Pages*.

Seleccionamos la rama *master* y más abajo pulsamos *Choose a theme* para elegir el tema. En mi caso seleccionaré el tema *state*.

Esto creará un archivo en la raíz llamado *_config.yml* en la raíz del repositorio, donde incluye:
#+BEGIN_SRC 
theme: jekyll-theme-slate
#+END_SRC

** Archivo de Configuración _config.yml

Ahora en nuestro archivo de configuración, podemos añadir más información, como...
#+BEGIN_SRC 
theme: jekyll-theme-slate
title: Titulo
description: <br>Descripción<br><br> 
lang: es
google_analytics: UA-131585940-1 
#+END_SRC

** Crear la página

Para crear la web principal, tan sencillo como crear un archivo *index.md* en la raíz del directorio y GitHub lo convertirá el html por arte de magia, gracias a jekyll.

** Script

Siguiendo los pasos anteriores, vamos ha hacer un script para generar de forma automática la web.

#+BEGIN_SRC 
#!/bin/bash
#
#
#
#

cp README.md > index.md

echo "theme: jekyll-theme-slate
google_analytics: UA-131585940-1
lang: es" > _config.yml
#+END_SRC

** Fuentes

- https://github.com/pages-themes/slate



* TODO Rclone bidireccional con Rclonesync
:PROPERTIES:
:TITLE: Rclone bidireccional con Rclonesync
:EXPORT_FILE_NAME: rclone-bidireccional-con-rclonesync
:DESCRIPTION:
:EXPORT_DATE: 2020-03-26 19:50
:CATEGORY: rclone
:TAG: sincronización,sync,webdav,dropbox,drive
:IMAGE: ./images-blog/rclone.png
:END:

Rclone Es una herramienta genial que permite copiar y sincronizar archivos de tus nubes públicas o privadas. Pero tiene un pequeño defecto dentro de su perfección, esta sincronización es como rsync, en un único sentido. 

Gracias a este script desarrollado en python por [[https://github.com/cjnaz][Chris cjnaz]], solucionamos esta limitación podiento tener un directorio con una réplica exacta del contenido de tu nube en local y totalmente sincronizada de un modo bidireccional. 

De manera que si se modifica un archivo tanto en local como en el servidor, estos se sincronizaran instantáneamente teniendo una copia exacta en ambos sitios.
#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

De momento rclonesync ha sido probado con Dropbox, Google Drive, Box.com, OneDrive, Nextcloud, Owncloud, Webdav,... y en todos estos funciona perfectamente.

Vamos a ver las opciones básicas de uso e instalación en el propio sistema.

Si utilizas otros sistema operativo como Windows, si, en Windows también funciona, descarga únicamente el archivo *rclonesync.py* y ejecútalo con python.

** Instalación
He creado [[https://github.com/cjnaz/rclonesync-V2][un Fork del proyecto original]], para que si hay modificaciones en el código original, no haya problemas, ya que esta la he probado tanto en la Raspberry como en procesadores de 64 y 32 bits.

De todas maneras, eres libre de instalar la versión del proyecto original si han habido actualizaciones.

Vamos a instalarlo en el sistema.

#+BEGIN_SRC 
sudo curl \
  -L https://raw.githubusercontent.com/Bash-Projects/rclonesync-V2/master/rclonesync.py \
  -o /usr/local/bin/rclonesync && sudo chmod +x /usr/local/bin/rclonesync
#+END_SRC

Para no instalarlo en tu propio sistema y ejecutarlo con python:
#+BEGIN_SRC 
curl -L https://raw.githubusercontent.com/Bash-Projects/rclonesync-V2/master/rclonesync.py -o rclonesync.py
#+END_SRC
** Funcionamiento
El funcionamiento es muy simple, ejecutamos *rclonesync* ruta origen y ruta destino.

#+BEGIN_SRC 
rclonesync [RUTA_ORIGEN] [RUTA_DESTINO]
#+END_SRC

** Iniciando

Solo la primera vez que iniciamos, tenemos que poner como *ruta origen*, el directorio *no que tiene archivos*. 

Y *solo la primera vez*, iniciaremos el scritp con la opción =--first-sync=. En la ayuda también se especifica que podemos utilizar la opción =-1=.

*** Dropbox 
Ejemplo de cuenta una con dropbox, la he probado y funciona perfecto.
Este seria el ejemplo de mi primera sincronización:
#+BEGIN_SRC 
rclonesync /home/angel/dropbox  dropbox: --first-sync --verbose
#+END_SRC

*** Drive 
Utilizando Google Drive. Voy a sincronizar una subdirectorio dentro de mi Google Drive llamada sync:

Además, en este caso, estoy utilizando otro archivo de configuración de rclone.
#+BEGIN_SRC 
rclonesync  drive:sync /home/angel/drive --config "/home/angel/.config/rclone/otra_configuración.conf" --first-sync --verbose
#+END_SRC

*** Webdav 
Esto es una maravilla. Mi servidor de webdav, mediante rclonesync, es el mejor cliente para tener mis archivos orgmode y todo.txt sincronizado en todos mis servidores, pc, etc...
#+BEGIN_SRC 
rclonesync  webdav:  /home/angel/webdav --first-sync --verbose
#+END_SRC


** Forzar

Si se supera el 50% de archivos y carpetas para el borrado, tenemos que forzar con la opción =--force=, esta es una opción para evitar el que por error borremos archivos mediante la sincronización.
#+BEGIN_SRC 
--force
#+END_SRC

** Sincronización automatizada con cron.
Ahora vamos a tener sincronizado de forma automatizada, nuestra carpeta local con el contenido que tenemos en el servidor. Para ello utilizaremos *cron*. En este ejemplo he decidido que el directorio se sincronice cada 5 minutos.

#+BEGIN_SRC 
*/5 * * * * /usr/local/bin/rclonesync /home/angel/todo webdav:todo --verbose >> ~/.config/log_webdav_todo 2>&1
#+END_SRC

Cada 5 minutos, a parte de producirse la sincronización, todo quedará registrado en el archivo =~/.config/log_webdav_todo=. De esta manera puedo comprobar que todo funciona correctamente.


** Excluir archivos o directorios en la sincronización 
Mediante la opción =--filters-file=, podremos excluir archivos y directorios.

También podemos =--check-access= para una mejor medida adicional.

Este sería el cron:
#+BEGIN_SRC 
*/5 * * * * ~/scripts/rclonesync.py /home/angel/drive/ drive: --check-access --filters-file ~/.rclonesyncwd/Filters  >> ~/.config/log_drive 2>&1
#+END_SRC

** Conclusión
Rclonesync tiene muchísimas más opciones que puedes consultar en la documentación o ejecutando en tu terminal:

#+BEGIN_SRC 
rclonesync -h
#+END_SRC

Este artículo solo es una guía de iniciación. No descarto en un futuro profundizar más el resto de opciones.

** Fuentes

- https://github.com/cjnaz/rclonesync-V2

* DONE Creando contenedores con dockerc
:PROPERTIES:
:TITLE: Creando contenedores con dockerc
:EXPORT_FILE_NAME: creando-contenedores-con-dockerc
:DESCRIPTION:
:EXPORT_DATE: 2020-03-31 15:22
:CATEGORY: docker
:TAG: app
:IMAGE: ./images-blog/docker.png
:END:

El motivo de crear esta aplicación es bash que he desarrollado, es tener en una carpeta archivos de texto plano con la extensión .docker y en su contenido las líneas de terminal que escribirias en la terminal para montar el contenedor.

#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

La aplicación te permite tanto el crear el archivo para guardar estas líneas, así como poder montar un contenedor o un grupo de contendores todo de manera automatizada.

Si tienes tu lista de dockers favoritos en una carpeta, instalar de cero una Raspberry Pi, por ejemplo, con un simple =dockerc a= auto instalará todos los dockers que hayamos guardado en esa carpeta.

** Instalación
Si tienes Linux, es tan simple como:
#+BEGIN_SRC 
sudo curl -L https://raw.githubusercontent.com/uGeek/dockerc/master/dockerc \
          -o /usr/bin/dockerc && sudo chmod +x /usr/bin/dockerc
#+END_SRC
** Archivo de Configuración
La primera vez que ejecutemos cualquier comando con dockerc, nos hará dos preguntas:
- En que directorio vamos a guardar nuestros dockers
- Que editor de texto queremos utilizar para editarlos

Tras responder estas preguntas, dockerc creará una archivo de configuración en =~/.config/dockerc/dockerc.conf=.

** Guardar un docker
Para guardar un docker con dockerc, tienes que ejecutar el comando =dockerc n=. Dockerc te preguntará:
- En que grupo de contenedores quieres guardarlo.
- Nombre del docker

Te abrirá el editor de texto que decidiste la primera vez que iniciaste dockerc, para que guardes las líneas de terminal que escribirias en tu terminal para crear el docker y creará un archivo de texto plano con la extensión .docker.

*** Ejemplo 
Supongamos que he elegido el directorio =/home/angel/dockerc/=, yo he creado los siguientes grupos de dockers:

- =/home/angel/dockerc/rpi=
- =/home/angel/dockerc/amd64/=
- =/home/angel/dockerc/automontaje=

En la carpeta rpi, dejo los archivos de los dockers para Raspberry Pi, en la *amd64*, los dockers para arquitectura 64bits y en automontaje, los dockers que quiero montar en mi Raspberry Pi de forma automatizada.

Un archivo =.docker=, tendría la siguiente estructura:

#+BEGIN_SRC 
# Docker Supysonic
docker run --name supysonic --restart=unless-stopped -v $HOME/docker/supysonic:/var/lib/supysonic -v /media:/media -p 8080:8080 ugeek/supysonic:arm-0.5.0
#+END_SRC

Si le decimos a *dockerc* que este docker es Supysonic y pertenece al grupo de rpi, dockerc creará un archivo de texto plano con este contenido en la ruta =/home/angel/dockerc/rpi/supysonic.docker=

*** Crealo como quieras
No es necesario crearlos con dockerc, cualquier archivo que contenga las líneas de terminal que pondrías en la terminal para montar el docker y estén en el directorio, dockerc los visualizará y podrá montarlos.

La idea es que puedas guardar estos archivos y compartirlos o utilizarlos en otra máquina y poder hacer el automontaje de todos los contenedores de una vez.

** Crear un docker
Para crear un docker que tengamos guardado, es tan simple como escribir en tal terminal:
#+BEGIN_SRC 
dockerc 
#+END_SRC

Dockerc te preguntará:
- ¿A Que grupo pertenece?. En mi ejemplo =rpi=. Te listará todos los dockers que tienes guardados en esa carpeta
- Que docker quieres crear. En mi caso voy crear el de Supysonic
- Abre el editor de texto con el archivo =suypysonic.docker=, por si quieres cambiar una opción antes de montarlo, como puertos, volumenes...

Una vez contestado todo, comienza la creación del docker.

** Montar muchos dockers automatizado
Yo utilizo la carpeta automontaje pero podría ser cualquier otra donde tubieras todos tus archivos .docker.

Para automontarlos:

#+BEGIN_SRC 
dockerc a
#+END_SRC

Dockerc te preguntará en que grupo o directorio están los .docker que quieres crear. Dockerc comenzará a crear todos los contenedores un tras otro de forma automátizada.

** Contenedores y sus puertos
Dockerc te permite visualizar todos los contenedores que están corriendo y sus puertos. Para verlos:
#+BEGIN_SRC 
dockerc c
#+END_SRC 

También permite con la opción *ls*.
#+BEGIN_SRC 
dockerc ls
#+END_SRC

Veriamos en la terminal:
#+BEGIN_SRC 
----------------------------------
CONTAINERS CORRIENDO Y SUS PUERTOS
----------------------------------
bitwarden           3012/tcp, 0.0.0.0:1000->80/tcp
duckdns             
ejabberd            0.0.0.0:5222->5222/tcp, 0.0.0.0:5280->5280/tcp, 5269/tcp
jellyfin            0.0.0.0:8096->8096/tcp
mariadb             0.0.0.0:3306->3306/tcp
portainer           0.0.0.0:9000->9000/tcp
supysonic           0.0.0.0:8080->8080/tcp
syncthing           21027/udp, 0.0.0.0:8385->8384/tcp, 0.0.0.0:22001->22000/tcp
tt-rss              443/tcp, 0.0.0.0:81->80/tcp
webdav              0.0.0.0:80->80/tcp
#+END_SRC

** Contenedores creados
Podemos ver todos los contenedores creado con el comando
#+BEGIN_SRC 
dockerc c -a
#+END_SRC

o

#+BEGIN_SRC 
dockerc ls -a
#+END_SRC

Veriamos en la terminal:
#+BEGIN_SRC 
----------------------
CONTAINERS DISPONIBLES
----------------------
bitwarden
duckdns
ejabberd
jellyfin
letsencrypt
mariadb
mumble
musikcube
nginx
ouroboros
portainer
resilio
supysonic
syncthing
tautulli
tt-rss
wallabag
webdav
#+END_SRC

** Imágenes con su fecha de creación
Para seguir las actualizaciones de las imágenes, dockerc ordena estas por fecha. Para visualizar las imágenes
#+BEGIN_SRC 
dockerc i
#+END_SRC

La terminal muestra
#+BEGIN_SRC 
--------
IMAGENES
--------
CREATED             REPOSITORY:TAG                     SIZE
3 days ago          ugeek/traefik:arm                  63.4MB
4 days ago          bitwardenrs/server:raspberry       140MB
5 days ago          ugeek/mumble-ubuntu:arm            87.3MB
7 days ago          python:alpine                      77.1MB
7 days ago          alpine:latest                      3.81MB
7 days ago          arm32v6/alpine:3.11                4.81MB
7 days ago          ugeek/webdab-apache:arm            84MB
#+END_SRC

** Ayuda
#+BEGIN_SRC 
dockerc -h
#+END_SRC

o 

#+BEGIN_SRC 
dockerc --help
#+END_SRC

#+BEGIN_SRC 

Modo de empleo: dockerc [OPCIONES]

dockerc                 -> Menú para crear un contendor guardado
dockerc   a             -> Automontaje de todos los dockers de un grupo
dockerc   n             -> Guarda un nuevo docker
dockerc   i             -> Imagenes listadas por creación
dockerc   c,    ls      -> Dockers que están corriendo y sus puertos
dockerc   c -a ,ls -a   -> Todos los Dockers disponibles
dockerc  -h, --help     -> Ayuda


dockerc v0.8 30/03/2020
 Copyright (C) 2020 Angel. uGeek
 ugeekpodcast@gmail.com

#+END_SRC

** Conclusión
Esta es una aplicación que he creado para mi que me ha sido de mucha utilidad. Espero que si tienes la misma necesidad que yo, la disfrutes mucho.





* EteSync. Tareas, Contactos y Agendas, sincronizadas de extremo a extremo
  :PROPERTIES:
  :ARCHIVE_TIME: 2020-04-01 mié 18:53
  :ARCHIVE_FILE: ~/docker/webdav/02_Org/tareas.org
  :ARCHIVE_OLPATH: Artículos
  :ARCHIVE_CATEGORY: tareas
  :END:
EteSync es un servicio/aplicaciones similar a CalDAV, pero que permite una sincronización segura, de extremo a extremo para tus contactos, calendarios y tareas.

Se integra a la perfección con sus aplicaciones existentes en dispositivos android y IOS. Guarda un historial completo de tus datos en un diario cifrado pudiendo revisar, reproducir y revertir cualquier cambio que haya realizado en cualquier momento.

Vamos a ver como poder crear el docker y poder utilizarlo en la Raspberry Pi o placa ARM.

** Docker ARM y Raspberry Pi
Escribe el usuario y contraseña que registraras en tu servidor. Cuando inicies por primera vez el cliente en cualquier de las versiones, movil, web,... Te pedirá que pongas una contraseña, que después podrás cambiar, para el cifrado extremo a extremo.

#+BEGIN_SRC 
docker run --name etesync -d \
  -e SUPER_USER="USUARIO" \
  -e SUPER_PASS="CONTRASEÑA" \
  -p 3735:3735 \
  -v $HOME/docker/etesync/host:/data \
   ugeek/etesync:arm
#+END_SRC

** Fuentes
- https://www.etesync.com/
- https://github.com/etesync
- 

* DONE EteSync. Tareas, Contactos y Agendas, sincronizadas de extremo a extremo
:PROPERTIES:
:TITLE: EteSync. Tareas, Contactos y Agendas, sincronizadas de extremo a extremo
:EXPORT_FILE_NAME: etesync-tareas-contactos-y-agendas-sincronizadas-de-extremo-a-extremo
:DESCRIPTION:
:EXPORT_DATE: 2020-04-01 19:20
:CATEGORY: tareas
:TAG: caldav,calendario
:IMAGE: ./images-blog/etesync.png
:END:

EteSync es un servicio/aplicaciones similar a CalDAV, pero que permite una sincronización segura, de extremo a extremo para tus contactos, calendarios y tareas.

Se integra a la perfección con sus aplicaciones existentes en dispositivos android y IOS. Guarda un historial completo de tus datos en un diario cifrado pudiendo revisar, reproducir y revertir cualquier cambio que haya realizado en cualquier momento.
#+HTML: <center>
[[./images-blog/etesync.png]]
#+HTML: </center>

Vamos a ver como poder crear el docker y poder utilizarlo en la Raspberry Pi o placa ARM.

** Docker ARM y Raspberry Pi
Escribe el usuario y contraseña que registraras en tu servidor. Cuando inicies por primera vez el cliente en cualquier de las versiones, movil, web,... Te pedirá que pongas una contraseña, que después podrás cambiar, para el cifrado extremo a extremo.

#+BEGIN_SRC 
docker run --name etesync -d \
  -e SUPER_USER="USUARIO" \
  -e SUPER_PASS="CONTRASEÑA" \
  -p 3735:3735 \
  -v $HOME/docker/etesync/host:/data \
   ugeek/etesync:arm
#+END_SRC

** Fuentes
- https://www.etesync.com/
- https://github.com/etesync
- 

* DONE Radicale. Calendario y Tareas sincronizadas mediante CalDAV y CardDAV
:PROPERTIES:
:TITLE: Radicale. Calendario y Tareas sincronizadas mediante CalDAV y CardDAV
:EXPORT_FILE_NAME: radicale-calendario-y-tareas-sincronizadas-mediante-caldav-y-carddav
:DESCRIPTION:
:EXPORT_DATE: 2020-04-02 17:30
:CATEGORY: tareas
:TAG: calendario,caldav,carddav,raspberry
:IMAGE: ./images-blog/radicale.png
:END:


Radicale es un servidor de calendario y libreta de direcciones. Está escrito en Python e implementa los estándares CalDAV y CardDAV.
#+HTML: <center>
[[./images-blog/radicale.png]]
#+HTML: </center>

La configuración recomendada para el uso de producción es servir a Apache en todo el sistema a través de uWSGI con autenticación basada en Apache

Vamos a instalarlo mediante docker en nuestra Raspberry Pi o servidor ARM.

** Docker para ARM y Raspberry
#+BEGIN_SRC 
docker create --name radicale -p 5232:5232 -v $HOME/docker/radicale:/data/radicale/collections  ugeek/radicale:arm
#+END_SRC
** Crear usuarios
Los usuarios están en el archivos:
#+BEGIN_SRC 
docker exec  -it radicale vi /data/radicale/users
#+END_SRC

La estructura del archivo de configuración es:
#+BEGIN_SRC 
usuario1:contraseña
usuario2:contraseña
#+END_SRC

En este archivo encontraremos:
#+BEGIN_SRC 
admin:$apr1$zuGWuE98$ZqFt7FKv8yROElvQy9.wh1
#+END_SRC

que corresponde a:
- usuario:admin
- contraseña:admin

En la contraseña vemos que hay una combinación de numero, letras, símbolos... Esto es debido a que esta contraseña está cifrada en md5.

Los cifrados mas seguros disponibles para la contraseña son =md5=, =bcrypt=.

También podemos optar por poner la contraseña en texto plano =plain=, pero esto sería inseguro si alguien accede al interior de nuestro servidor.

Para cambiar el tipo de cifrado o ponerlo en texto plano, accederemos al siguiente archivo de configuración:

#+BEGIN_SRC 
docker exec  -it radicale vi /etc/radicale/config 
#+END_SRC

Voy poner que esté en texto plano:

#+BEGIN_SRC 
[auth]
type = htpasswd
htpasswd_filename = /data/radicale/users
htpasswd_encryption = plain
#+END_SRC


Accedemos nuevamente al archivo de configuración
#+BEGIN_SRC 
docker exec  -it radicale vi /data/radicale/users
#+END_SRC 

Ahora voy a cambiarlo por usuario:angel password:1234 y el usuario:juan password:4321

#+BEGIN_SRC 
angel:1234
juan:4321
#+END_SRC

Para que todos esto cambios tengan efecto, tendremos que reiniciar el docker
#+BEGIN_SRC 
docker restart radicale
#+END_SRC

** Descarga un Backup
#+BEGIN_SRC 
wget -c -r -l 1 -nc --user='[myuser]' --password='[mypassword]' --accept=ics '[url]'
#+END_SRC

** Ayuda
#+BEGIN_SRC 
radicale --help
#+END_SRC

** Fuentes
- https://radicale.org
- https://hub.docker.com/u/ugeek




* DONE Shaarli. El Delicious del Software Libre
:PROPERTIES:
:TITLE: Shaarli. El Delicious del Software Libre
:EXPORT_FILE_NAME: shaarli-el-delicious-del-software-libre
:DESCRIPTION:
:EXPORT_DATE: 2020-04-02 11:30
:CATEGORY: docker
:TAG: servicio
:IMAGE: ./images-blog/shaarli.png
:END:

Shaarly es un servicio de marcadores personal, minimalista, súper rápido, sin bases de datos.

Es uno de los primeros servicios que instalé cuando me inicié en esto de la Raspberry.
#+HTML: <center>
[[./images-blog/shaarli.png]]
#+HTML: </center>

Shaarli es un servicio minimalista para compartir enlaces que puedes instalar en tu propio servidor. Te permite el tener un Feed, donde tus seguidores pueden seguir tu actividad.

Dispone de aplicación para android, de manera que cuando ves algo interesante, puedes compartirlo con Shaarli.

De momento no he podido montar el docker para ARM o Raspberry Pi, pero si para amd64.
** Conoce Shaarly
En esta [[https://demo.shaarli.org/][url hay una instancia de prueba donde puedes probarlo antes de montar el docker]].
- usuario: demo
- contraseña: demo

** Todo sobre Shaarly
Puedes encontrar toda la información como cambiar temas, etc... [[https://sebsauvage.net/wiki/doku.php?id=php:shaarli][en la Wiki de Shaarli]].

También puedes seguir la documentación en https://shaarli.readthedocs.io.

** Docker amd64
#+BEGIN_SRC 
docker run -it --name=shaarli -p 81:80 ugeek/shaarli:amd64
#+END_SRC

** Docker Oficial shaarly/shaarly
#+BEGIN_SRC 
docker create --name shaarly -p 80:80 shaarli/shaarli
#+END_SRC


* DONE Zerotier. Funcionamiento e instalación por docker o repositorios
:PROPERTIES:
:TITLE: Zerotier. Funcionamiento e instalación por docker o repositorios
:EXPORT_FILE_NAME: zerotier-funcionamiento-e-instalacion-por-docker-o-repositorios
:DESCRIPTION:
:EXPORT_DATE: 2020-04-05 17:00
:CATEGORY: docker
:TAG: vpn,raspberry,servidor
:IMAGE: ./images-blog/zerotier.png
:END:


Me gusta tener todos mis servicios instalados en mi máquina, pero hay cosas que de momento no pueden ser. Este es el ejemplo de *ZeroTier*, un servicio que he escuchado mucho hablar [[https://diario.mosqueteroweb.eu/][MosqueteroWeb]], [[https://naseros.com/][Mc Josan]] y [[https://www.eduardocollado.com][Eduardo Collado]].

La verdad es que no me he puesto manos a la obra para probarlo, por el motivo que explicaba al principio. Pero después de ver el vídeo de Mc Josan, no lo he podido evitar. 

¿Tan sencillo es *ZeroTier* como se ve en el vídeo y cuentan?

#+HTML: <center>
[[./images-blog/zerotier.png]]
#+HTML: </center>


*ZeroTier* está hecho para gente "normal" que no tiene ni idea de como funciona una VPN o simplemente, alguien como nosotros, que quiere algo que funcione en 5 minutos y simplemente, que funcione.

El funcionamiento de *ZeroTier* es el siguiente:
- Creas una subred que tendrá el llamado *Network ID*. Un identificador de la Red
- Instalas en todas las máquinas que deseas tener bajo esta nueva subred, *ZeroTier*.
- El servidor de *ZeroTier*, que no está en nuestra máquina, está en sus servidores y es la que nos ha dado el *Network ID*, igual que sucede con servicios como *Syncthing* o *Plex*, conecta todos aquellos clientes que tiene en mismo *Network ID* y estén online, conectados a internet en ese momento.

El servidor central de *ZeroTier*, localiza las ip's de todos los dispositivos que están conectados a internet, gracias a la app de ZeroTier y los conecta creando una red.

Para gestionar nuestras subredes creadas, nos conectaremos a: https://my.zerotier.com/


Está genial, ya que podemos montar un servidor con ciertos servicios y compartirlo con familiares, sin necesidad de montar una VPN y darle todos los privilegios de tener a ese familiar dentro de nuestra red local.

El tráfico va totalmente cifrado de extremo a extremo. Tal como comenta Mc Josan en su vídeo, los servidores de *ZeroTier*, única y exclusivamente, se encargan de localizar y conectar los clientes, no pasan los datos por sus servidores. Si eso es así, la verdad es que este servicio es alucinante.



Otro punto fuerte de *ZeroTier*, es que podemos instalarlo en todos los dispositivos. Windows, Linux, Mac, Android, IOS, Raspberry, placa con arquitectura ARM...

** Pierde el miedo a ZeroTier
Te dejo el vídeo donde Mc Josan explica el funcionamiento de la página de administración.

#+HTML: <center>
#+HTML:<iframe width="560" height="315" src="https://www.youtube.com/embed/ICMJ4rHk1Co" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
#+HTML: </center>

** Instalación desde Respositorios

ZeroTier está disponible en los repositorios de Debian Buster con el nombre *zerotier-one*

Para instalarlo:
#+BEGIN_SRC 
sudo apt install zerotier-one
#+END_SRC 

** Instalación de la última versión

#+BEGIN_SRC 
curl -s https://install.zerotier.com/ | sudo bash
#+END_SRC

** Añadir y Conectarnos a tu Network ID

Tanto la primera vez, como todas aquellas que queremos conectar nuestro dispositivo Linux a ZeroTier, utilizaremos el siguiente comando:
#+BEGIN_SRC 
sudo zerotier-cli join tu_Network_ID
#+END_SRC

** Desconectarnos del Network ID

Para que nuestro dispositivo Linux se desconecte de la red que hemos creado con ZeroTier, escribiremos los siguiente en la terminal:
#+BEGIN_SRC 
sudo zerotier-cli leave 9f77fc393e6ef772
#+END_SRC

** Docker
*** Docker para Raspberry y ARM
#+BEGIN_SRC 
docker run --name zerotier-one --device=/dev/net/tun --net=host \
  --cap-add=NET_ADMIN --cap-add=SYS_ADMIN \
  -v $HOME/docker/zerotier-one:/var/lib/zerotier-one ugeek/zerotier:arm
#+END_SRC
*** Docker para amd64
#+BEGIN_SRC 
docker run --name zerotier-one --device=/dev/net/tun --net=host \
  --cap-add=NET_ADMIN --cap-add=SYS_ADMIN \
  -v $HOME/docker/zerotier-one:/var/lib/zerotier-one ugeek/zerotier:amd64
#+END_SRC

*** Crear

#+BEGIN_SRC 
docker exec -it zerotier-one bash 
#+END_SRC

#+BEGIN_SRC 
zerotier-cli join 9f77fc393e6ef772
#+END_SRC

En un único comnado 
#+BEGIN_SRC 
docker exec -it zerotier-one zerotier-cli join 9f77fc393e6ef772
#+END_SRC

** Información

#+BEGIN_SRC 
sudo zerotier-cli info
#+END_SRC

** Fuente

- https://github.com/docker-projects/docker-zerotier



* DONE Instalar Brave en Ubuntu, Debian, Linux Mint
:PROPERTIES:
:TITLE: Instalar Brave en Ubuntu, Debian, Linux Mint
:EXPORT_FILE_NAME: instalar-brave-en-ubuntu-debian-linux-mint
:DESCRIPTION:
:EXPORT_DATE: 2020-04-02 14:21
:CATEGORY: navegador
:TAG: brave
:IMAGE: ./images-blog/brave.png
:END:

Brave es el navegador de moda, un navegador web de código abierto basado en Chromium creado por la compañía Brave Software y fundada por el cofundador del Proyecto Mozilla y creador de JavaScript, Brendan Eich.2​ 
Brave tiene la capacidad de bloquear de anuncios y rastreadores en línea.


#+HTML: <center>
[[./images-blog/brave.png]]
#+HTML: </center>

También dice proteger la privacidad de sus usuarios compartiendo menos datos con sus anunciantes.

Vamos a ver como instalarlo en nuestro pc con linux


** Instalación Debian, Ubuntu, Linux Mint desde los repositorios de Brave

Para añadir el repositorio de Brave en instalar:
#+BEGIN_SRC 
sudo apt install apt-transport-https curl

curl -s https://brave-browser-apt-release.s3.brave.com/brave-core.asc | sudo apt-key --keyring /etc/apt/trusted.gpg.d/brave-browser-release.gpg add -

echo "deb [arch=amd64] https://brave-browser-apt-release.s3.brave.com/ stable main" | sudo tee /etc/apt/sources.list.d/brave-browser-release.list

sudo apt update

sudo apt install brave-browser
#+END_SRC
** Por Snap
Brave también podemos instalarlo con una línea desde snap.
#+BEGIN_SRC 
sudo snap install brave
#+END_SRC
** Instalación resto de distros
Si quieres instalar Brave en otras distros

https://brave-browser.readthedocs.io/en/latest/installing-brave.html#linux

** Añade extensiones
Brave permite [[https://chrome.google.com/webstore/category/extensions?hl=es][instalar extensiones disponibles de Chronium]].
** Fuentes
- https://brave.com/



* DONE Varias cuentas de telegram en un mismo PC
:PROPERTIES:
:TITLE: Varias cuentas de telegram en un mismo PC
:EXPORT_FILE_NAME: varias-cuentas-de-telegram-en-un-mismo-pc
:DESCRIPTION:
:EXPORT_DATE: 2020-04-02 14:54
:CATEGORY: telegram
:TAG: ubuntu
:IMAGE: ./images-blog/telegram.png
:END:


Telegram ha añadido la clasificación por carpetas en Telegram Desktop, para poder clasificar todos aquellos canales y grupos que tenemos por categorías, pero de momento, no tenemos disponible la multicuenta, pudiendo tener nuestra cuenta personal y de trabajo todo en un mismo PC. 

#+HTML: <center>
[[./images-blog/telegram.png]]
#+HTML: </center>


Vamos a ver como poder hacer esto de un modo sencillo.
** Creamos una carpeta de usuario
Crea una carpeta por cada usuario. Voy a crear mi cuenta personal como =angel_bcn= 
#+BEGIN_SRC 
mkdir -p ~/telegram-desktop/angel_bcn/
#+END_SRC

y la de trabajo como =trabajo=.
#+BEGIN_SRC 
mkdir -p ~/telegram-desktop/trabajo/
#+END_SRC
** Uso
*** Repositorios 
Si tienes telegram instalada con los paquetes oficiales.

#+BEGIN_SRC 
/usr/bin/telegram-desktop -workdir  ~/telegram-desktop/angel_bcn/ &
#+END_SRC

La cuenta de trabajo seria:
#+BEGIN_SRC 
/usr/bin/telegram-desktop -workdir  ~/telegram-desktop/trabajo/ &
#+END_SRC


*** Snap 
Si utilizas snap
#+BEGIN_SRC 
/snap/bin/telegram-desktop -workdir ~/telegram-desktop/angel_bcn/ &
#+END_SRC

La cuenta de trabajo seria
#+BEGIN_SRC 
/snap/bin/telegram-desktop -workdir ~/telegram-desktop/trabajo/ &
#+END_SRC

*** Versión descargada de la wed de Telegram 
Si utilizas la versión descargable desde la página pagina de telegram, a mi me gusta descomprimir el archivo en una carpeta en la raíz de $HOME llamada telegram (=~/Telegram=). 

Lo ejecutaríamos así:

#+BEGIN_SRC 
/home/angel/Telegram/Telegram
#+END_SRC

Para Ejecutar mi cuenta personal:
#+BEGIN_SRC 
/home/angel/Telegram/Telegram -workdir ~/telegram-desktop/angel_bcn/ &
#+END_SRC


** Creando alias con screen

Vamos a crear un alias y vamos a utilizar screen con todo lo aprendido. Si no tienes instalado screen, recuerda hacerlo con =sudo apt install screen=.

#+BEGIN_SRC 
alias t='screen -dmS Telegram /home/angel/Telegram/Telegram -workdir ~/telegram-desktop/angel_bcn/'
#+END_SRC

Ahora cuando escribo *t* en mi terminal, abre telegram con mi cuenta personal.

Voy ha hacer que cuando escriba *trabajo*, abra la cuenta de mi trabajo:

#+BEGIN_SRC 
alias trabajo='screen -dmS Telegram /home/angel/Telegram/Telegram -workdir ~/telegram-desktop/trabajo/'
#+END_SRC

** Conclusión
Aquí tienes una guía de como crear multicuenta en Telegram. Ahora, como puedes imaginar, crea una carpeta de configuración por cada cuenta, de manera que tendrás cuentas ilimitadas de telegram.

* DONE Creando una página web de tu proyecto en GitHub
:PROPERTIES:
:TITLE: Creando una página web de tu proyecto en GitHub
:EXPORT_FILE_NAME: creando-una-pagina-web-de-tu-proyecto-en-github
:DESCRIPTION:
:EXPORT_DATE: 2020-04-15 17:00
:CATEGORY: github
:TAG: web
:IMAGE: ./images-blog/githubpages.png
:END:


Si tienes un repositorio en GitHub y quieres crear una web relacionada con este proyecto para mostrar toda la información, gracias a las GitHub Pages lo tienes super fácil.

Vamos a crear una web que mostrará todo el conenido de nuestro README.md, creando un nuevo archivo =_config.yml= que contendrá la configuración, tema, etc...
#+HTML: <center>
[[./images-blog/githubpages.png]]
#+HTML: </center>

La url de la página tendrá la dirección web =https://tu_usuario.github.io/nombre_repositorio=. 

Como comentaba, podríamos personalizar incluso el css de la página cambiando el tema de la misma, pero eso lo dejamos para otro artículo.

Vamos a ver como se crea esta página web

** Crear GitHub Page del proyecto

No vamos a *settings* y buscamos en el apartado *GitHub Pages*.

Seleccionamos la rama *master* y más abajo pulsamos *Choose a theme* para elegir el tema. En mi caso seleccionaré el tema *state*.

Esto creará un archivo en la raíz llamado *_config.yml* en la raíz del repositorio, donde incluye:
#+BEGIN_SRC 
theme: jekyll-theme-slate
#+END_SRC

** Archivo de Configuración _config.yml

Ahora en nuestro archivo de configuración, podemos añadir más información, como...
#+BEGIN_SRC 
theme: jekyll-theme-slate
title: Titulo
description: <br>Descripción<br><br> 
lang: es
google_analytics: UA-131585940-1 
#+END_SRC

** Crear la página

Para crear la web principal, tan sencillo como crear un archivo *index.md* en la raíz del directorio y GitHub lo convertirá el html por arte de magia, gracias a jekyll.

** Script

Siguiendo los pasos anteriores, vamos ha hacer un script para generar de forma automática la web.

#+BEGIN_SRC 
#!/bin/bash
#
#
#
#

cp README.md > index.md

echo "theme: jekyll-theme-slate
google_analytics: UA-131585940-1
lang: es" > _config.yml
#+END_SRC

** Fuentes

- https://github.com/pages-themes/slate


* DONE Servidor de Samba fácil
:PROPERTIES:
:TITLE: Servidor de Samba fácil
:EXPORT_FILE_NAME: servidor-de-samba-facil
:DESCRIPTION:
:EXPORT_DATE: 2020-04-02 15:24
:CATEGORY: servidor
:TAG: samba
:IMAGE: ./images-blog/samba.png
:END:

Vamos a compartir una carpeta por *Samba* de un modo muy sencillo, para que sea accesible desde cualquier máquina dentro de una misma red local.
#+HTML: <center>
[[./images-blog/samba.png]]
#+HTML: </center>

Para acceder a los datos de esta carpeta, no va a ser necesario utilizar usuario y contraseña, pero para darle un mínimo de seguridad, vamos a permitir el acceso a esta carpeta a determinados dispositivos en función de us IP.

El modo más correcto y seguro de compartir una carpeta por *Samba*, es crear un grupo donde ponemos un número de usuarios dentro de este y donde todos estos usuarios tienen usuario y contraseña.

He optado por esta configuración, porque es mucho más sencilla y he visto algo parecido en *Recalbox*. Una capeta que todos los usuarios de la red local tienen acceso y pueden depositar ahí sus archivos para compartir.

** Instalación

Instalación de Samba
#+BEGIN_SRC 
sudo apt install samba 
#+END_SRC

** Compartiendo Carpeta

Damos permisos para compartir la carpeta por *Samba* y que puede acceder cualquier usuario.
#+BEGIN_SRC 
sudo chmod -R 777 /home/angel/samba/
#+END_SRC

** Archivo de configuración

Editamos el archivo de configuración.
#+BEGIN_SRC 
sudo nano /etc/samba/smb.conf 
#+END_SRC

#+BEGIN_SRC 
[samba]                     # Nombre del servidor que veran los clientes
 
path=/home/angel/samba      # Ruta de la carpeta compartida
public=yes                  # Disponible para usuarios invitados u otros. Si ponemos no, solo los usuarios autorizados accederan                            
writable=yes                # Puede escribir y editar el contenido
guest ok = yes              
browseable = yes            # El directorio, puede ser visible    
read only = no              

create mask = 0777          # Permisos de escritura y lectura de cualquier cliente      
directory mask = 0777
force create mode = 777
force directory mode = 777
force security mode = 777
force directory security mode = 777
#+END_SRC

Desmarcamos el compartir impresoras
#+BEGIN_SRC 
#[print$]
#   comment = Printer Drivers
#   path = /var/lib/samba/printers
#   browseable = yes
#   read only = yes
#   guest ok = no
#+END_SRC

Verifica con *testparm* si hay un error en el archivo de configuración
#+BEGIN_SRC 
testparm
#+END_SRC

** Permitir de unas ip's en concreto

Para dar un poquito más de seguridad desde el servidor, solo vamos a permitir el acceso a determinadas ip's.
#+BEGIN_SRC 
hosts allow = 192.168.1.100, 192.168.1.101
#+END_SRC

** Solo lectura

El cliente solo tendrá acceso en modo lectura
#+BEGIN_SRC 
[samba] 

path = /home/angel/samba/ 
guest ok = yes 
browseable = yes 
read only = yes
#+END_SRC

** Reiniciar servicio

#+BEGIN_SRC 
sudo systemctl restart smbd
#+END_SRC

** Añadir en un archivo aparte

También existe la posibilidad, de utilizar una archivo a parte, sin tener que añadir todo en el archivo de configuración.

Para ello añadiremos al final del archivo de configuración de samba: =include = /etc/samba/mi_servidor.conf=

Creamos el archivo =/etc/samba/mi_servidor.conf= y añadimos nuestra configuración. Así tendremos el dotfile de nuestro servidor.

** Fuentes

- https://likegeeks.com/es/servidor-de-linux-samba/
- https://www.osmosislatina.com/linux/win_samba.htm
- https://www.linuxito.com/gnu-linux/nivel-basico/1233-instalar-y-configurar-un-servidor-samba-en-debian


* DONE Gonic. Servidor de Subsonic desarrollado en go
:PROPERTIES:
:TITLE: Gonic. Servidor de Subsonic desarrollado en go
:EXPORT_FILE_NAME: gonic-servidor-de-subsonic-desarrollado-en-go
:DESCRIPTION:
:EXPORT_DATE: 2020-04-02 16:00
:CATEGORY: subsonic
:TAG: musica
:IMAGE: ./images-blog/gonic.png
:END:


Gonic es la alternativa de servidor desarrollado en go para subsonic.
#+HTML: <center>
[[./images-blog/gonic.png]]
#+HTML: </center>

Las características de este servidor son:
- Navegación por carpeta (manteniendo intacto su árbol completo)
- navegación por etiquetas (usando taglib - soporta mp3, opus, flac, ape, m4a, wav, etc.)
- Transcodificación y almacenamiento en caché de audio sobre la marcha (requiere ffmpeg ) (gracias spijet )
- escaneo bastante rápido (El desarrollador con su biblioteca de ~ 27k pistas, el escaneo inicial duró unos 10 m y unos 5 s después de forma incremental)
- múltiples usuarios, cada uno con sus propias preferencias de transcodificación, listas de reproducción, pistas principales, artistas principales, etc.
- last.fm scrobbling
- similitudes de artistas y biografías de la api last.fm
- Una interfaz web para la configuración (configurar last.fm, administrar usuarios, iniciar escaneos, etc.)
- soporte para la etiqueta del artista del álbum , para no saturar su lista de artistas con apariencias de álbumes compilados
- escrito en go , tan ligero y adecuado para una frambuesa pi, etc.
- nueva autenticación de sal y token
- probado en dsub , jamstash , música sublime y ondas de sonido

El único defecto que he encontrado por el momento, es que el desarrollador no ha añadido la sincronización de las portadas, por lo demás, el servicio funciona perfecto.

** Montar el docker

#+BEGIN_SRC 
docker create  --name=gonic -p 88:80 -v $HOME/docker/media/musica:/music:ro ugeek/gonic:arm 
#+END_SRC

** Administración de Gonic
En el docker anterior, he tomado de ejemplo montar el servicio en el puerto 88. Para acceder a la página de administración, tendríamos que conectarnos a la ip de nuestro servidor puerto 88. http://ip:88
** Desde la Terminal

#+BEGIN_SRC 
docker exec  -it gonic sh  
#+END_SRC

#+BEGIN_SRC 
gonic -h
#+END_SRC

#+BEGIN_SRC 
Usage of gonic:
  -cache-path string
    	path to cache (default "/tmp/gonic_cache")
  -config-path string
    	path to config (optional)
  -db-path string
    	path to database (optional) (default "gonic.db")
  -listen-addr string
    	listen address (optional) (default "0.0.0.0:4747")
  -music-path string
    	path to music
  -proxy-prefix string
    	url path prefix to use if behind proxy. eg '/gonic' (optional)
  -scan-interval int
    	interval (in minutes) to automatically scan music (optional)
  -version
    	show gonic version

#+END_SRC

Con los comandos de terminal, podemos hacer que se hagan sincronizaciones de nuestra biblioteca añadiendo cada cuantos minutos queremos que se produzca.

Para más información, os recomiendo visitar el repositorio del proyecto.
** Fuente

- https://github.com/sentriz/gonic


* DONE El htop 2.0 desarrollado en bash. bashtop
:PROPERTIES:
:TITLE: El htop 2.0 desarrollado en bash. bashtop
:EXPORT_FILE_NAME: el-htop-2-0-desarrollado-en-bash-bashtop
:DESCRIPTION:
:EXPORT_DATE: 2020-04-07 14:20
:CATEGORY: bash
:TAG: zsh
:IMAGE: ./images-blog/bashtop.png
:END:


Bashtop es un proyecto con licencia Apache 2.0 desarrollado por [[https://github.com/aristocratos][aristocratos]], que nos permite acceder a toda la información de nuestra cpu, memoria, almacenamiento, red, procesos... de nuestro pc, servidor,... de un modo claro, desde mi punto de vista, de lo que lo haríamos con top o htop.
#+HTML: <center>
[[./images-blog/bashtop.png]]
#+HTML: </center>

Me ha gustado mucho porque puedo ver el consumo en ram, cpu,... en tiempo real y de un modo gráfico y claro de mis dockers.

También el uso es mucho más intuitivo, seleccionando los procesos mediante las *teclas arriba, abajo*. Para seleccionar el proceso deseado, pulsaremos *Enter* y se abrirá una pequeña sección donde muestra estadísticas detalladas para el proceso seleccionado.

Permite la posibilidad de filtrar procesos, pulsando la tecla *f* y escribiendo el nombre del proceso,  entre otras muchas más cosas.

#+HTML: <center>
[[./images-blog/bashtop1.png]]
#+HTML: </center>


Para su uso se recomienda bash v4.4 o posterior.

Vamos a ver como instalarlo y utilizarlo

** Instalación 
Clonamos el repositorio desde la raíz del HOME.
#+BEGIN_SRC 
cd ; git clone https://github.com/aristocratos/bashtop.git
#+END_SRC

Crear alias. Recuerda sustituir el usuario *angel* por el tuyo.

#+BEGIN_SRC 
alias bashtop='/home/angel/bashtop/bashtop'
#+END_SRC

Ahora, cada vez que escriba en la terminal =bashtop=, será lanzado.

** Configuración

La primera vez que ejecutemos *bashtop*, nos creará un archivo de configuración en la siguiente ruta: =$HOME/.config/bashtop/bashtop.cfg=.

En este archivo podremos configurar el tiempo de refresco en milisegundos, el orden de los procesos, habilitar la temperatura de la cpu,... y más cosas que podremos encontrar en la documentación del repositorio del desarrollador.

*** Configuración gráfica 

Podremos ver y editar de un modo gráfico está configuración, pulsando dentro de *bashtop* la tecla *ESC* y seleccionando *OPTIONS*.

** Ayuda 
Para conocer un poco más las opciones de esta aplicación, pulsaremos la tecla *h* para acceder a la ayuda.

** Fuentes
Las imágenes son del repositorio del desarrollador
- https://github.com/aristocratos/bashtop

Yo no se vosotros, pero yo [[https://github.com/Bash-Projects/bashtop][he forkeado este magnífico proyecto]].



#+HTML: <center>
[[./images-blog/bashhtop1.png]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/bashtop2.png]]
#+HTML: </center>

* DONE Instalar Ubuntu 20.04 en una Raspberry o Servidor ARM y Que hacer después de instalarlo
  :PROPERTIES:
  :ARCHIVE_TIME: 2020-04-26 dom 16:00
  :ARCHIVE_FILE: ~/docker/webdav/02_Org/tareas.org
  :ARCHIVE_OLPATH: Artículos
  :ARCHIVE_CATEGORY: tareas
  :END:

* DONE Instalar Ubuntu 20.04 en una Raspberry o Servidor ARM y Que hacer después de instalarlo
:PROPERTIES:
:TITLE: Instalar Ubuntu 20.04 en una Raspberry o Servidor ARM y Que hacer después de instalarlo
:EXPORT_FILE_NAME: instalar-ubuntu-20-04-en-una-raspberry-o-servidor-arm-y-que-hacer-despues-de-instalarlo
:DESCRIPTION:
:EXPORT_DATE: 2020-04-26 16:04
:CATEGORY: ubuntu
:TAG: raspberry,server
:IMAGE: ./images-blog/ubuntu.png
:END:


Ubuntu da un golpe de efecto y sorprende no solo para escritorio con su versión 20.04, sino que también con la versión ARM y para Raspberry.

Esta versión LTS nos da soporte hasta Abril del 2025 y no solo nos proporciona una versión de 32bits, sino que también la versión de 64bits. 
#+HTML: <center>
[[./images-blog/ubuntu.png]]
#+HTML: </center>

¿Porque deberíamos probar Ubuntu?. Aquí te daré muchos de los motivos, como por ejemplo tener una versión de 64bits para Raspberry, paquetes muchos más actualizados que Raspbian Buster, Wireguard de un modo estable,...

Pero no te adelanto más. Voy a explicar un poco mi experiencia instalando Ubuntu 20.04 Server en mi Raspberry 3.

Ah! La misma SD la he puesto en mi Raspberry 4 y reconoce sin problemas los 4Gb de RAM. Así que todo un Win para Ubuntu!!! Una alternativa muy real a Raspbian.

** Grabando la SD o USB

Podemos descargar la imagen de Ubuntu para Raspberry en https://ubuntu.com/download/raspberry-pi, pero yo la versión que he descargado, [[http://cdimage.ubuntu.com/ubuntu-server/daily-preinstalled/current/HEADER.html][es la versión de Ubuntu Server]].

Para grabar la imagen, vamos a utilizar [[https://www.balena.io/etcher/][Etcher]]. 

Podemos instalar el AppImage o el método que desees y grabarlo de un modo súper sencillo y sin tener que pensar mucho.
 
Si lo deseas, también puedes utilizar el comando dd como explicaba en el artículo [[https://ugeek.github.io/blog/post/2019-10-29-grabar-raspbian-ubuntu-debian-en-un-pendrive-o-sd.html][Grabar Raspbian, Ubuntu, Debian,… en un Pendrive o SD desde la Terminal]].
** Iniciamos Ubuntu
Yo he conectado mi raspberry a un monitor, cable de ethernet y teclado, a ver que sucede...

Conecto mi transformador USB. El inicio ha tardado un poquito, ya que es el primer arranque.

Se inicia ubuntu y me pide el usuario y contraseña. El usuario y contraseña por defecto son:
- usuario: *ubuntu*
- contraseña: *ubuntu*

Una vez iniciado, *ubuntu* nos pedirá el cambiar la contraseña. Primero pondremos la contraseña antigua, en este caso la que está por defecto *ubuntu* y escribiremos 2 veces nuestra nueva contraseña.

Ya podemos utilizar *ubuntu*!!!

Ahora podemos hacer un: 
#+BEGIN_SRC 
sudo apt update && sudo apt upgrade && sudo apt dist-upgrade
#+END_SRC

Así tendremos nuestro sistema operativo actualizado.

** Conocer mi ip
Voy a ver que ip ha asignado mi router a esta raspberry con ubuntu:
#+BEGIN_SRC 
ip a
#+END_SRC

** Conectarme por SSH
Al iniciarse la primera vez, ubuntu ha instalado ssh, de manera que ahora desde un pc remoto puedo conectarme a mi raspberry.

Conozco la ip gracias al paso anterior. Si mi ip fuera 192.168.1.100, me conectaría de la siguiente manera

#+BEGIN_SRC 
ssh ubuntu@192.168.1.100
#+END_SRC

*FUNCIONA!!!*

Cuando te conectas via ssh, te dice la memoria, espacio de tu sd, temperatura, swap,... La verdad es que está muy bien.
También te informa si hay un paquete pendiente para actualizar. Para que nos muestre que paquetes son:
#+BEGIN_SRC 
apt list --upgradable
#+END_SRC

** Crear contraseña al usuario root y cambiamos el nombre de usuario
Es probable que también quieras cambiar el nombre de usuario y eliminar el de *ubuntu* por defecto.

Para hacer esto, vamos tener que entrar como root.

#+BEGIN_SRC 
sudo passwd root
#+END_SRC

Nos pedirá que introduzcamos 2 veces la contraseña.

Iniciamos como root
#+BEGIN_SRC 
su root
#+END_SRC

Ahora sigue los pasos para cambiar el usuario *ubuntu* por el usuario que tu desees [[https://ugeek.github.io/blog/post/2019-02-01-cambiar--mover-ruta-y-contrasena-de-usuario-en-tu-raspberry-pi.html][siguiendo el tutorial que os dejé]].

** Snap

Se supone que trae snap por defecto instalado, veamos...
#+BEGIN_SRC 
sudo snap --version
#+END_SRC

*FUNCIONA!!!*

Esto quiere decir que de un modo rápido y sencillo, podríamos  instalar servicios como Nextcloud, RocketChat,...

*** Nextcloud
#+BEGIN_SRC 
sudo snap install nextcloud
#+END_SRC

*** RocketChat

#+BEGIN_SRC 
sudo snap install rocketchat-server
#+END_SRC

*** Plex
#+BEGIN_SRC 
sudo snap install plexmediaserver
#+END_SRC

*** Subsonic
#+BEGIN_SRC 
sudo snap install subsonic-arubislander
#+END_SRC

*** OpenHub 
#+BEGIN_SRC 
sudo snap install openhab
#+END_SRC

*** Homebridge
#+BEGIN_SRC 
sudo snap install homebridge
#+END_SRC

*** OpenVPN
#+BEGIN_SRC 
sudo snap install easy-openvpn-server --candidate
#+END_SRC

*** Servidor de Minecraft  
#+BEGIN_SRC 
sudo snap install mc-server-installer
#+END_SRC



Snap viene instalado por defecto. Aún así si odias *snap* y no lo quieres, puedes desinstalarlo.

#+BEGIN_SRC 
sudo apt purge snapd
#+END_SRC

Simplemente Brutal!!!
** Instalar Docker
Vamos a instalar docker
*** Instalación
Lo instalaremos desde los repositorios de Ubuntu. Súper fácil.
#+BEGIN_SRC 
sudo apt install docker.io
#+END_SRC

*** Iniciar docker al iniciar el sistema 
Creamos el servicio para que inicie docker al iniciar el sistema
#+BEGIN_SRC 
sudo systemctl enable --now docker
#+END_SRC

*** Darle privilegios de administración de docker a un usuario 
En mi caso, mi usuario *angel*. Pon tu el tuyo.

#+BEGIN_SRC 
sudo usermod -aG docker angel
#+END_SRC

*** Ver si todo esta ok 
Vamos a ver que versión de docker hay instalada y si se ha instalado
#+BEGIN_SRC 
docker --version
#+END_SRC

** Instalando Wireguard
Se acabó wireguard en testing. Ubuntu 20.04 trae el kernel de Linux 5.4 y aunque no está disponible por defecto en este kernel de Linux, Ubuntu lo ha añadido para esta LTS y está disponible en sus repositorios.

#+BEGIN_SRC 
sudo apt install wireguard
#+END_SRC

*FUNCIONA!!!* Ahora si es facil tener Wireguard en una Raspberry.

Para configurarlo, [[https://ugeek.github.io/blog/post/2020-02-11-wireguard-en-2-minutos-con-wgc.html][te recomiendo el script que hice para crear la configuración del servidor y clientes]].


** Instalar escritorio
Si lo que deseas es tener un escritorio en tu ubuntu
#+BEGIN_SRC 
sudo apt update && sudo apt install ubuntu-desktop
#+END_SRC

Ten en cuenta las limitaciones de tu Raspberry, [[https://ubuntu.com/download/desktop][consulta la web oficial]].

** Temperatura Raspberry con Ubuntu
Ubuntu puede mostrar a que temperatura está nuestra Raspberry, pero es diferente a Raspbian.

Para conocer la temperatura:
#+BEGIN_SRC 
cat /sys/class/thermal/thermal_zone0/temp
#+END_SRC

Se me ha ocurrido este comando que puedes añadirte a un alias, para que sea más clara la medición
#+BEGIN_SRC 
echo "$(cat /sys/class/thermal/thermal_zone0/temp | cut -c 1,2),$(cat /sys/class/thermal/thermal_zone0/temp | cut -c 3,4)º"
#+END_SRC

** Conclusión
Ubuntu por primera vez, nos proporciona un Sistema Operativo 100% usable como alternativa real a Raspbian. Es una versión que por su sencillez y paquetes totalmente a la última, me ha encantado. Voy a testearlo más en profundidad y te recomiendo que tu también lo hagas.


#+HTML: <center>
[[./images-blog/ubuntu.png]]
#+HTML: </center>


* DONE Gonic. El mejor y más ligero servidor de música con api Subsonic
:PROPERTIES:
:TITLE: Gonic. El mejor y más ligero servidor de música con api Subsonic
:EXPORT_FILE_NAME: gonic-el-mejor-y-mas-ligero-servidor-de-musica-con-api-subsonic
:DESCRIPTION:
:EXPORT_DATE: 2020-05-06 17:53
:CATEGORY: subsonic
:TAG: música,raspberry
:IMAGE: ./images-blog/gonic.png
:END:

El desarrollador [[https://github.com/sentriz][Senan Kelly]], ha creado Gonic, un servidor ultra rápido y ligero (En mi Raspberry Pi consume solo 17-19 Mb de ram) que mejora todavía más la experiencia en dispositivos como una Raspberry Pi.
#+HTML: <center>
[[./images-blog/gonic.png]]
#+HTML: </center>


Las características de este servidor son:
- Navegación por carpeta (manteniendo intacto su árbol completo)
- navegación por etiquetas (usando taglib - soporta mp3, opus, flac, ape, m4a, wav, etc.)
- Transcodificación y almacenamiento en caché de audio sobre la marcha (requiere ffmpeg ) (gracias spijet )
- escaneo bastante rápido (El desarrollador con su biblioteca de ~ 27k pistas, el escaneo inicial duró unos 10 m y unos 5 s después de forma incremental)
- múltiples usuarios, cada uno con sus propias preferencias de transcodificación, listas de reproducción, pistas principales, artistas principales, etc.
- last.fm scrobbling
- similitudes de artistas y biografías de la api last.fm
- Una interfaz web para la configuración (configurar last.fm, administrar usuarios, iniciar escaneos, etc.)
- soporte para la etiqueta del artista del álbum , para no saturar su lista de artistas con apariencias de álbumes compilados
- escrito en go , tan ligero y adecuado para una frambuesa pi, etc.
- nueva autenticación de sal y token
- probado en dsub , jamstash , música sublime y ondas de sonido

Que no tiene:
Tenemos que tener en cuenta un pequeño detalle, para que aparezcan las portadas de nuestras discos en los clientes, tenemos que dejar en la carpeta donde tenemos los archivos mp3, flac,... un archivo *jpg* o *png* con el nombre *folder*. Ejemplo. *folder.jpg*. Gonic entenderá que es una portada y la enviará al cliente para que sea visualizada.

De momento no integra el poder poner una estrella o puntuación a una canción.

Por lo demás, es un servidor alucinante y que sincroniza a la perfección y de un modo muy rápido.

** docker para Raspberry Pi, ARM 

#+BEGIN_SRC 
docker create  \
  --name=gonic \
  -p 88:80 \
  -v $HOME/media/musica:/music:ro \
  -v $HOME/docker/gonic/data:/data \
  -v -v $HOME/docker/gonic/cache:/cache  \
ugeek/gonic:arm-0.8.8
#+END_SRC

- /data -> base de datos de gonic, etc...
- /music -> tu música
- /cache -> trasncodificación

** docker oficial para amd64

#+BEGIN_SRC 
docker create  \
  --name=gonic \
  -p 88:80 \
  -v $HOME/media/musica:/music:ro \
  -v $HOME/docker/gonic/data:/data \
  -v -v $HOME/docker/gonic/cache:/cache  \
sentriz/gonic:latest
#+END_SRC

** Administración de Gonic

En el montaje del docker, del paso anterior, he tomado de ejemplo el puerto 88. Para acceder a la página de administración, tendríamos que conectarnos a la ip de nuestro servidor puerto 88. http://ip:88

** Desde la Terminal

#+BEGIN_SRC 
docker exec  -it gonic sh  
#+END_SRC

#+BEGIN_SRC 
gonic -h
#+END_SRC

#+BEGIN_SRC 
Usage of gonic:
  -cache-path string
    	path to cache (default "/tmp/gonic_cache")
  -config-path string
    	path to config (optional)
  -db-path string
    	path to database (optional) (default "gonic.db")
  -listen-addr string
    	listen address (optional) (default "0.0.0.0:4747")
  -music-path string
    	path to music
  -proxy-prefix string
    	url path prefix to use if behind proxy. eg '/gonic' (optional)
  -scan-interval int
    	interval (in minutes) to automatically scan music (optional)
  -version
    	show gonic version

#+END_SRC

Con los comandos de terminal, podemos hacer que se hagan sincronizaciones de nuestra biblioteca añadiendo cada cuantos minutos queremos que se produzca.

Para más información, os recomiendo visitar el repositorio del proyecto.

** Crear listas en m3u8
*** Que es una lista m3u8

Los archivos M3U8 son listas de reproducción como los m3u, con la diferencia que los archivos m3u8 utilizan el estándar de codificación de caracteres UTF-8. Esto significa que las listas pueden contener nombres escritos en distintos idiomas y caracteres.

El archivo de texto sin formato contiene información sobre la ubicación de las canciones en la lista de reproducción.

Un ejemplo de archivo m3u8 sería:

#+BEGIN_SRC 
/music/The Rolling Stones/The Rolling Stones - (I Can't Get No) Satisfaction.mp3
/music/The Rolling Stones/The Rolling Stones - Sympathy for the Devil.mp3
/music/./track
#+END_SRC

*** Listar toda tu música
Para listar toda la música que tenemos, nos situariamos en la raíz del docker y ejecutaríamos el comando find:

#+BEGIN_SRC 
find /music/ > all_music.list
#+END_SRC

*** Crear Listas

Entramos dentro del contenedor

#+BEGIN_SRC 
docker exec  -it gonic sh
#+END_SRC

Ahora corremos *find* para listar todas las canciones de un directorio. En este ejemplo voy listar todas las canciones *mp3* del directorio The Rolling Stones.

#+BEGIN_SRC 
find /music/"The Rolling Stones" | grep mp3 
#+END_SRC

Voy a crear mi lista en formato *m3u8* de las canciones en formato *flac* de este directorio
#+BEGIN_SRC 
find /music/"The Rolling Stones" | grep flac > lista.m3u8
#+END_SRC

** Conclusión

La ligereza de Gonic, consumo de bajos recursos y la creación de listados, hace que esta aplicación sea ideal para cualquier servidor, pero sobretodo, para servidores como una Raspberry Pi.

** Fuente
- https://github.com/sentriz/gonic
#+HTML: <center>
[[./images-blog/qutebrowser.svg]]
#+HTML: </center>
* DONE Servidor de ebooks en Ubuntu, Debian, Raspbian,... con Calibre
:PROPERTIES:
:TITLE: Servidor de ebooks en Raspberry con Calibre
:EXPORT_FILE_NAME: servidor-de-ebooks-con-calibre
:DESCRIPTION:
:EXPORT_DATE: 2020-05-07 18:59
:CATEGORY: libros
:TAG: raspberry,servidor
:IMAGE: ./images-blog/calibre.png
:END:

Tener un servidor de ebooks en nuestro servidor, Raspberry,... es súper fácil. Además, teniendo en cuenta que calibre consume muchos recursos, esta versión la verdad es que está bastante bien optimizada, consumiendo pocos recursos.

Va a crear una página web simple, que permite búsqueda por autor, título, formato, etc... Una buena base de datos de nuestra biblioteca.

#+HTML: <center>
[[./images-blog/calibre.png]]
#+HTML: </center>

El objetivo va a ser crear una carpeta donde pondremos todos los libros sin ordenar, ejecutaremos un comando para crear la base de datos de calibre y además, calibre parará todos los libros a la segunda carpeta, donde los guardará por autor, libro,...

** Instalación
Muy sencillo, desde los repositorios
#+BEGIN_SRC 
sudo apt install calibre xvfb
#+END_SRC

** Creando carpetas
Crearemos un directorio llamado *Libros* y *add*.

#+BEGIN_SRC 
mkdir -p /home/pi/add/ ; mkdir -p /home/pi/Libros/
#+END_SRC

** Iniciando
Vamos a crear la base de datos e importar los libros de la carpeta *add* a *Libros*.

Dejaremos todos los libros que queramos añadir a nuestra biblioteca en la carpeta *add* y ejecutaremos este comando.

Sustituye el usuario pi por tu usuario y cambia la ruta de tus libros si así lo deseas.

#+BEGIN_SRC 
xvfb-run calibredb add /home/pi/add/* --library-path /home/pi/Libros/
#+END_SRC

** Corriendo el servidor web
Para ver Calibre en su versión web, ejecutaremos el servidor, en este ejemplo por el puerto 8080.

#+BEGIN_SRC 
calibre-server "/home/pi/Libros/" --port 8080
#+END_SRC

Para conectarnos: http://tu_ip:8080

Para detener el servidor, hazlo con Ctrl-c o cerrando la terminal.

** Crea el servicio con Systemd
Para que el servicio siempre esté corriendo y se inicie al iniciar el sistema operativo, vamos a crear el servicio.

#+BEGIN_SRC 
sudo nano /etc/systemd/system/calibre-server.service
#+END_SRC

Añadimos:

#+BEGIN_SRC 
[Unit]
Description=Calibre Content Server
After=network.target

[Service]
Type=simple
User=pi
Group=pi
ExecStart=/usr/bin/calibre-server "/home/pi/Libros/" --port 8080
 
[Install]
WantedBy=default.target
#+END_SRC

*Recuerda cambiar *pi* por tu usuario

Inicia el servicio con:

#+BEGIN_SRC 
sudo systemctl start calibre-server.service
#+END_SRC


Si quieres iniciarlo al iniciar tu Raspberry o Servidor

#+BEGIN_SRC 
sudo systemctl enable calibre-server.service
#+END_SRC


Para detenerlo

#+BEGIN_SRC 
sudo systemctl stop calibre-server.service
#+END_SRC



* DONE ZRAM. Ampliando la RAM y no utilizando - quemando la SD de mi Raspberry
:PROPERTIES:
:TITLE: ZRAM. Ampliando la RAM y no utilizando - quemando la SD de mi Raspberry
:EXPORT_FILE_NAME: zram-ampliando-la-ram-y-no-utilizando--quemando-la-sd-de-mi-raspberry
:DESCRIPTION:
:EXPORT_DATE: 2020-05-09 18:27
:CATEGORY: raspberry
:TAG: ram
:IMAGE: ./images-blog/ram.png
:END:

Este método no solo sirve para la Raspberry, pero es ideal para ella, ya que en el caso de mi Raspberry 3, solo tiene 1Gb de RAM y para la nueva versión de Ubuntu, sumado a todo lo que quiero correr en ella, se queda un poco corta.

Además, el punto fuerte es no tener que quemar mi SD a base de lecturas y escrituras con la memoria Swap.

#+HTML: <center>
[[./images-blog/ram.png]]
#+HTML: </center>

Desde la versión 3.14, ZRAM viene incluida en el kernel de Linux. ZRAM comprime los datos de la Swap y los almacena en la RAM, no utilizando la tarjeta SD de la Raspberry o Disco Duro de un PC, ganando más velocidad.

Por contra, haremos trabajar más a la CPU comprimiendo los datos.

Vamos a utilizar el script de [[https://github.com/novaspirit/rpi_zram][Novaspirit]] disponible en GitHub, para hacerlo de un modo rápido y seguro.

** Descargamos el Scrirpt 
#+BEGIN_SRC 
sudo wget -O /usr/bin/zram.sh https://raw.githubusercontent.com/Bash-Projects/rpi_zram/master/zram.sh
#+END_SRC

Damos permisos de ejecución
#+BEGIN_SRC 
sudo chmod +x /usr/bin/zram.sh
#+END_SRC

Creamos un script para iniciar zram. Recuerda que el usuario que estoy utilizando es *angel*, sustitúyelo por el tuyo.
#+BEGIN_SRC 
echo -e "#\!/bin/bash\n/usr/bin/zram.sh &" > /home/angel/scripts/zram.sh
#+END_SRC


** Montamos zram con cron
Sustituye nuevamente *angel* por tu usuario.

#+BEGIN_SRC 
@reboot ( sleep 50 ; sudo /home/angel/scripts/zram.sh )
#+END_SRC
Tras 50 segundos tras el inicio, se ejecutará el script de zram.sh.


Reinicia
#+BEGIN_SRC 
sudo reboot now
#+END_SRC

** Comprobando la memoria
Vamos a ver si ya se nos ha ampliado la memoria y estamos utilizando zram.

#+BEGIN_SRC 
free -h
#+END_SRC

Como podemos comprobar, hemos doblado el tamaño de RAM. Ahora la Swap, tiene el mismo tamaño que la memoria RAM.

#+BEGIN_SRC 
swapon -s
#+END_SRC

Mediante este comando, podemos ver como consta de cuatro bloques iguales (en el caso de la Raspberry 3), uno por cada núcleo de la CPU.

Un modo más gráfico es utilizar
#+BEGIN_SRC 
htop
#+END_SRC

** Fuentes
- https://github.com/Bash-Projects/rpi_zram/blob/master/README.md
- https://acastillog.es/20180316.php

#+HTML: <center>
[[./images-blog/ram.png]]
#+HTML: </center>

* topydo
  :PROPERTIES:
  :ARCHIVE_TIME: 2020-05-22 vie 18:44
  :ARCHIVE_FILE: ~/docker/webdav/02_Org/tareas.org
  :ARCHIVE_OLPATH: Artículos
  :ARCHIVE_CATEGORY: tareas
  :END:
Si te gusta el todo.txt y utilizas la terminal, topydo es tu aplicación. Topydo, como su nombre indica, es una aplicación desarrollada en python que mejora la experiencia de las gestión de tus tareas con todo.txt en la terminal, respecto al script original *todotxt-cli* de Gina Trapani.

La sintaxis es muy parecida y en algunos casos esta como el uso, es más simple. Una de las mejoras, es la visualización de los listados de proyectos, contextos, prioridades,...  son más visibles, ya cada uno se muestra de colores diferentes.

Lo más espectacular, son dos modos que podemos utilizar de topydo. 

Prompt, te permite gestionar tus tareas, estando dentro de la aplicación, sin necesidad de estar todo el rato introduciendo el comando =topydo=.

=Column=, es otro modo que permite mostrarnos todas nuestra tareas en columnas, fusionando si lo deseas, el método kanban o manteniendo un contexto, proyecto, prioridades,.... separado en columnas.

La verdad es que he profundizado muchísimo con esta aplicación y voy a explicaros un poco de los tres modos. Si buscas algo en concreto, he clonado el Tiki Wiki de su documentación, ya que no tiene una página actualmente con esta.

He crearé en breve una nueva sección dentro del Blog de uGeek para cosas como estas. Documentaciones, atajos de teclado,... 


** Instalación de topydo 
Si tienes instalado python3 y el sistema de gestión de paquetes de python, es tan simple como:
#+BEGIN_SRC 
sudo pip3 install topydo
#+END_SRC

** Indicando la ruta del archivo todo.txt y done.txt
Si no queremos acceder al directorio, también podemos acceder al archivo todo.txt o done.txt, especificando la ruta de este.
#+BEGIN_SRC 
topydo -t ~/todo/todo.txt -d ~/todo/done.txt
#+END_SRC

Si utilizamos la versión prompt, podríamos lanzarlo con:
#+BEGIN_SRC 
topydo -t ~/todo/todo.txt prompt
#+END_SRC

** Configuración

Podemos configurar topydo con uno o más archivos de configuración de estilo ini. topydo busca los siguientes archivos de configuración en este orden:
 
#+BEGIN_SRC 
/etc/topydo.conf
$HOME/.config/topydo/config
$HOME/.topydo
.topydo (en el directorio de trabajo actual)
topydo.conf (en el directorio de trabajo actual)
topydo.ini (en el directorio de trabajo actual) (para soporte mejorado en Windows)
#+END_SRC

Para especificar un archivo de configuración alternativo, utilizaremos la opción -c.

Los valores en archivos de configuración posteriores, anulan los valores anteriores.

*** Alias

Mediante el archivo de configuración, podremos crear nuestros propios alias para invocar a topydo con comandos personalizados. Esta funcionalidad es similar a los alias en un shell de Unix (bash, zsh, etc.).

Vamos a crear el archivo de configuración =$HOME/.config/topydo/config= y añadir unos alias de ejemplo:

#+BEGIN_SRC 
[aliases]
# Muestra la primera linea de la lista
next = ls -n 1

# Muestra mi lista de trabajo, con la opción lst
lst = ls @trabajo

# abreviando comando. Pulsando l, en lugar de ls o x para salir
e = edit {}
l = ls {}
x = exit

# Poner una estrella a una tarea. Opción no standar de todo.txt
star = tag {} star 1
unstar = tag {} star
#+END_SRC

Ahora para listar mis tareas, podría hacerlo con este comnado
#+BEGIN_SRC 
topydo l
#+END_SRC


*** Crea el alias en tu sistema operativo
Recuerda que para no tener que estar utilizando todo el rato el comando *topydo*, podemos crea un alias para sustituirlo, por ejemplo, por la letra *t*.

Así, tal como explicaba antes, listar nuestras tareas sería tan simple como:
#+BEGIN_SRC 
t l
#+END_SRC

** topydo. Uso Básico
Es mucho más simple que todotxt-cli ya que necesitamos crear previamente un archivo de configuración. 

Simplemente entramos en el directorio donde está el archivo todo.txt y ejecutando el comando =topydo=, ya podemos gestionar nuestra lista de tareas de nuestro archivo todo.txt.

Vamos a ver un poco como funciona esta aplicación
*** Añadir tarea 
#+BEGIN_SRC 
topydo add "grabar podcast de topydo +podcast"
#+END_SRC

Para que sea más simple y rápido, a diferencia de todotxt-cli, no es obligatorio utilizar comillas
#+BEGIN_SRC 
topydo add grabar podcast de topydo +podcast
#+END_SRC

*** Listar tareas

#+BEGIN_SRC 
todopy ls
#+END_SRC

*** Filtrar
Tan sencillo como escribir el comando seguido de la palabra a filtrar:
#+BEGIN_SRC 
topydo palabra
#+END_SRC

** Modo prompt

El modo de solicitud es bastante similar a la interfaz de línea de comandos, excepto que los subcomandos se reconocen inmediatamente (no es necesario escribir *topydo* cada vez) y hay una finalización automática.

Los cambios en su lista de tareas pendientes se guardan inmediatamente después de cada comando.

Este modo es adecuado si invocamos la CLI de topydo con bastante frecuencia.
** Instalación modo prompt

El modo de prompt requiere una dependencia adicional prompt_toolkitque así que vamos a instalarla primero.

#+BEGIN_SRC 
sudo pip3 install "topydo[prompt]"
#+END_SRC

** Uso modo prompt

Iniciamos con:
#+BEGIN_SRC 
topydo prompt
topydo>
#+END_SRC

Ahora puedes introducir comandos de inmediato, sin comenzar con topydo.

*** Salir del modo prompt
Para salir, escribe el comando *exit*.
*** Listar
**** Listar todas las tareas

#+BEGIN_SRC 
ls
#+END_SRC

**** Listar Proyectos

Escribiendo ls + TAB, nos mostrará todas las opciones de ls.

#+BEGIN_SRC 
lsproj

lspr
#+END_SRC

**** Listar contextos

#+BEGIN_SRC 
lscon
#+END_SRC

*** Filtrar
Simplemente escribimos la palabra, pulsamos *enter* y ya nos muestra los resultados

*** Limpiar terminal
Igual que hacemos habitualmente en nuestra terminal, utilizaremos el atajo *Ctrl+l*.

*** Añadir una tarea

Escribimos add seguido de la tarea
#+BEGIN_SRC 
add tarea
#+END_SRC

*** Autocompletar

Los siguientes elementos se autocompletan automáticamente al presionar *Tab*:

- Comandos, Subcomandos y alias
- Proyectos (presione Tab después +)
- Contextos (presione Tab después @)
- Fechas (presione Tab después de due:o t:, o las etiquetas correspondientes que se configuraron )

*Con las flechas arriba y abajo, podemos seleccionar el histórico de comandos previamente introducidos*.

Con *TAB* autocompleta lo que estamos escribiendo. 
Ejemplo.
#+BEGIN_SRC 
add tarea @c
#+END_SRC

Si pulsamos ahora *TAB*, en mi caso autoescribirá el contexto *@casa*

El proceso para crear una tarea utilizando el autocompletado, sería:
1) add
2) Escribimos de un modo natural la tarea
3) @ y pulsamos TAB o + y pulsamos TAB

#+BEGIN_SRC 
add @podcast hablar en el podcast de topydo
#+END_SRC

*** Añadir una prioridad a una tarea

#+BEGIN_SRC 
pri 56 A
#+END_SRC
Añadir prioridad *A* a la tarea 56.

También podemos utilizar *a* minúscula, no es obligatorio escribir *A*.

*** Añadir fecha
Escribe *due:* y pulsa *TAB*. Te mostrará unas fechas por defecto.

Con *append*, podemos agregar al final lo que queramos

*** Posponer fecha

#+BEGIN_SRC 
postpone 16 1d
#+END_SRC
Posponer un dia la tarea 16

- w -> semana
- m -> mes
- y -> año

*** Editar
Si escribimos *edit*, nos abrirá todo el archivo todo.txt para editarlo.
Si escribimos *edit 20*, editaremos solo la tarea 20.

*** Borrar una tarea
Para borrar una tarea, es tan simple como:
#+BEGIN_SRC 
del 45
#+END_SRC

Borrando la tarea 45

*** Revertir cambios
Es posible que hayas guardado una tarea y te hayas equevocado, puedes reviertir con el comando revert
#+BEGIN_SRC 
revert
#+END_SRC

Te preguntaras, ¿como hace esto?. Topydo guarda un bakup de tu todo.txt en el mismo directorio que tienes el archivo llamado *.todo.bak*.

*** Poner estrellas
Esto es algo que no está en la sintaxis oficial de todo.txt.

Podemos añadir un número de estrellas según la importancia.

La sintaxis sería:

#+BEGIN_SRC 
(C) 2020-04-27 A starred item star:1
#+END_SRC

Alias
#+BEGIN_SRC 
# starring and unstarring
# `star 42` substitutes to `tag 42 star 1`
star = tag {} star 1
unstar = tag {} star
#+END_SRC

Para visualizar, escribimos =s + TAB= , start 1.
start 2

**** Añadiendo estrellas

A la tarea 42, le pongo una estralla 
#+BEGIN_SRC 
 star 42 1
#+END_SRC
*** Añadir con appen
Para añadir un texto a una tarea, utilizaremos appen:
#+BEGIN_SRC 
appen 47 texto a añadir
#+END_SRC
*** Tarea realizada

Pulsaremos =do numero_tarea=. Automáticamente irá al archivo *done.txt*.

Para finalizar varias tareas =do tarea1 tarea2 ...=.

*** Resumen de Comandos disponibles

Escribiendo *help*, nos mostrará la ayuda con todos los comandos disponibles.

#+BEGIN_SRC 
 add
 append (app)
 del (rm)
 dep
 depri
 do
 edit
 ls
 listcon (lscon)
 listprojects (lsprj)
 postpone
 pri
 revert
 sort
 tag

Run `topydo help <subcommand>` for command-specific help.

#+END_SRC
** Columnas
*** Instalación con columnas
#+BEGIN_SRC 
sudo pip3 install 'topydo[columns]'
#+END_SRC
*** Iniciar
Situandonos en el directorio donde tenemos nuestro archivo todo.txt.
#+BEGIN_SRC 
topydo columns
#+END_SRC
Si no es así, tendremos que especificar la ruta, tal como explicaba al principio del artículo.

*** Uso 
Para introducir un comando, utilizaremos *:*, como en vim.
Con *:help*, tendremos la ayuda.

- Ayuda -> :help
- Salir -> :quit o :exit

*** Acciones de Columnas. Añadir, borrar,... Columnas

Para añadir una nueva columna , pulsa la tecla *A*.

| Llave	  | Acción	        | Descripción                                               |
|----------+-----------------+-----------------------------------------------------------|
| A	      | append_column	 | Agregar / agregar columna (a la derecha)                  |
| I	      | insert_column	 | Insertar nueva columna antes de la columna actual         |
| E	      | edit_column	   | Editar la definición de columna actual                    |
| D	      | delete_column	 | Eliminar la columna actual                                |
| Y	      | copy_column	   | Copie ( y ank) la columna actual                          |
| L	      | swap_left	     | Cambiar la columna actual con la columna vecina izquierda |
| R	      | swap_right	    | Cambiar la columna actual con la columna vecina derecha   |
| Ctrl-a	 | mark_all	      | Marca todos los elementos en la columna actual            |

*** Navegación

| Llave	   | Acción	       | Descripción                                                        |
|-----------+----------------+--------------------------------------------------------------------|
| j o ↓	   | up	           | Mueve un elemento hacia abajo                                      |
| k o ↑	   | down	         | Mueve un elemento hacia arriba                                     |
| l o →	   | next_column	  | Ir a la siguiente columna                                          |
| h o ←	   | prev_column	  | Ir a la columna anterior                                           |
| gg o Home | 	home	       | Mover hacia arriba                                                 |
| G o End	 | end	          | Mover al fondo                                                     |
| 0	       | first_column	 | Moverse a la primera columna                                       |
| $	       | last_column	  | Moverse a la última columna                                        |
| :		     |                | Enfoca la línea de comandos para ejecutar comandos personalizados. |

*** Acciones de elementos de todo

| Llave	         | Acción        | 	   Descripción                                                                      |
|-----------------+---------------+---------------------------------------------------------------------------------------|
| d	             | cmd del {}	  | Se ejecuta delen elementos resaltados                                                 |
| e	             | cmd edit {}	 | Se ejecuta editen elementos resaltados                                                |
| m	             | mark	        | Marcar elemento actual (para realizar acciones en varios elementos simultáneamente)   |
| pp< período >	 | postpone	    | Se ejecuta postponeen los elementos resaltados con el período dado .                  |
| pr< prioridad > | pri	         | Se ejecuta prien los elementos resaltados con la prioridad dada.                      |
| ps< período >	 | postpone_s	  | Se ejecuta postponeen modo estricto en los elementos resaltados con el período dado . |
| u	             | cmd revert	  | Ejecuta revert                                                                        |
| x	             | cmd do {}	   | Se ejecuta doen elementos resaltados                                                  |

*** Configuración Columnas

Vamos a crear el archivo de configuración para poder ver diferentes columnas preestablecidas por mi.

#+BEGIN_SRC 
nano $HOME/.config/topydo/config
#+END_SRC

Añadimos, por ejemplo

#+BEGIN_SRC 
[Current]
title = Current
sortexpr = desc:importance
groupexpr = project
show_all = 0

[Overdue]
title = Overdue
filterexpr = due:<today
sortexpr = desc:due
show_all = 1

[Starred]
title = Starred
filterexpr = star:1
show_all = 1
#+END_SRC

Iniciaremos con mi configuración, ejecutando el siguiente comando
#+BEGIN_SRC 
topydo columns -l $HOME/.config/topydo/config
#+END_SRC

*** Otros atajos de línea de comando

La línea de comandos, activada al presionar *:*, admite las siguientes teclas:

- Ctrl-a	-> Ir al principio
- Ctrl-e	-> Muévete hasta el final
- Ctrl-u	-> Eliminar del cursor al principio
- Ctrl-k	-> Eliminar desde el cursor hasta el final

** Android
Gracias a Termux, también podremos utilizar topydo en Android.

Voy a explicar un poco el proceso

1) Instalaremos Termux desde Google Play o F-Droid
2) Instalamos Python3 =apt-get install python=
3) Instalamos topydo =pip3 install topydo=
4) Crearemos unos alias para que nos se más sencillo:

#+BEGIN_SRC 
vi $HOME/.bashrc
#+END_SRC

Añadiremos el siguiente contenido
#+BEGIN_SRC 
alias topydo=$HOME/.local/bin/topydo
alias do="topydo do"
alias add="topydo add"

# -N and %S make sure that the list fits on the screen properly
alias t="topydo ls -N -F '%I %S' "
#+END_SRC

Asegurate tener source =$HOME/.bashrc= en tu =$HOME/.bash_profile=.


** Fuentes

- https://c306.net/t/topydo-docs/
- https://ugeek.github.io/blog/varios/topydo.html
- http://bropages.org/topydo

* DONE Gestionando mis tareas en la terminal con topydo
CLOSED: [2020-05-22 vie 18:50]
:PROPERTIES:
:TITLE: Gestionando mis tareas en la terminal con topydo
:EXPORT_FILE_NAME: gestionando-mis-tareas-en-la-terminal-con-topydo
:DESCRIPTION:
:EXPORT_DATE: 2020-05-22 18:50
:CATEGORY: todo.txt
:TAG: tareas,terminal
:IMAGE: ./images-blog/topydo.png
:END:



Si te gusta el todo.txt y utilizas la terminal, topydo es tu aplicación. Topydo, como su nombre indica, es una aplicación desarrollada en python que mejora la experiencia de gestión de tus tareas en todo.txt, respecto al script original *todotxt-cli* de Gina Trapani.

La sintaxis es muy parecida y en algunos casos, más simple. Una de las mejoras, es la visualización de los listados de proyectos, contextos, prioridades,...  son más visibles, ya cada uno se muestra de colores diferentes.

Lo más espectacular, son dos modos que podemos utilizar de topydo. 

Prompt, te permite gestionar tus tareas, estando dentro de la aplicación, sin necesidad de estar todo el rato introduciendo el comando =topydo=.
#+HTML: <center>
[[./images-blog/topydo.png]]
#+HTML: </center>

=Column=, es otro modo que permite mostrarnos todas nuestra tareas en columnas, fusionando si lo deseas, el todo.txt al método kanban o mostrando en estas columnas contextos, proyectos, prioridades,....

La verdad es que he profundizado muchísimo con esta aplicación y voy a explicaros un poco de los tres modos. Si buscas algo en concreto, he clonado el Tiki Wiki de su documentación, ya que no tiene una página actualmente con esta.

He crearé en breve una nueva sección dentro del Blog de uGeek para cosas como estas. Documentaciones, atajos de teclado,... 


** Instalación de topydo 
Si tienes instalado python3 y pip3, el sistema de gestión de paquetes de python, es tan simple como:
#+BEGIN_SRC 
sudo pip3 install topydo
#+END_SRC

** Indicando la ruta del archivo todo.txt y done.txt
Si no queremos acceder al directorio, también podemos acceder al archivo todo.txt o done.txt, especificando su ruta
#+BEGIN_SRC 
topydo -t ~/todo/todo.txt -d ~/todo/done.txt
#+END_SRC

Si utilizamos la versión prompt, podríamos lanzarlo con:
#+BEGIN_SRC 
topydo -t ~/todo/todo.txt prompt
#+END_SRC

** Configuración

Podemos configurar topydo con uno o más archivos de configuración de estilo ini. topydo busca los siguientes archivos de configuración en este orden:
 
#+BEGIN_SRC 
/etc/topydo.conf
$HOME/.config/topydo/config
$HOME/.topydo
.topydo (en el directorio de trabajo actual)
topydo.conf (en el directorio de trabajo actual)
topydo.ini (en el directorio de trabajo actual) (para soporte mejorado en Windows)
#+END_SRC

Para especificar un archivo de configuración alternativo, utilizaremos la opción -c.

Los valores en archivos de configuración posteriores, anulan los valores anteriores.

*** Alias

Mediante el archivo de configuración, podremos crear nuestros propios alias para invocar a topydo con comandos personalizados. Esta funcionalidad es similar a los alias en un shell de Unix (bash, zsh, etc.).

Vamos a crear el archivo de configuración =$HOME/.config/topydo/config= y añadir unos alias de ejemplo:

#+BEGIN_SRC 
[aliases]
# Muestra la primera linea de la lista
next = ls -n 1

# Muestra mi lista de trabajo, con la opción lst
lst = ls @trabajo

# abreviando comando. Pulsando l, en lugar de ls o x para salir
e = edit {}
l = ls {}
x = exit

# Poner una estrella a una tarea. Opción no standar de todo.txt
star = tag {} star 1
unstar = tag {} star
#+END_SRC

Ahora para listar mis tareas, podría hacerlo con este comnado
#+BEGIN_SRC 
topydo l
#+END_SRC


*** Crea el alias en tu sistema operativo
Recuerda que para no tener que estar utilizando todo el rato el comando *topydo*, podemos crea un alias para sustituirlo, por ejemplo, por la letra *t*.

Así, tal como explicaba antes, listar nuestras tareas sería tan simple como:
#+BEGIN_SRC 
t l
#+END_SRC

** topydo. Uso Básico
Es mucho más simple que todotxt-cli ya que necesitamos crear previamente un archivo de configuración. 

Simplemente entramos en el directorio donde está el archivo todo.txt y ejecutando el comando =topydo=, ya podemos gestionar nuestra lista de tareas de nuestro archivo todo.txt.

Vamos a ver un poco como funciona esta aplicación
*** Añadir tarea 
#+BEGIN_SRC 
topydo add "grabar podcast de topydo +podcast"
#+END_SRC

Para que sea más simple y rápido, a diferencia de todotxt-cli, no es obligatorio utilizar comillas
#+BEGIN_SRC 
topydo add grabar podcast de topydo +podcast
#+END_SRC

*** Listar tareas

#+BEGIN_SRC 
todopy ls
#+END_SRC

*** Filtrar
Tan sencillo como escribir el comando seguido de la palabra a filtrar:
#+BEGIN_SRC 
topydo palabra
#+END_SRC

** Modo prompt

El modo de solicitud es bastante similar a la interfaz de línea de comandos, excepto que los subcomandos se reconocen inmediatamente (no es necesario escribir *topydo* cada vez) y hay una finalización automática.

Los cambios en su lista de tareas pendientes se guardan inmediatamente después de cada comando.

Este modo es adecuado si invocamos la CLI de topydo con bastante frecuencia.
** Instalación modo prompt

El modo de prompt requiere una dependencia adicional prompt_toolkitque así que vamos a instalarla primero.

#+BEGIN_SRC 
sudo pip3 install "topydo[prompt]"
#+END_SRC

** Uso modo prompt

Iniciamos con:
#+BEGIN_SRC 
topydo prompt
topydo>
#+END_SRC

Ahora puedes introducir comandos de inmediato, sin comenzar con topydo.

*** Salir del modo prompt
Para salir, escribe el comando *exit*.
*** Listar
**** Listar todas las tareas

#+BEGIN_SRC 
ls
#+END_SRC

**** Listar Proyectos

Escribiendo ls + TAB, nos mostrará todas las opciones de ls.

#+BEGIN_SRC 
lsproj

lspr
#+END_SRC

**** Listar contextos

#+BEGIN_SRC 
lscon
#+END_SRC

*** Filtrar
Simplemente escribimos la palabra, pulsamos *enter* y ya nos muestra los resultados

*** Limpiar terminal
Igual que hacemos habitualmente en nuestra terminal, utilizaremos el atajo *Ctrl+l*.

*** Añadir una tarea

Escribimos add seguido de la tarea
#+BEGIN_SRC 
add tarea
#+END_SRC

*** Autocompletar

Los siguientes elementos se autocompletan automáticamente al presionar *Tab*:

- Comandos, Subcomandos y alias
- Proyectos (presione Tab después +)
- Contextos (presione Tab después @)
- Fechas (presione Tab después de due:o t:, o las etiquetas correspondientes que se configuraron )

*Con las flechas arriba y abajo, podemos seleccionar el histórico de comandos previamente introducidos*.

Con *TAB* autocompleta lo que estamos escribiendo. 
Ejemplo.
#+BEGIN_SRC 
add tarea @c
#+END_SRC

Si pulsamos ahora *TAB*, en mi caso autoescribirá el contexto *@casa*

El proceso para crear una tarea utilizando el autocompletado, sería:
1) add
2) Escribimos de un modo natural la tarea
3) @ y pulsamos TAB o + y pulsamos TAB

#+BEGIN_SRC 
add @podcast hablar en el podcast de topydo
#+END_SRC

*** Añadir una prioridad a una tarea

#+BEGIN_SRC 
pri 56 A
#+END_SRC
Añadir prioridad *A* a la tarea 56.

También podemos utilizar *a* minúscula, no es obligatorio escribir *A*.

*** Añadir fecha
Escribe *due:* y pulsa *TAB*. Te mostrará unas fechas por defecto.

Con *append*, podemos agregar al final lo que queramos

*** Posponer fecha

#+BEGIN_SRC 
postpone 16 1d
#+END_SRC
Posponer un dia la tarea 16

- w -> semana
- m -> mes
- y -> año

*** Editar
Si escribimos *edit*, nos abrirá todo el archivo todo.txt para editarlo.
Si escribimos *edit 20*, editaremos solo la tarea 20.

*** Borrar una tarea
Para borrar una tarea, es tan simple como:
#+BEGIN_SRC 
del 45
#+END_SRC

Borrando la tarea 45

*** Revertir cambios
Es posible que hayas guardado una tarea y te hayas equevocado, puedes reviertir con el comando revert
#+BEGIN_SRC 
revert
#+END_SRC

Te preguntaras, ¿como hace esto?. Topydo guarda un bakup de tu todo.txt en el mismo directorio que tienes el archivo llamado *.todo.bak*.

*** Poner estrellas
Esto es algo que no está en la sintaxis oficial de todo.txt.

Podemos añadir un número de estrellas según la importancia.

La sintaxis sería:

#+BEGIN_SRC 
(C) 2020-04-27 A starred item star:1
#+END_SRC

Alias
#+BEGIN_SRC 
# starring and unstarring
# `star 42` substitutes to `tag 42 star 1`
star = tag {} star 1
unstar = tag {} star
#+END_SRC

Para visualizar, escribimos =s + TAB= , start 1.
start 2

**** Añadiendo estrellas

A la tarea 42, le pongo una estralla 
#+BEGIN_SRC 
 star 42 1
#+END_SRC
*** Añadir con appen
Para añadir un texto a una tarea, utilizaremos appen:
#+BEGIN_SRC 
appen 47 texto a añadir
#+END_SRC
*** Tarea realizada

Pulsaremos =do numero_tarea=. Automáticamente irá al archivo *done.txt*.

Para finalizar varias tareas =do tarea1 tarea2 ...=.

*** Resumen de Comandos disponibles

Escribiendo *help*, nos mostrará la ayuda con todos los comandos disponibles.

#+BEGIN_SRC 
 add
 append (app)
 del (rm)
 dep
 depri
 do
 edit
 ls
 listcon (lscon)
 listprojects (lsprj)
 postpone
 pri
 revert
 sort
 tag

Run `topydo help <subcommand>` for command-specific help.

#+END_SRC
** Columnas
*** Instalación con columnas
#+BEGIN_SRC 
sudo pip3 install 'topydo[columns]'
#+END_SRC
*** Iniciar
Situandonos en el directorio donde tenemos nuestro archivo todo.txt.
#+BEGIN_SRC 
topydo columns
#+END_SRC
Si no es así, tendremos que especificar la ruta, tal como explicaba al principio del artículo.

*** Uso 
Para introducir un comando, utilizaremos *:*, como en vim.
Con *:help*, tendremos la ayuda.

- Ayuda -> :help
- Salir -> :quit o :exit

*** Acciones de Columnas. Añadir, borrar,... Columnas

Para añadir una nueva columna , pulsa la tecla *A*.

| Llave	  | Acción	        | Descripción                                               |
|----------+-----------------+-----------------------------------------------------------|
| A	      | append_column	 | Agregar / agregar columna (a la derecha)                  |
| I	      | insert_column	 | Insertar nueva columna antes de la columna actual         |
| E	      | edit_column	   | Editar la definición de columna actual                    |
| D	      | delete_column	 | Eliminar la columna actual                                |
| Y	      | copy_column	   | Copie ( y ank) la columna actual                          |
| L	      | swap_left	     | Cambiar la columna actual con la columna vecina izquierda |
| R	      | swap_right	    | Cambiar la columna actual con la columna vecina derecha   |
| Ctrl-a	 | mark_all	      | Marca todos los elementos en la columna actual            |

*** Navegación

| Llave	   | Acción	       | Descripción                                                        |
|-----------+----------------+--------------------------------------------------------------------|
| j o ↓	   | up	           | Mueve un elemento hacia abajo                                      |
| k o ↑	   | down	         | Mueve un elemento hacia arriba                                     |
| l o →	   | next_column	  | Ir a la siguiente columna                                          |
| h o ←	   | prev_column	  | Ir a la columna anterior                                           |
| gg o Home | 	home	       | Mover hacia arriba                                                 |
| G o End	 | end	          | Mover al fondo                                                     |
| 0	       | first_column	 | Moverse a la primera columna                                       |
| $	       | last_column	  | Moverse a la última columna                                        |
| :		     |                | Enfoca la línea de comandos para ejecutar comandos personalizados. |

*** Acciones de elementos de todo

| Llave	         | Acción        | 	   Descripción                                                                      |
|-----------------+---------------+---------------------------------------------------------------------------------------|
| d	             | cmd del {}	  | Se ejecuta delen elementos resaltados                                                 |
| e	             | cmd edit {}	 | Se ejecuta editen elementos resaltados                                                |
| m	             | mark	        | Marcar elemento actual (para realizar acciones en varios elementos simultáneamente)   |
| pp< período >	 | postpone	    | Se ejecuta postponeen los elementos resaltados con el período dado .                  |
| pr< prioridad > | pri	         | Se ejecuta prien los elementos resaltados con la prioridad dada.                      |
| ps< período >	 | postpone_s	  | Se ejecuta postponeen modo estricto en los elementos resaltados con el período dado . |
| u	             | cmd revert	  | Ejecuta revert                                                                        |
| x	             | cmd do {}	   | Se ejecuta doen elementos resaltados                                                  |

*** Configuración Columnas

Vamos a crear el archivo de configuración para poder ver diferentes columnas preestablecidas por mi.

#+BEGIN_SRC 
nano $HOME/.config/topydo/config
#+END_SRC

Añadimos, por ejemplo

#+BEGIN_SRC 
[Current]
title = Current
sortexpr = desc:importance
groupexpr = project
show_all = 0

[Overdue]
title = Overdue
filterexpr = due:<today
sortexpr = desc:due
show_all = 1

[Starred]
title = Starred
filterexpr = star:1
show_all = 1
#+END_SRC

Iniciaremos con mi configuración, ejecutando el siguiente comando
#+BEGIN_SRC 
topydo columns -l $HOME/.config/topydo/config
#+END_SRC

*** Otros atajos de línea de comando

La línea de comandos, activada al presionar *:*, admite las siguientes teclas:

- Ctrl-a	-> Ir al principio
- Ctrl-e	-> Muévete hasta el final
- Ctrl-u	-> Eliminar del cursor al principio
- Ctrl-k	-> Eliminar desde el cursor hasta el final

** Android
Gracias a Termux, también podremos utilizar topydo en Android.

Voy a explicar un poco el proceso

1) Instalaremos Termux desde Google Play o F-Droid
2) Instalamos Python3 =apt-get install python=
3) Instalamos topydo =pip3 install topydo=
4) Crearemos unos alias para que nos se más sencillo:

#+BEGIN_SRC 
vi $HOME/.bashrc
#+END_SRC

Añadiremos el siguiente contenido
#+BEGIN_SRC 
alias topydo=$HOME/.local/bin/topydo
alias do="topydo do"
alias add="topydo add"

# -N and %S make sure that the list fits on the screen properly
alias t="topydo ls -N -F '%I %S' "
#+END_SRC

Asegurate tener source =$HOME/.bashrc= en tu =$HOME/.bash_profile=.

** Fuentes
- https://c306.net/t/topydo-docs/
- https://ugeek.github.io/blog/varios/topydo.html
- http://bropages.org/topydo

* DONE screen. Comandos básicos
:PROPERTIES:
:TITLE: screen. Comandos básicos
:EXPORT_FILE_NAME: 2020-05-23-screen-comandos-basicos
:DESCRIPTION:
:EXPORT_DATE: 2020-05-24 18:15
:CATEGORY: bash
:TAG: screen
:IMAGE: ./images-blog/bash.png
:END:

Screen nos permite tener múltiples terminales abiertas en una sesión o llevar a segundo plano un proceso inacabado, que cerrando la terminal, se detendría.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Voy dejaros los comandos básicos para hacer uso de screen.


** Instalación
Podemos encontrarlo en cualquier distro en sus repositorios
#+BEGIN_SRC 
sudo apt install screen
#+END_SRC

** Iniciar screen 
Para iniciar screen y crear una nueva sesión:
#+BEGIN_SRC 
screen
#+END_SRC
** Iniciar sesión y ponerle nombre
Para iniciar screen y poner un nombre a la sesión, utilizaremos la opción *-S*.
#+BEGIN_SRC 
screen -S nombre_de_sesión
#+END_SRC


** Salir de screen y dejar sesión en segundo plano: 
#+BEGIN_SRC 
Ctrl+a d
#+END_SRC

** Listar sesiones screen

#+BEGIN_SRC 
screen -ls
#+END_SRC

Vemos los id (número) de cada screen. Para entrar en esa sesión, lo haríamos indicando su id:

#+BEGIN_SRC 
screen -r id
#+END_SRC
** Cerrar sesión screen, estando dentro

#+BEGIN_SRC 
exit
#+END_SRC

** Cerrar sesión desde fuera
Si la sesión tiene nombre, podríamos cerrarla desde fuera de screen así:
#+BEGIN_SRC 
screen -XS nombre_de_sesión quit
#+END_SRC



* Backup de tu Shaarli
  :PROPERTIES:
  :ARCHIVE_TIME: 2020-05-24 dom 16:59
  :ARCHIVE_FILE: ~/docker/webdav/02_Org/tareas.org
  :ARCHIVE_OLPATH: Artículos
  :ARCHIVE_CATEGORY: tareas
  :END:

* DONE Backup de tu Shaarli
:PROPERTIES:
:TITLE: Backup de tu Shaarli
:EXPORT_FILE_NAME: backup-de-tu-shaarli
:DESCRIPTION:
:EXPORT_DATE: 2020-05-24 17:30
:CATEGORY: docker
:TAG: shaarli,rss,feed
:IMAGE: ./images-blog/shaarli.png
:END:

Para hacer un backup de los enlaces que tenemos en shaarli, es muy sencillo.

#+HTML: <center>
[[./images-blog/shaarli.png]]
#+HTML: </center>


** Backup de tus enlaces en Shaarli
Vamos ha hacer un *cat* del *datastore.php* y lo vamos a exportar fuera. En mi caso, voy a guardarlo en la carpeta de configuración del contenedor de shaarli 

#+BEGIN_SRC 
docker exec -t shaarli cat /var/www/shaarli/data/datastore.php > ~/docker/shaarli/$(date +%Y-%m-%d_%H%M)-shaarli.php
#+END_SRC

Después, si montamos shaarli en otro lugar, solo tendremos que importar datastore.php, que además, vamos a añadir la fecha del backup.

Recomiendo utilizar cron. Así nos despreocupamos y siempre tendremos nuestro backup.

** Fuente
- https://shaarli.readthedocs.io/en/latest/guides/backup-restore-import-export/


* DONE FreshRSS. Mi servidor de RSS
:PROPERTIES:
:TITLE: FreshRSS. Mi servidor de RSS
:EXPORT_FILE_NAME: freshrss-mi-servidor-de-rss
:DESCRIPTION:
:EXPORT_DATE: 2020-05-24 17:28
:CATEGORY: rss
:TAG: feed
:IMAGE: ./images-blog/freshrss.png
:END:

Hace algo más de tres años, [[Bon dia Nuria][os hablé en el podcast de mi experiencia con Freshrss]]. Entonces, no había una buena aplicación para Android. Hoy eso ha cambiado.

El servicio prácticamente es el mismo. Han cambiado algunos detalles como el que cada sección que creamos, crea un Feed, igual que hace Tiny Tiny RSS.
#+HTML: <center>
[[./images-blog/freshrss.png]]
#+HTML: </center>

Voy a darle una nueva oportunidad, ya que basándome en sensaciones, es mucho más rápido en el momento de sincronizar con la aplicación mobile, las aplicaciones de Android de terceros, pese a no ser Software Libre, son mucho mejores que la versión de Tiny Tiny RSS y la navegación vía web, es muchísimo mejor y se adapta perfectamente a cualquier tamaño de pantalla, pudiendo utilizarla en cualquier dispositivo.

Si quieres profundizar, FreshRSS permite personalizar el periodo de actualización de cada Feed, grupo de Feed's, compartir con muchos servicios como Pocket, Wallabag, Shaarli,... Te informa de los Feeds que están en desuso,  esta llena de estadísticas sobre nuestro Feeds favoritos,... 

Vamos, que está muy completito.

Ahora todo es mucho más fácil de instalar, gracias al docker con su docker oficial y el de la comunidad LinuxServer.io.

Vamos a instalarlo

** Docker Oficial ARM
Mi Raspberry Pi ya tiene FreshRSS. Podemos encontrarlo en el [[https://hub.docker.com/r/freshrss/freshrss][DockerHub]].
        
#+BEGIN_SRC 
docker create \
  --name=freshrss \
  -e TZ=Europe/Mardrid \
  -v $HOME/docker/freshrss/data:/var/www/FreshRSS/data \
  -v $HOME/docker/freshrss/extensions:/var/www/FreshRSS/extensions \
  -p 80:80 \
freshrss/freshrss:arm
#+END_SRC

** Docker Oficial amd64
Así creamos el docker para arquitectura amd64.
#+BEGIN_SRC 
docker create \
  -e TZ=Europe/Mardrid \
  -v $HOME/docker/freshrss/data:/var/www/FreshRSS/data \
  -v $HOME/docker/freshrss/extensions:/var/www/FreshRSS/extensions \
  -p 80:80 \
freshrss/freshrss
#+END_SRC

*** Actualizar FreshRSS con cron

Actualizar manualmente FreshRSS
#+BEGIN_SRC 
docker exec --user www-data freshrss php ./app/actualize_script.php
#+END_SRC

Actualizar manualmente FreshRSS, guardando un log
#+BEGIN_SRC 
docker exec --user www-data freshrss php ./app/actualize_script.php > ~/docker/freshrss/FreshRSS.log 2>&1
#+END_SRC

Automatizándolo con cron en nuestro sistema operativo.
Este método, cada 20 minutos, se actualizaran nuestro Feeds.
#+BEGIN_SRC 
*/20 * * * * docker exec freshrss php ./app/actualize_script.php > ~/docker/freshrss/FreshRSS.log 2>&1
#+END_SRC

** Docker amd64, ARM, LinuxServer
El docker de Linux Server, sirve para todas las arquitecturas y se actualiza FreshRSS, sin necesidad de hacerlo mediante cron.
#+BEGIN_SRC 
docker create \             
  --name=freshrss \
  -e PUID=1000 \
  -e PGID=1000 \
  -e TZ=Europe/Madrid \
  -p 80:80 \
  -v $HOME/docker/freshrss:/config \
  linuxserver/freshrss
#+END_SRC

** Crea una contraseña para la api

Si nos conectamos a esta url, veremos que por defecto no tenemos habilitada la api =http://url:puerto/api/=

Para habilitarla, iremos en el menú de configuración al apartado *Identificación* y seleccionaremos *Concederle acceso a la API (necesario para apps de móvil)*

Una vez hemos habilitado la api, ahora vamos al apartado *Perfil* y en la parte inferior, donde pone *API management*, pondremos una contraseña a la Api.


Al iniciar la sesión en tu movil o cualquier aplicación que utiliza la api, introduciremos nuestra *url del servidor*, *usuario* y *contraseña de la api*.

Ya tenemos acceso a Freshrss!!!

** Aplicaciones Android

- [[https://play.google.com/store/apps/details?id=com.seazon.feedme][FeedMe (RSS Reader | Podcast)]] *Esta utilizo*
- [[https://play.google.com/store/apps/details?id=com.isaiasmatewos.readably][Readably]]
- [[https://play.google.com/store/apps/details?id=com.readrops.app][Readrops]] *Software Libre* [[https://github.com/readrops/Readrops/issues][GitHub]]
- [[https://f-droid.org/es/packages/fr.chenry.android.freshrss/][FreshRss]] *Software Libre* [[https://git.feneas.org/christophehenry/freshrss-android][GitLab]]

** Fuentes
- https://github.com/FreshRSS/FreshRSS/tree/master/Docker
* DONE Copiar directorios o archivos de un Docker a Local o viceversa
:PROPERTIES:
:TITLE: Copiar directorios o archivos de un Docker a Local o viceversa
:EXPORT_FILE_NAME: copiar-directorios-o-archivos-de-un-docker-a-local-o-viceversa
:DESCRIPTION:
:EXPORT_DATE: 2020-05-25 18:40
:CATEGORY: docker
:TAG: servidor
:IMAGE: ./images-blog/docker.png
:END:


Después de hacer el artículo de como hacer un Backup del docker Shaarli, busqué un poco de información para averiguar de que modo podemos copiar archivos del interior del contenedor y guardarlos en la máquina local y viceversa.

Como podéis ver en este artículo, algo que de salida puede parecer muy complicado, es súper fácil.
#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>


Aunque es importante el tener montado *volumenes*, que sería esa carpeta de intercambio entre tu Docker y tu máquina local, con este método, si no has montado estos volumenes, si te permite intercambiar archivos o directorios con tus dockers.

** Del Contenedor a Local

#+BEGIN_SRC 
docker cp NOMBRE_CONTENEDOR:RUTA_DEL_CONTENEDOR RUTA_LOCAL
#+END_SRC

** De Local al Contenedor 
#+BEGIN_SRC 
docker cp RUTA_LOCAL NOMBRE_CONTENEDOR:RUTA_DEL_CONTENEDOR
#+END_SRC

- https://riptutorial.com/es/docker/example/6587/copiando-archivo-desde---a-contenedores

#+HTML: <center>
[[./images-blog/traducir-plusmessenger.png]]
#+HTML: </center>
* DONE Mumble. El docker del servidor de VoIP de Software Libre
:PROPERTIES:
:TITLE: Mumble. El docker del servidor de VoIP de Software Libre.
:EXPORT_FILE_NAME: mumble-el-docker-del-servidor-de-voip-de-software-libre
:DESCRIPTION:
:EXPORT_DATE: 2020-06-01 19:45
:CATEGORY: docker
:TAG: voip
:IMAGE: ./images-blog/mumble.png
:END:

No es la primera vez que os hablo de Mumble. Hace unos 9 meses cree una imagen para docker con la intención de instalar rápido sin problemas el servicio para arquitectura arm y amd64.

Este contenedor parte de un Alpine Linux, así que es una imagen muy pequeña, tan solo ocupa 11.47Mb la versión para arm y 19.91Mb la de amd64.

#+HTML: <center>
[[./images-blog/mumble.png]]
#+HTML: </center>

Vamos a ver como instalarlo y configurarlo

** ARM, Raspberry Pi

#+BEGIN_SRC 
docker run -d --name mumble -p 64738:64738 ugeek/mumble:arm
#+END_SRC

** amd64
#+BEGIN_SRC 
docker run -d --name mumble -p 64738:64738 ugeek/mumble:amd64
#+END_SRC

** Configuración
Para configurar el servicio, vamos a entrar dentro del contenedor
#+BEGIN_SRC 
docker exec -i -t --user root mumble sh
#+END_SRC

Ahora vamos a poner una contraseña, para que solo aquellos que nosotros autoricemos, tengan acceso al servicio.

Utilizaremos vi para editar el archivo de configuración, ya que viene instalado por defecto
#+BEGIN_SRC 
vi /config/mumble-server.ini
#+END_SRC

Buscaremos donde ponga:
#+BEGIN_SRC 
# Password to join server.                 
serverpassword=contraseña
#+END_SRC

Y sustituimos *contraseña*, por la contraseña.
* DONE Instalando docker-compose
:PROPERTIES:
:TITLE: Instalando docker-compose
:EXPORT_FILE_NAME: instalando-docker-compose
:DESCRIPTION:
:EXPORT_DATE: 2020-06-04 19:25
:CATEGORY: docker
:TAG: docker-compose
:IMAGE: ./images-blog/docker.png
:END:


Docker-compose está en los repositorios oficiales de muchas distros, pero casi con toda seguridad, la versión que encontraremos en esta no será última y esto, dependiendo de la versión de docker-compose que queramos levantar, puede dar errores. Para evitar esto, lo ideal es tener la ultima versión.
#+HTML: <center>
[[./images-blog/docker.png]]
#+HTML: </center>

Vamos a instalar docker-compose a la última de un modo súper fácil en ubuntu, debian, Raspberry Pi OS,...

** Instalando
Si no tienes instalado pip, deberás instalarlo
#+BEGIN_SRC 
sudo apt install python3-pip
#+END_SRC

Ahora vamos a instalar docker-compose
#+BEGIN_SRC 
sudo pip3 install docker-compose
#+END_SRC
- [[https://pypi.org/project/docker-compose/][Fuente]]

** Versión
Vamos a verificar la versión de docker-compose
#+BEGIN_SRC 
 docker-compose -v
#+END_SRC
** Levantar un docker con docker-compose
Ahora cuando tenga un archivo *docker-compose.yml*, lo levantaré con:
#+BEGIN_SRC 
docker-compose up -d
#+END_SRC


* DONE Instalar Node.js 12. Versión estable
:PROPERTIES:
:TITLE: Instalar Node.js 12. Versión estable
:EXPORT_FILE_NAME: instalar-node-js-12-version-estable
:DESCRIPTION:
:EXPORT_DATE: 2020-06-07 17:30
:CATEGORY: node
:TAG: joplin
:IMAGE: ./images-blog/node.png
:END:

Necesitaba actualizar Node.js a partir de la versión 10 para poder utilizar joplin-cli.

Utilizando el mismo script, podemos instalar la versión estable, hoy la versión 12 o la versión inestable, versión 14.
#+HTML: <center>
[[./images-blog/node.png]]
#+HTML: </center>

Si quieres cambiar la versión, solo tienes que cambiar el número *12*, por el número de versión que desees.

Vamos a actualizar la versión que tenemos en los repositorios a la versión *12.18*, que es la versión estable el día que estoy escribiendo este artículo.

*** Instalación

Instalamos curl si no lo tenemos instalado

#+BEGIN_SRC 
sudo apt install curl
#+END_SRC

Descargamos y ejecutamos este script
#+BEGIN_SRC 
curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
#+END_SRC

Instalamos nodejs
#+BEGIN_SRC 
sudo apt install nodejs
#+END_SRC

Comprobar la versión
#+BEGIN_SRC 
node -v
#+END_SRC

* DONE Sincronización con Rclone via SSH y SFTP
:PROPERTIES:
:TITLE: Sincronización con Rclone via SSH y SFTP
:EXPORT_FILE_NAME: sincronizacion-con-rclone-via-ssh-sftp
:DESCRIPTION:
:EXPORT_DATE: 2020-06-08 17:50
:CATEGORY: rclone
:TAG: ssh
:IMAGE: ./images-blog/rclone.png
:END:
Estamos acostumbrados a conectarnos nubes públicas y privadas con rclone. Hoy vamos a conectarnos a un VPS o servidor remoto via SSH con SFTP.

#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

** Archivo de configuración
Actualmente me conecto vía SSH sin necesidad de poner la contraseña, ya que en el servidor he añadido mi *id_rsa* pública.

Vamos a aprovechar esta llave pública para acceder con rclone.

Vamos a añadir en el archivo de configuración de *rclone.conf* en =/home/angel/.config/rclone/rclone.conf=

#+BEGIN_SRC  
[servidor]
type = sftp
host = 192.168.1.100
user = ubuntu
port = 22
key_file = /home/angel/.ssh/id_rsa

#+END_SRC
Ahora vamos a probar listar los directorios de $HOME del servidor, para comprobar que todo funciona correctamente

#+BEGIN_SRC 

rclone lsd vps1:/home/ubuntu/
#+END_SRC

* DONE Joplin Desktop, Joplin para Terminal y WebClipper
:PROPERTIES:
:TITLE: Joplin Desktop, Joplin para Terminal y WebClipper
:EXPORT_FILE_NAME: joplin-desktop-joplin-para-terminal-y-webclipper
:DESCRIPTION:
:EXPORT_DATE: 2020-06-13 19:17
:CATEGORY: joplin
:TAG: notas,terminal
:IMAGE: ./images-blog/joplin.png
:END:

Joplin junto al orgmode, se está convirtiendo en una aplicación imprescindible para mi. Me permite tener sincronizadas mis notas en todos mis dispositivos, gracias a mi servidor webdav.
#+HTML: <center>
[[./images-blog/joplin.png]]
#+HTML: </center>

Voy a explicaros la instalación de algunos de sus clientes y conocer el funcionamiento de la versión de terminal.
** AppImage
Para instalar la versión de escritorio con AppImage.

- Podemos descargar la versión de escritorio [[https://github.com/laurent22/joplin/releases][desde su repositorio en GitHub]]
- Damos permisos de ejecución al archivo descargado =sudo chmod +x ./*.AppImage=
- Lanzamos el AppImage

En debian Buster, me da un problema al ejecurar el AppImage, ya que me dice que el sandbox no está bien configurado. Para poder arrancarlo utilizo:
#+begin_src 
./Joplin-1.0.218.AppImage --no-sandbox
#+end_src

Para configurar correctamente el sandbox, ejecutaremos:

#+begin_src 
sudo sysctl kernel.unprivileged_userns_clone=1
#+end_src

- [[https://github.com/ramboxapp/community-edition/issues/2481][Fuente]]

** Snap
Si tienes snap en tu sistema, es tan sencillo como:
#+BEGIN_SRC 
sudo snap install joplin-james-carroll
#+END_SRC
- https://snapcraft.io/joplin-james-carroll
- https://joplinapp.org/#terminal-application

** WebClipper
Por si solo, el plugin no funciona. Necesita tener abierta la versión desktop de joplin, ya que esta utiliza el puerto *41184* para enviar el contenido del navegador.

Para habilitar que WebClipper y envíe el contenido de una web a joplin desktop, tenemos que ir *Herramientas/Opciones/Web Clipper* y habilitar el servicio.

Después, como no, tenemos que instalar la extensión para Firefox o Google Chrome.

** Control de versiones
Joplin ya permite el control de versiones de una nota. Esto quiere decir que podemos volver atrás en el tiempo, a una edición anterior. Esta opción actualmente solo está disponible en la versión desktop pulsando sobre la "i" de información de la nota o tarea.
** SubLibretas
También podemos crear sublibretas. Esta opción también a día de hoy, es exclusiva en la versión desktop. EL desarrollador ya ha comunicado que en breve estará en la versión mobile.

** Joplin para Terminal
Vamos a instalar la versión para utilizar Joplin desde la terminal.
*** Instalando Node
Primero instalaremos Node 10 o superior

#+BEGIN_SRC 
sudo apt update
sudo apt install nodejs
#+END_SRC

Ahora npm
#+BEGIN_SRC 
sudo apt install npm
#+END_SRC

*** Instalando Joplin-cli

Podemos instalar la versión de terminal en nuestro pc con arquitectura amd64 o en nuestra Raspberry Pi con arquitectura ARM.

#+BEGIN_SRC 
NPM_CONFIG_PREFIX=~/.joplin-bin npm install -g joplin
#+END_SRC

Creamos un enlace, así en la terminal, con solo escribir joplin, nos abrirá joplin-cli.
#+BEGIN_SRC 
sudo ln -s ~/.joplin-bin/bin/joplin /usr/bin/joplin
#+END_SRC


*** Carpeta de configuración
Los archivos de configuración, pueden estar en la carpeta
#+BEGIN_SRC 
~/.config/joplin
#+END_SRC

Carpeta donde están las imágenes
#+begin_src 
~/.config/joplin/resources
#+end_src

*** Uso


La app de terminal es muy intuitiva. Aparecerán tres grandes columnas, con las libretas, notas y contenido de estas. Utilizaremos la tecla *TAB* para saltar de una columna a otra.

Para introducir un comando, tendremos que escribir *:* seguido del comando.

También permite el autocompletado mediante *TAB*. De manera que si escribimos /:sy/ y pulsamos *TAB*, auto escribirá *:sync*.

Para salir de la aplicación, lo haremos escribiendo =:exit= o pulsando *Ctrl+d*.

*** Algunos comandos útiles

#+BEGIN_SRC 
:mknote "Título de Nota"   # Crear nota
:mn     "Título de Nota"   # Crear nota
:mktodo "Título de tarea"  # Crear tarea -> Pulsa la tecla *space*, para marcar la tarea como realizada
:mt     "Título de tarea"  # Crear tarea
:mkbook "Nombre Libreta"   # Crear una libreta
:mb     "Nombre Libreta"   # Crear una libreta
:ren $n "Nuevo nombre"     # Renombrar la nota en la que estás situado, con el nombre "Nuevo nombre"
:mv  $n "Tareas"           # Mover la nota en la que estás situado, a la libreta "Tareas"
:yn       cp $n                                                                                                                                                                      
:dn       mv $n ""   
:search                    # Buscar
:mv TAB                    # Mover una nota. Si pulsas TAB, nos aparecera todas las notas a seleccionar
:sync                      # Sincronizar con el servidor
:status                    # Ver estado. Número de notas, libretas,...
:config editor "nano"      # Cambiar editor por defecto
:help                      # Ayuda
:help all                  # Ayuda más completa
:help keymap               # Atajos 
#+END_SRC

*** Atajos 
#+begin_src 
tm        # Ver metadata de una nota
tc        # Entrar y salir al modo consola
Enter     # Encima de una nota, editarla
suprimir  # Da la opción a borrar una nota, tarea, libreta
Backspace # Da la opción a borrar una nota, tarea, libreta
/         # Buscar
TAB       # Saltar entre columnas y autoescritura
Ctrl+d    # Salir
#+end_src

*** Personalizar atajos 
Crea el siguiente archivo, si no lo tienes creado
#+begin_src 
nano ~/.config/joplin/keymap.json
#+end_src

Añade el siguiente contenido
#+begin_src 
[
	{ "keys": [":"], "type": "function", "command": "enter_command_line_mode" },
	{ "keys": ["TAB"], "type": "function", "command": "focus_next" },
	{ "keys": ["SHIFT_TAB"], "type": "function", "command": "focus_previous" },
	{ "keys": ["UP"], "type": "function", "command": "move_up" },
	{ "keys": ["DOWN"], "type": "function", "command": "move_down" },
	{ "keys": ["PAGE_UP"], "type": "function", "command": "page_up" },
	{ "keys": ["PAGE_DOWN"], "type": "function", "command": "page_down" },
	{ "keys": ["ENTER"], "type": "function", "command": "activate" },
	{ "keys": ["DELETE", "BACKSPACE"], "type": "function", "command": "delete" },
	{ "keys": [" "], "command": "todo toggle $n" },
	{ "keys": ["tc"], "type": "function", "command": "toggle_console" },
	{ "keys": ["tm"], "type": "function", "command": "toggle_metadata" },
	{ "keys": ["/"], "type": "prompt", "command": "search \"\"", "cursorPosition": -2 },
	{ "keys": ["mn"], "type": "prompt", "command": "mknote \"\"", "cursorPosition": -2 },
	{ "keys": ["mt"], "type": "prompt", "command": "mktodo \"\"", "cursorPosition": -2 },
	{ "keys": ["mb"], "type": "prompt", "command": "mkbook \"\"", "cursorPosition": -2 },
	{ "keys": ["yn"], "type": "prompt", "command": "cp $n \"\"", "cursorPosition": -2 },
	{ "keys": ["dn"], "type": "prompt", "command": "mv $n \"\"", "cursorPosition": -2 }
]
#+end_src

Sustituye o personaliza a tu gusto

*** Configuración para Webdav, Nexcloud, OwnCloud

Nubes disponibles:
2: File system
3: OneDrive 
5: Nextcloud
6: WebDAV
7: Dropbox

Yo en mi caso, utilizaré mi servidor webdav, así que utilizaré el número 6.

#+BEGIN_SRC 
:config sync.target 6
:config sync.6.path https://mi-url/joplin
:config sync.6.username USUARIO
:config sync.6.password CONTRASEÑA
#+END_SRC

*** Iniciar la Sincronizar
#+BEGIN_SRC 
:sync
#+END_SRC

*** Cifrado extremo a extremo

Poner la contraseña
#+BEGIN_SRC 
:e2ee decrypt
#+END_SRC
Introduzca la contraseña maestra:

*** Cambiar el editor

Cambiar el editor a emacs por defecto a:
#+BEGIN_SRC 
:config editor "emacs -nw"
#+END_SRC

** Joplin modo shell 
Los comandos son los mismos que la versión terminal, solo que el comando se ejecuta y nos devuelve el resultado.
Voy a resumir algunos de los comandos:
*** Varios 
#+begin_src 
joplin config editor                    # Muestra el editor que estamos utilizando
joplin config editor "gedit"            # Utilizar gedit como editor
joplin config dateFormat DD-MM-YYYY     # Cambiar formato de fecha
joplin mknote "nueva tarea"             # Crear la tarea llamada "nueva tarea"
joplin edit "nueva tarea"               # Editar la tarea
joplin cat "nueva tarea"                # Mostrar en terminal el contenido de la tarea
joplin cat -v "nueva tarea"             # Mostrar contenido y metadata de la tarea
joplin mkbook tareas                    # Crea la libreta tareas
joplin ls /                             # Listar libretas desde la raíz
joplin tag list                         # Listar etiquetas
joplin tag list "linux"                 # Listar notas con la etiqueta linux
joplin set fd297 titulo "nuevo titulo"  # Cambiar título de una nota
joplin use tareas                       # Situate dentro de la libreta tareas
joplin sync                             # Sincronizar todas las tareas
joplin import linux.md linux            # Importa un documento .md llamado linux en joplin con el título linux
joplin version                          # Versión de joplin

joplin export --note <node-id> --format md <output-dir>
#+end_src

- http://leetschau.github.io/joplin-notes.html

*** Listar 
Listar la raíz de tu Joplin
#+begin_src 
joplin ls /
#+end_src

Listar la raíz de tu Joplin con los id
#+begin_src 
joplin ls / -l
#+end_src


Listar y mostrar los id de las notas:
#+BEGIN_SRC 
joplin ls -l
#+END_SRC

*** Cambiar de libreta 
#+begin_src 
joplin use "nombre de libreta"
#+end_src

Ahora podemos listar las notas o tareas de esa libreta:
#+begin_src 
joplin ls
#+end_src
*** Editar Nota o Tarea

Editar nota con id 073ac
#+begin_src 
joplin edit 073ac 
#+end_src

*** Ver nota  
#+begin_src 
joplin cat "nombre nota"
#+end_src

#+begin_src 
joplin cat id
#+end_src 

*** Marcar tarea como realizada o no realizada 
#+begin_src 
done "nombre tarea"
#+end_src

#+begin_src 
undone "nombre tarea"
#+end_src

*** Ayuda 
Ayuda simple
#+begin_src 
joplin help
#+end_src

Ayuda completa
#+begin_src 
joplin help all
#+end_src

Muestra de ayuda con todos los comandos
#+begin_src 
attach <note> <file>

    Adjuntar archivo a la nota.

cat <note>

    Mostrar la nota dada.

    -v, --verbose  Mostrar la información completa acerca de la nota.

config [name] [value]

    Obtener o configurar un valor. Si no se provee el [valor], se mostrará el 
    valor de [nombre]. Si no se provee [nombre] ni [valor], se listará la 
    configuración actual.

    -v, --verbose         También muestra variables ocultas o no configuradas.
    --export              Writes all settings to STDOUT as JSON including 
                          secure variables.
    --import              Reads in JSON formatted settings from STDIN.
    --import-file <file>  Reads in settings from <file>. <file> must contain 
                          valid JSON.

Claves/valores posbiles:

    sync.target                    Destino de sincronización.
                                   El destino de la sincronización. Cada 
                                   destino de la sincronización puede tener 
                                   parámetros adicionales los cuales son 
                                   llamados como `sync.NUM.NAME` (todos abajo 
                                   documentados).
                                   Tipo: Enumeración.
                                   Posibles valores: 2 (File system), 3 
                                   (OneDrive), 5 (Nextcloud), 6 (WebDAV), 7 
                                   (Dropbox).
                                   Por defecto: 7
                                   
    sync.2.path                    Directorio con el que sincronizarse (ruta 
                                   completa).
                                   Attention: If you change this location, 
                                   make sure you copy all your content to it 
                                   before syncing, otherwise all files will be 
                                   removed! See the FAQ for more details: 
                                   https://joplinapp.org/faq/
                                   Tipo: string.
                                   
    sync.5.path                    Servidor WebDAV de Nextcloud.
                                   Attention: If you change this location, 
                                   make sure you copy all your content to it 
                                   before syncing, otherwise all files will be 
                                   removed! See the FAQ for more details: 
                                   https://joplinapp.org/faq/
                                   Tipo: string.
                                   
    sync.5.username                Usuario de Nextcloud.
                                   Tipo: string.
                                   
    sync.5.password                Contraseña de Nextcloud.
                                   Tipo: string.
                                   
    sync.6.path                    Servidor WebDAV.
                                   Attention: If you change this location, 
                                   make sure you copy all your content to it 
                                   before syncing, otherwise all files will be 
                                   removed! See the FAQ for more details: 
                                   https://joplinapp.org/faq/
                                   Tipo: string.
                                   
    sync.6.username                Usuario de WebDAV.
                                   Tipo: string.
                                   
    sync.6.password                Contraseña de WebDAV.
                                   Tipo: string.
                                   
    sync.maxConcurrentConnections  Conexiones simultáneas máximas.
                                   Tipo: int.
                                   Por defecto: 5
                                   
    locale                         Idioma.
                                   Tipo: Enumeración.
                                   Posibles valores: ar (Arabic (87%)), eu 
                                   (Basque (37%)), bs_BA (Bosnian (81%)), 
                                   bg_BG (Bulgarian (73%)), ca (Catalan 
                                   (58%)), hr_HR (Croatian (31%)), cs_CZ 
                                   (Czech (90%)), da_DK (Dansk (81%)), de_DE 
                                   (Deutsch (97%)), et_EE (Eesti Keel (72%)), 
                                   en_GB (English (UK) (100%)), en_US (English 
                                   (US) (100%)), es_ES (Español (90%)), eo 
                                   (Esperanto (41%)), fr_FR (Français (91%)), 
                                   gl_ES (Galician (47%)), it_IT (Italiano 
                                   (96%)), nl_BE (Nederlands (37%)), nl_NL 
                                   (Nederlands (92%)), nb_NO (Norwegian 
                                   (97%)), fa (Persian (36%)), pl_PL (Polski 
                                   (84%)), pt_PT (Português (98%)), pt_BR 
                                   (Português (Brasil) (98%)), ro (Română 
                                   (37%)), sl_SI (Slovenian (47%)), sv 
                                   (Svenska (78%)), th_TH (Thai (58%)), vi 
                                   (Tiếng Việt (94%)), tr_TR (Türkçe (100%)), 
                                   el_GR (Ελληνικά (89%)), ru_RU (Русский 
                                   (97%)), sr_RS (српски језик (78%)), zh_CN 
                                   (中文 (简体) (97%)), zh_TW (中文 (繁體) (98%)), 
                                   ja_JP (日本語 (100%)), ko (한국어 (95%)).
                                   Por defecto: "en_GB"
                                   
    dateFormat                     Formato de fecha.
                                   Tipo: Enumeración.
                                   Posibles valores: DD/MM/YYYY (30/01/2017), 
                                   DD/MM/YY (30/01/17), MM/DD/YYYY 
                                   (01/30/2017), MM/DD/YY (01/30/17), 
                                   YYYY-MM-DD (2017-01-30), DD.MM.YYYY 
                                   (30.01.2017), YYYY.MM.DD (2017.01.30).
                                   Por defecto: "DD/MM/YYYY"
                                   
    timeFormat                     Formato de hora.
                                   Tipo: Enumeración.
                                   Posibles valores: HH:mm (20:30), h:mm A 
                                   (8:30 PM).
                                   Por defecto: "HH:mm"
                                   
    uncompletedTodosOnTop          Mostrar tareas incompletas al inicio de las 
                                   listas.
                                   Tipo: bool.
                                   Por defecto: true
                                   
    showCompletedTodos             Mostrar tareas completadas.
                                   Tipo: bool.
                                   Por defecto: true
                                   
    notes.sortOrder.field          Ordenar notas por.
                                   Tipo: Enumeración.
                                   Posibles valores: user_updated_time (Fecha 
                                   de actualización), user_created_time (Fecha 
                                   de creación), title (Título).
                                   Por defecto: "user_updated_time"
                                   
    notes.sortOrder.reverse        Invierte el orden.
                                   Tipo: bool.
                                   Por defecto: true
                                   
    folders.sortOrder.field        Ordenar libretas por.
                                   Tipo: Enumeración.
                                   Posibles valores: title (Título), 
                                   last_note_user_updated_time (Fecha de 
                                   actualización).
                                   Por defecto: "title"
                                   
    folders.sortOrder.reverse      Invierte el orden.
                                   Tipo: bool.
                                   Por defecto: false
                                   
    trackLocation                  Guardar geolocalización en las notas.
                                   Tipo: bool.
                                   Por defecto: true
                                   
    sync.interval                  Intervalo de sincronización.
                                   Tipo: Enumeración.
                                   Posibles valores: 0 (Deshabilitado), 300 (5 
                                   minutos), 600 (10 minutos), 1800 (30 
                                   minutos), 3600 (1 hora), 43200 (12 horas), 
                                   86400 (24 horas).
                                   Por defecto: 300
                                   
    editor                         Editor de texto.
                                   El comando del editor (puede incluir 
                                   argumentos) que se utilizará para abrir una 
                                   nota. Si no se provee ninguno se intentará 
                                   auto detectar el editor por defecto.
                                   Tipo: string.
                                   
    net.customCertificates         Certificados TLS personalizados.
                                   Lista de rutas de los directorios de dónde 
                                   cargar los certificados separados por 
                                   comas, o la ruta individual de los 
                                   certificados. Por ejemplo: /mi/cert_dir, 
                                   /otro/personalizado.pem. Tenga en cuenta 
                                   que si realiza cambios en la configuración 
                                   de los certificados debe guardar los 
                                   cambios antes de pulsar en «Comprobar la 
                                   configuración de sincronización».
                                   Tipo: string.
                                   
    net.ignoreTlsErrors            Ignorar errores en certificados TLS.
                                   Tipo: bool.
                                   Por defecto: false
                                   
    sync.wipeOutFailSafe           Fail-safe.
                                   A prueba de fallos: No borre los datos 
                                   locales cuando el objetivo de 
                                   sincronización esté vacío (a menudo como 
                                   resultado de una configuración errónea o de 
                                   un error).
                                   Tipo: bool.
                                   Por defecto: true
                                   
                                   
    revisionService.enabled        Habilitar historial de notas.
                                   Tipo: bool.
                                   Por defecto: true
                                   
    revisionService.ttlDays        Mantener historial de la nota durante.
                                   Tipo: int.
                                   Por defecto: 90
                                   
    layout.folderList.factor       Notebook list growth factor.
                                   The factor property sets how the item will 
                                   grow or shrink to fit the available space 
                                   in its container with respect to the other 
                                   items. Thus an item with a factor of 2 will 
                                   take twice as much space as an item with a 
                                   factor of 1.Restart app to see changes.
                                   Tipo: int.
                                   Por defecto: 1
                                   
    layout.noteList.factor         Note list growth factor.
                                   The factor property sets how the item will 
                                   grow or shrink to fit the available space 
                                   in its container with respect to the other 
                                   items. Thus an item with a factor of 2 will 
                                   take twice as much space as an item with a 
                                   factor of 1.Restart app to see changes.
                                   Tipo: int.
                                   Por defecto: 1
                                   
    layout.note.factor             Note area growth factor.
                                   The factor property sets how the item will 
                                   grow or shrink to fit the available space 
                                   in its container with respect to the other 
                                   items. Thus an item with a factor of 2 will 
                                   take twice as much space as an item with a 
                                   factor of 1.Restart app to see changes.
                                   Tipo: int.
                                   Por defecto: 2

cp <note> [notebook]

    Duplica las notas que coincidan con <note> en la libreta. Si no se 
    especifica una libreta la nota se duplica en la libreta actual.

done <note>

    Marca una tarea como hecha.

e2ee <command> [path]

    Gestiona la configuración E2EE. Los comandos disponibles son: `enable`, 
    `disable`, `decrypt`, `status`, `decrypt-file` y `target-status`.

    -p, --password <password>  Use this password as master password (For 
                               security reasons, it is not recommended to use 
                               this option).
    -v, --verbose              More verbose output for the `target-status` 
                               command
    -o, --output <directory>   Output directory
    --retry-failed-items       Applies to `decrypt` command - retries 
                               decrypting items that previously could not be 
                               decrypted.

edit <note>

    Editar una nota.

export <path>

    Exporta datos de Joplin al directorio indicado. Por defecto, se exportará 
    la base de datos completa incluyendo libretas, notas, etiquetas y 
    recursos.

    --format <format>      Formato de destino: jex (Archivo de exportación de 
                           Joplin), raw (Directorio para exportar de Joplin), 
                           json (Directorio para exportar JSON), md 
                           (Markdown), html (Archivo HTML), html (Directorio 
                           HTML)
    --note <note>          Exporta únicamente la nota indicada.
    --notebook <notebook>  Exporta únicamente la libreta indicada.

geoloc <note>

    Muestra la URL de la geolocalización de la nota.

help [command]

    Muestra información de uso.

import <path> [notebook]

    Importa los datos en Joplin.

    --format <format>  Formato de origen: auto, jex, md, raw, enex, enex
    -f, --force        No requiere confirmación.

ls [note-pattern]

    Muestra las notas en la libreta actual. Usa `ls /` para mostrar la lista 
    de libretas.

    -n, --limit <num>      Muestra las primeras <num> notas.
    -s, --sort <field>     Ordena los elementos por campo ( ej. title, 
                           updated_time, created_time).
    -r, --reverse          Invierte el orden.
    -t, --type <type>      Muestra únicamente los elementos de los tipos 
                           especificados. Pueden ser `n` para notas, `t` para 
                           tareas, o `nt` para libretas y tareas (ej. `-tt` 
                           mostrará unicamente las tareas, mientras `-ttd` 
                           mostrará notas y tareas).
    -f, --format <format>  Puede ser «text» o «json»
    -l, --long             Usar formato largo de lista. El formato es ID, 
                           NOTE_COUNT ( para libretas), DATE,TODO_CHECKED ( 
                           para tareas), TITLE

mkbook <new-notebook>

    Crea una nueva libreta.

mknote <new-note>

    Crea una nueva nota.

mktodo <new-todo>

    Crea una nueva lista de tareas.

mv <note> [notebook]

    Mueve las notas que coincidan con <note> a la [libreta].

ren <item> <name>

    Renombra el elemento dado <item> (nota o libreta) a <name>.

rmbook <notebook>

    Elimina la libreta dada.

    -f, --force  Elimina una libreta sin pedir confirmación.

rmnote <note-pattern>

    Elimina las notas que coinciden con <note-pattern>.

    -f, --force  Elimina las notas sin pedir confirmación.

server <command>

    Inicie, pare o compruebe el servidor API. Para especificar el puerto que 
    debe ejecutarse use api.port como variable en la configuración. Los 
    comandos son (start|stop|status). This is an experimental feature - use at 
    your own risks! It is recommended that the server runs off its own 
    separate profile so that no two CLI instances access that profile at the 
    same time. Use --profile to specify the profile path.

set <note> <name> [value]

    Asigna el valor [value] a la propiedad <name> de la nota indicada <note>. 
    Propiedades disponibles:

    parent_id (text), title (text), body (text), created_time (int), 
    updated_time (int), is_conflict (int), latitude (numeric), longitude 
    (numeric), altitude (numeric), author (text), source_url (text), is_todo 
    (int), todo_due (int), todo_completed (int), source (text), 
    source_application (text), application_data (text), order (int), 
    user_created_time (int), user_updated_time (int), encryption_cipher_text 
    (text), encryption_applied (int), markup_language (int), is_shared (int)

status

    Muestra un resumen acerca de las notas y las libretas.

sync

    Sincroniza con el almacenamiento remoto.

    --target <target>  Sincroniza con el destino indicado (por defecto al 
                       valor de configuración sync.target)

tag <tag-command> [tag] [note]

    <tag-command> puede ser «add», «remove», «list», o «notetags» para asignar 
    o eliminar [etiqueta] de [nota], o para listar las notas asociadas con 
    [etiqueta], o para listar las etiquetas asociadas con [nota]. El comando 
    `tag list` puede ser usado para listar todas las etiquetas (usa -l para la 
    opción larga).

    -l, --long  Usar formato largo de lista. El formato es ID, NOTE_COUNT ( 
                para libretas), DATE,TODO_CHECKED ( para tareas), TITLE

todo <todo-command> <note-pattern>

    <todo-command> puede ser «toggle» o «clear». Usa «toggle» para cambiar la 
    tarea dada entre estado completado y sin completar. (Si el objetivo es una 
    nota regular se convertirá en una tarea). Usa «clear» para convertir la 
    tarea a una nota regular.

undone <note>

    Marca una tarea como no completada.

use <notebook>

    Cambia una [libreta] - todas las demás operaciones se realizan en ésta 
    libreta.

version

    Muestra información de la versión
#+end_src

*** Fuentes

- https://joplinapp.org/terminal/
- https://www.npmjs.com/package/joplin

** Exportar una nota
Listamos las notas en la ubicación que estamos
#+begin_src 
joplin ls -l
#+end_src

Con cat seguido del nombre de la nota/tarea o el id, exportamos su contenido a el archivo llamado *nota.md*.
#+BEGIN_SRC 
joplin cat id > nota.md
#+END_SRC

** Fuentes
- https://joplinapp.org/
- https://appimage.github.io/Joplin/
- http://leetschau.github.io/joplin-notes.html
#+HTML: <center>
[[./images-blog/joplin.png]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/joplin.png]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/joplin.png]]
#+HTML: </center>

* DONE Habilitar el modo-org en Emacs, cuando abras un archivo txt o markdown
:PROPERTIES:
:TITLE: Habilitar el modo-org en Emacs, cuando abras un archivo txt o markdown
:EXPORT_FILE_NAME: habilitar-el-modo-org-en-emacs-cuando-abras-un-archivo-txt-o-markdown
:DESCRIPTION:
:EXPORT_DATE: 2020-06-14 00:38
:CATEGORY: emacs
:TAG: joplin,simplenote
:IMAGE: ./images-blog/emacs.png
:END:

Es posible que te interese el habilitar el modo org cuando abras un archivos .txt o markdown.
#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

Por ejemplo para sincronizar notas abiertas con emacs, utilizando aplicaciones como simplenote o Joplin.

De esa manera, podemos utilizar el modo org con estás aplicaciones de notas 

** Cambiando el modo al abrir markdown
Vamos a añadir a nuestro archivo de configuración init.el,  el siguiente código, para que cada vez que abramos un archivo .md, se habilite el modo org.

#+begin_src 
(add-to-list 'auto-mode-alist '("\\.md\\'" . org-mode)) 
#+end_src

Hacer lo propio también con los archivos extensión .txt
#+begin_src 
(add-to-list 'auto-mode-alist '("\\.md\\'" . org-mode)) 
(add-to-list 'auto-mode-alist '("\\.txt\\'" . org-mode)) 
#+end_src



** Estructura de una nota con Joplin
Para poder utilizar el orgmode con Joplin y no de error en la sincronización, tendremos escribir el título en la parte superior de la nota en texto plano y *dejar un espacio en blanco* antes de escribir el primer asterisco de la sintaxis orgmode.
** Estructura con SimpleNote
Igual que con Joplin, la primera línea será el título de la nota, así que para que no salga el asterisco de la primera cabecera de la sintaxis orgmode,
lo escribiremos en texto plano. El resto del archivo, puede ser orgmode sin problemas.

La ventaja de SimpleNote, es el poder editar la nota varios usuarios.

Recuerda que para hacer esto tenemos que utilizar Emacs con el paquete  *simplenote2*.
** Fuentes
- https://www.emacswiki.org/emacs/AutoModeAlist

* DONE Cliente de escritorio para editar archivos de una nube privada (WebDav, Nextcloud,...) o pública (Drive, Dropbox, OneDrive...) con rclone
:PROPERTIES:
:TITLE: Cliente de escritorio para editar archivos de una nube privada (WebDav, Nextcloud,...) o pública (Drive, Dropbox, OneDrive...) con rclone
:EXPORT_FILE_NAME: cliente-de-escritorio-para-editar-archivos-de-una-nube-privada-(webdav-nextcloud--)-o-publica-(drive-dropbox-onedrive--)-con-rclone
:DESCRIPTION:
:EXPORT_DATE: 2020-06-22 22:12
:CATEGORY: rclone
:TAG: webdav,nextcloud,dropbox,nube,ssh
:IMAGE: ./images-blog/rclone.png
:END:

Muchos me habéis preguntado como edito con emacs mis archivos orgmode que tengo en mi nube webdav, así como mi archivo todo.txt.

Para ello, aunque existe otros clientes webdav, me ha parecido más simple y eficaz utilizar rclone.

Esto podremos hacerlo con cualquier nube pública, privada, como Webdav, Nextcloud, Dropbox, Google Drive, OneDrive,... SSH, SFTP,... vamos, todas las opciones disponibles con Rclone.
#+HTML: <center>
[[./images-blog/rclone.png]]
#+HTML: </center>

Incluso, una opción interesante, cifrar el contenido de una carpeta local con rclone, sincronizar esta con Syncthing y montarla con rclone en otro pc o servidor.

Voy a explicarlo paso a paso.

Para entender más en profundidad como montar una nube con rclone, recomiendo [[https://ugeek.github.io/blog/post/2019-07-03-dale-almacenamiento-ilimitado-a-tu-raspberry-servidor-o-pc-con-rclone.html][este artículo que hice profundizando sobre el tema]].
 
** Crear el directorio donde montaremos el contenido
Voy a crear la carpeta donde montaré mis archivos *orgmode*. La llamaré *org*.

#+begin_example
mkdir ~/org
#+end_example

** Descomenta --allow-others
Descomenta la línea --allow-others, para permitir a usuarios no root, montar unidades

#+begin_example
sudo nano /etc/fuse.conf
#+end_example

Descomenta --allow-others

#+begin_example
# Allow non-root users to specify the allow_other or allow_root mount options.
--allow-others
#+end_example

Reinicia

** Montando la nube
Tan sencillo como utilizar =rclone mount=.

#+begin_example
rclone mount drive:org ~/org
#+end_example

Para enviar el comando a segundo plano y siempre corriendo, podemos añadir al final de esta línea *&*.

Esto puede dar una serie de lecturas en la terminal, que solucionaremos tal como explico en el automontado. El automontado es con cron, pero ese mismo comando, puedes ejecutarlo en la terminal.

** Automontando al inicio de sesión del sistema operativo
Para automontar la nube al inicio de Debian, Ubuntu,... podemos hacerlo de varias maneras. 

Voy a utilizar el método más sencillo que he utilizado, con cron.

Abrimos cron desde la sesión del usuario
#+begin_example
crontab -e
#+end_example

Añadímos la siguiente línea

#+begin_example
@reboot ( sleep 25 && nohup rclone mount drive:org /home/angel/org --vfs-cache-mode full -v --allow-other  2>/dev/null & )
#+end_example

Este comando en crontab, indica que cada vez que iniciamos el sistema operativo, con =@reboot=, esperará 25 segundos y montará la nube que tengo en rclone con el nombre =drive:org=, en la carpeta =~/org=.


*nohup* y *2>/dev/null*, envía a esta posición de memoria el resultado que muestra la terminal, una posición de memoria que tiene nuestro sistema operativo precisamente para no mostrar nada en terminal.

*&*, dejará corriendo el comando indefinidamente, a no ser que lo detengamos nosotros.

*--vfs-cache-mode full*, activa la caché de lectura y escritura

*--allow-other,* permite a otros usuarios que se conecten a este directorio 

** Conclusión
Así es como monto mi nube webdav en mi escritorio para editar mis archivos orgmode. Cada vez que inicio el sistema operativo, siempre está disponible ahí mi nube.

También podemos hacer lo mismo, pero en lugar de utilizar cron, podemos crear un servicio, pero esto lo dejo para otro artículo.


#+HTML: <center>
[[./images-blog/googlefotos.png]]
#+HTML: </center>
* DONE Informacion de tu sistema, pc, servidor,... con neofetch
:PROPERTIES:
:TITLE: Informacion de tu sistema, pc, servidor,... con neofetch
:EXPORT_FILE_NAME: informacion-de-tu-sistema-pc-servidor---con-neofetch
:DESCRIPTION:
:EXPORT_DATE: 2020-06-30 19:57
:CATEGORY: bash
:TAG: informacion
:IMAGE: ./images-blog/neofetch.png
:END:
Neofetch es una aplicación para terminal desarrollada en bash, que muestra información del sistema, pc, servidor, etc...
#+HTML: <center>
[[./images-blog/neofetch.png]]
#+HTML: </center>

Ha diferentes opciones de personalización, mediante el archivo de configuración. Vamos a ver como se instala y configura.

** Instalación
En debian, ubuntu, raspberry os,...
#+begin_src 
sudo apt install neofetch
#+end_src

** Iniciar
Para iniciar la aplicación, tan simple como:
#+begin_src 
neofetch
#+end_src

De forma automática, creará un nuevo archivo de configuración.

#+begin_src 
nano ~/.config/neofetch/config.conf
#+end_src

Aquí podemos añadir que aparezca más información como nuestra ip pública, privada, usuario,...

Si una vez configurado, quieres que te aparezca neofetch por defecto, sin hacer uso del archivo de configuración, ejecutaremos:
#+begin_src 
neofetch  --config noney
#+end_src

O especificar una ruta por defecto del archivo de configuración
#+begin_src 
neofetch --config ~/dotfile/neofetch/config.conf
#+end_src


* DONE Listar paquetes instalados y hacer un poco de limpieza
:PROPERTIES:
:TITLE: Listar paquetes instalados y hacer un poco de limpieza
:EXPORT_FILE_NAME: listar-paquetes-instalados-y-hacer-un-poco-de-limpieza
:DESCRIPTION:
:EXPORT_DATE: 2020-07-02 19:50
:CATEGORY: paquetes
:TAG: apt
:IMAGE: ./images-blog/bash.png
:END:

Ha llegado el momento de hacer limpieza. Vamos a listar todos los paquetes que hay instalados en nuestra distro y desinstalar aquellos que ya no utilizamos. 

Pasado un largo tiempo, de tanto instalar programas, ya no recuerdo ni lo que tengo instalado. Este método me ayuda a dejar mi sistema operativo más limpio y optimizado.
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

*Recuerda desinstalar solo aquellos paquetes que conoces*. Por tu seguridad, haz una copia en un archivo de texto con el nombre de todos los paquetes que tienes antes de desinstalarlos. 

Desinstalar paquetes que no conozcas, puede provocar que tu sistema operativo no funcione correctamente o dejen de funcionar cosas como el Wifi, Bluetooth, etc...

** Listar todos los paquetes instalado
Vamos a ver todos los paquetes instalados

 #+begin_src 
dpkg --get-selections
 #+end_src

Buscar un paquete filtrando por nombre

#+begin_src 
dpkg --get-selections | grep syncthing
 #+end_src

** Hacer una copia de todos los paquetes instalados en un archivo de texto plano, .txt.
Esto es ideal, para si eliminas algún paquete que pueda hacer que algo no funcione, refrescarte la mente para volver a instalarlo

#+begin_src 
dpkg --get-selections > ~/paquetes_instalados.txt
#+end_src




* DONE FileRun. Un Nextcloud-Owncloud más ligero para almacenar tus archivos
:PROPERTIES:
:TITLE: FileRun. Un Nextcloud-Owncloud más ligero para almacenar tus archivos
:EXPORT_FILE_NAME: filerun-un-nextcloud-owncloud-mas-ligero-para-almacenar-tus-archivos
:DESCRIPTION:
:EXPORT_DATE: 2020-07-02 21:45
:CATEGORY: nube
:TAG: nextcloud,owncloud
:IMAGE: ./images-blog/filerun.png
:END:


Lo que apareció como un enlace más, casi sin importancia en el grupo de uGeek en Telegram, enlace publicado por José Jiménez, se va a convertir en uno de mis servicios imprescindibles en el día a día.

Lo mejor que tiene Nextcloud respecto a la sincronización de archivos, lo tiene FileRun.
#+HTML: <center>
[[./images-blog/filerun.png]]
#+HTML: </center>

Es que es muchísimo más ligero que Nextcloud o nubes públicas como Google Drive, Dropbox,... pero respecto a estas últimas, con la ventaja además de tener todos los archivos tú. Al final, es como instalar un servidor webdav, pero con interfaz web de administración.

Tener una página web de administración, permite más opciones que un servidor WebDav. Estás son algunas de las características que incluye FileRun.

- Control de versiones de archivos
- Compartir directorios o archivos con otros usuarios de la misma nube, pudiendo editarlos y trabajar en equipo.
- Compartir archivos de forma pública sin necesidad de tener cuenta de usuario.
- Previsualización y edición de archivos de texto plano, imágenes, hojas de cálculo, geolocalización, etcétera...
- Poder utilizar las aplicaciones de Nextcloud, Owncloud tanto de escritorio cómo dispositivo móvil. (Utiliza la API Nextcloud)

Permite separar los archivos en tres grupos. 

- Fotos. Gracias a la aplicación móvil de Nextcloud, puedo tener un backup clasificado de mis fotos en FileRun, del mismo modo que lo harías con Nextcloud. FileRun las clasificará también por fecha, tag, últimas fotos,...

- Música. Los archivos MP3 que estén dentro de tu nube FileRun, serán clasificados por álbum, autor,...

 
También permite una búsqueda de archivos avanzada.

Actualmente tengo en mi escritorio y dispositivo móvil, la aplicación de Nextcloud para la subida y bajada de archivos, así como la sincronización bidireccional en mi escritorio, todo ello vinculada a FileRun.

Gracias al servicio WebDav qué incluye FileRun, podrás utilizar aplicaciones de notas como Joplin, Orgzly o el todo.txt con SimpleTask.

La gran diferencia respecto a Nextcloud - OwnCloud, es que *no es Software Libre* y solo permite 3 usuarios en el servidor. Si quieres ampliar en números de usuarios, tendrás que pagar la licencia.

** Docker Compose
Vamos a utilizar docker compose para levantar los dos contenedores tal como explica en la documentación. 

Lo he montado tanto en mi servidor, vps y Raspberry a la primera sin problemas.

Copia el los docker-compose.yml en una carpeta y levántalos con:
#+begin_src 
docker-compose up -d
#+end_src

** Docker amd64

#+begin_src 
version: '2'

services:
  db:
    image: mariadb:10.1
    environment:
      MYSQL_ROOT_PASSWORD: your_mysql_root_password
      MYSQL_USER: your_filerun_username
      MYSQL_PASSWORD: your_filerun_password
      MYSQL_DATABASE: your_filerun_database
    volumes:
      - $HOME/docker/filerun/db:/var/lib/mysql

  web:
    image: afian/filerun
    environment:
      FR_DB_HOST: db
      FR_DB_PORT: 3306
      FR_DB_NAME: your_filerun_database
      FR_DB_USER: your_filerun_username
      FR_DB_PASS: your_filerun_password
      APACHE_RUN_USER: www-data
      APACHE_RUN_USER_ID: 33
      APACHE_RUN_GROUP: www-data
      APACHE_RUN_GROUP_ID: 33
    depends_on:
      - db
    links:
      - db:db
    ports:
      - "80:80"
    volumes:
      - $HOME/docker/filerun/html:/var/www/html
      - $HOME/docker/filerun/user-files:/user-files
#+end_src


- https://docs.filerun.com/docker
** Docker arm o Raspberry Pi
#+begin_src 
version: '2'

services:
  db:
    image: jsurf/rpi-mariadb
    environment:
      MYSQL_ROOT_PASSWORD: your_mysql_root_password
      MYSQL_USER: your_mysql_username
      MYSQL_PASSWORD: your_mysql_password
      MYSQL_DATABASE: your_mysql_database
      PUID: 1000
      PGID: 1000
      TZ: Europe/London
    volumes:
      - $HOME/docker/filerun/db:/var/lib/mysql

  web:
    image: afian/filerun:arm32v7
    environment:
      FR_DB_HOST: db
      FR_DB_PORT: 3306
      FR_DB_NAME: your_mysql_database
      FR_DB_USER: your_mysql_username
      FR_DB_PASS: your_mysql_password
      APACHE_RUN_USER: pi
      APACHE_RUN_USER_ID: 1000
      APACHE_RUN_GROUP: pi
      APACHE_RUN_GROUP_ID: 1000
    depends_on:
      - db
    links:
      - db:db
    ports:
      - "80:80"
    volumes:
      - $HOME/docker/filerun/html:/var/www/html
      - $HOME/docker/filerun/user-files:/user-files
#+end_src

- https://docs.filerun.com/docker-arm (Raspberry)

** Docker Traefik
Yo lo tengo montado traefik en una red llamada *web*. Sustituye el dominio duckdns por el tuyo.
#+begin_src 
  db:
    image: mariadb:10.1
    environment:
      MYSQL_ROOT_PASSWORD: your_mysql_root_password
      MYSQL_USER: your_filerun_username
      MYSQL_PASSWORD: your_filerun_password
      MYSQL_DATABASE: your_filerun_database
    volumes:
      - $HOME/docker/filerun/db:/var/lib/mysql
    networks:
      - web
      
  web:
    image: afian/filerun
    container_name: filerun
    restart: unless-stopped
    environment:
      FR_DB_HOST: db
      FR_DB_PORT: 3306
      FR_DB_NAME: your_filerun_database
      FR_DB_USER: your_filerun_username
      FR_DB_PASS: your_filerun_password
      APACHE_RUN_USER: www-data
      APACHE_RUN_USER_ID: 33
      APACHE_RUN_GROUP: www-data
      APACHE_RUN_GROUP_ID: 33
    depends_on:
      - db
    links:
      - db:db
    ports:
      - "800:80"
    volumes:
      - $HOME/docker/filerun/html:/var/www/html
      - $HOME/docker/filerun/user-files:/user-files
    networks:
      - web
    labels:
     - traefik.backend=filerun
     - traefik.frontend.rule=Host:dominio.duckdns.org
     - traefik.docker.network=web
     - traefik.port=80
     - traefik.enable=true

networks:
 web:
  external: true
#+end_src

** Iniciando
La primera vez que iniciamos FileRun, tenemos que introducir el usuario y contraseña por defecto (*superuser*). 

Recuerda sustituirlo una vez hayas entrado en la sesión, por el usuario y contraseña que desees.

- usuario:      superuser
- contraseña :  superuser
** Conexión webdav
Para conectarte con cualquier cliente *webdav*, tenemos que introducir el siguiente tipo de url:

#+begin_src 
https://misitio.filerun.com/dav.php/
#+end_src

** Licencia
Puedes ver los precios para obtener la licencia en https://filerun.com/enterprise

** Fuentes
- https://filerun.com
- Documentación: https://docs.filerun.com/Welcome 

* DONE FileRun. Cambiando el idioma por defecto
:PROPERTIES:
:TITLE: FileRun. Cambiando el idioma por defecto
:EXPORT_FILE_NAME: filerun-cambiando-el-idioma-por-defecto
:DESCRIPTION:
:EXPORT_DATE: 2020-07-06 20:06
:CATEGORY: filerun
:TAG: nube
:IMAGE: ./images-blog/filerun.png
:END:

Por defecto, el docker de FileRun viene en inglés, pero si deseas cambiarlo a castellano o cualquier otro idioma, puedes hacerlo gracias a las traducciones disponibles en [[https://github.com/filerun/translations][uno de los repositorios de FileRun en GitHub]].

#+HTML: <center>
[[./images-blog/filerun.png]]
#+HTML: </center>

Si copiaste la ubicación del docker-compose que hice en el artículo de FileRun, es tan sencillo como ir al directorio donde están las traducciones:

#+begin_example bash
~/docker/filerun/html/system/data/translations
#+end_example

Por defecto, el único archivo que viene es *english.php*. Yo lo que hice fué moverlo de directorio y borrar el directorio *translation*.

Después, cloné el repositorio con las traducciones en todos los idiomas:

#+begin_example
cp ~/docker/filerun/html/system/data/translations/english.php ~/
rm -Rf ~/docker/filerun/html/system/data/translations
git clone https://github.com/filerun/translations.git ~/docker/filerun/html/system/data/
mv ~/english.php ~/docker/filerun/html/system/data/translations
#+end_example

Ahora al iniciar FileRun, te permite cambiar entre todos los idiomas disponibles.

Si quieres que FileRun siempre esté en un idioma en concreto, tendrás que seleccionar el idioma que desees en el apartado de configuración.


- https://github.com/filerun
- https://github.com/filerun/translations




* DONE FileRun. Utilizando tu hora local
:PROPERTIES:
:TITLE: FileRun. Utilizando tu hora local
:EXPORT_FILE_NAME: filerun-utilizando-tu-hora-local
:DESCRIPTION:
:EXPORT_DATE: 2020-07-07 17:48
:CATEGORY: filerun
:TAG: nube,nextcloud
:IMAGE: ./images-blog/filerun.png
:END:

Por defecto, FileRun no lleva la hora local del lugar donde estás situado. Vamos a crear un archivo *config.php*, para que coincida la hora de sincronización o modificación de archivos con tu hora local.
#+HTML: <center>
[[./images-blog/filerun.png]]
#+HTML: </center>

Modifica o crea un nuevo archivo *config.php*

#+begin_src 
~/docker/filerun/html/customizables/config.php
#+end_src

Añade el siguiente contenido, con tu zona horaria.
#+begin_example
<?php
date_default_timezone_set("Europe/Madrid");
#+end_example

Ahora FileRun te mostrará la fecha correcta en tus archivos.

* DONE Gelli y Jellyamp. Clientes de Jellyfin para Android y Escritorio Linux, Windows y Mac
:PROPERTIES:
:TITLE: Clientes de Jellyfin para Android y Escritorio Linux, Windows y Mac
:EXPORT_FILE_NAME: clientes-de-jellyfin-para-android-y-escritorio-linux-windows-y-mac
:DESCRIPTION:
:EXPORT_DATE: 2020-07-11 21:40
:CATEGORY: jellyfin
:TAG: servidor
:IMAGE: ./images-blog/jellyfin.png
:END:

Crecen los clientes de Jellyfin.
#+HTML: <center>
[[./images-blog/jellyfin.png]]
#+HTML: </center>


** Gelli




#+HTML: <center>
[[./images-blog/gelli.png]]
#+HTML: </center>


- [[https://github.com/dkanada/gelli][Fuente]]


** Jellyamp
El desarrollador de esta app, se resistia a cambiar del servidor Plex a Jellyfin, por la aplicación PlexAmp.

Cuando se publicó Gelli, decidío desarrollar JellyAmp inspirada en PlexAmp.

- [[https://github.com/m0ngr31/jellyamp][Fuente]]

#+HTML: <center>
[[./images-blog/jellyamp.png]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/jellyamp1.png]]
#+HTML: </center>
#+HTML: <center>
[[./images-blog/jellyamp2.png]]
#+HTML: </center>


* DONE Procesos que consumen más CPU y RAM en Linux
:PROPERTIES:
:TITLE: Procesos que consumen más CPU y RAM en Linux
:EXPORT_FILE_NAME: procesos-que-consumen-mas-cpu-y-ram-en-linux
:DESCRIPTION:
:EXPORT_DATE: 2020-08-14 22:10
:CATEGORY: bash
:TAG: ram,cpu,zsh
:IMAGE: ./images-blog/bash.png
:END:


Hoy el script que tengo ejecutando en mi Raspberry, para comprobar la temperatura, me ha enviado un mensaje de alta temperatura
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Ha sido por la transcodificación de un contenido multimedia en jellyfin. Comprobar que procesos consumen más memoria o CPU, es tan sencillo como ejecutar htop o top.

De todas maneras, recuerdo que había un par de comandos que te permitían hacer esto de un modo más sencillo.

** Procesos que consumen más RAM

#+begin_src 
 ps aux --width 30 --sort -rss | head
#+end_src

También podemos hacer la consulta de otro modo. 

#+begin_src 
ps aux | awk '{print $2, $4, $11}' | sort -k2r | head -n 15
#+end_src

** Procesos que consumen más CPU

#+begin_src 
ps -Ao user,uid,comm,pid,pcpu,tty --sort=-pcpu | head -n 6
#+end_src
** Fuente
- https://blog.desdelinux.net/con-el-terminal-mostrar-los-10-procesos-que-mas-memoria-consumen/
- https://www.ochobitshacenunbyte.com/2018/01/29/como-saber-que-procesos-consumen-mas-cpu-y-memoria-en-linux/



* DONE Suscribirte al RSS de canales de YouTube
:PROPERTIES:
:TITLE: Suscribirte al RSS de canales de YouTube
:EXPORT_FILE_NAME: suscribirte-al-rss-de-canales-de-youtube
:DESCRIPTION:
:EXPORT_DATE: 2020-08-15 20:45
:CATEGORY: rss
:TAG: youtube
:IMAGE: ./images-blog/youtube.png
:END:

No acostumbro a utilizar la aplicación de YouTube, en cambio, FreshRSS la utilizo a diario. Para seguir los Canales de YouTube que más me interesan, me gustaría suscribirme al RSS, que no está de un modo visible.
#+HTML: <center>
[[./images-blog/youtube.png]]
#+HTML: </center>

Vamos a ver como suscribirnos a Canales de YouTube mediante el Feed RSS.

** Métodos

Hay 4 métodos de hacerlo y dos modos de extraer el RSS, ya que hay algunos canales que han registrado el nombre del Canal y otros no.

Así que obtener el rss, necesitaremos ver el final de la url principal del canal de YouTube y ver esta acaba con el nombre del Canal o el id.

** Canales con Nombre

Sitúate en la página principal del Canal.

Añade el nombre del canal que aparece al final de la *url*, a continuación de *user=*, siguiendo este patrón:

#+begin_src 
https://www.youtube.com/feeds/videos.xml?user=
#+end_src

Por ejemplo la url del Canal de NASeros es =https://www.youtube.com/user/naseros=. Por lo tanto, el Feed para suscribirme será:
#+begin_src 
https://www.youtube.com/feeds/videos.xml?user=naseros
#+end_src



** Canales que no tienen nombre. Tiene id


El Canal de Pelado Nerd no tiene nombre, así que el método anterior no servirá. Su url es https://www.youtube.com/channel/UCrBzBOMcUVV8ryyAU_c6P5g. 

La combinación de números y letras del final de la url, es el *id* del canal.

Así que siguiendo un poco el modelo anterior, en este caso será:

#+begin_src 
https://www.youtube.com/feeds/videos.xml?channel_id=
#+end_src

El rss del canal de Pelado Nerd sería:

#+begin_src 
https://www.youtube.com/feeds/videos.xml?channel_id=UCrBzBOMcUVV8ryyAU_c6P5g
#+end_src



** Buscando en el código fuente de la página
Otro método para buscar el rss, pero que a veces puede que no funcione, es buscar dentro del código fuente de la página:

1.- Seleccionamos ver el *Código fuente de la página*, para ver todo el código *html*.
2.- Buscamos el la página, habitualmente suele ser con el atajo *Ctrl+f*, la palabra rss
3.- En el código aparecerá algo así 

#+begin_src 
<link rel="alternate" type="application/rss+xml" title="RSS" href="https://www.youtube.com/feeds/videos
#+end_src

** Google nos facilita el trabajo

Si lo que quieres es exportar todas tus subscripciones de canales de YouTube, desde tu cuenta de YouTube:

- Ve a la página gestionar suscripciones: https://www.youtube.com/subscription_manager.
- En la parte inferior de la página, encontrarás la opción *Exportar a lectores de RSS*. Exporta el archivo *opml* que te permitirá importar todas las fuentes en servidor o cliente *rss*.



* DONE Compilar i3wm para Debian, Ubuntu y otras derivadas
:PROPERTIES:
:TITLE: Compilar i3wm para Debian, Ubuntu y otras derivadas
:EXPORT_FILE_NAME: compilar-i3wm-para-debian-ubuntu-y-otras-derivadas
:DESCRIPTION:
:EXPORT_DATE: 2020-08-16 14:00
:CATEGORY: i3wm
:TAG: debian,ubuntu
:IMAGE: ./images-blog/i3wm.png
:END:




Si utilizas Debian o versiones antiguas de Ubuntu, en los repositorios no está disponible la última versión i3wm.
#+HTML: <center>
[[./images-blog/i3wm.png]]
#+HTML: </center>

En Debian Buster, la versión disponible en repositorios es de Enero del 2019, en cambio compilando, siempre tendremos la última versión. En el momento de este artículo, la última versión disponible es la versión 4.18.2 (2020-07-26).  Este artículo te puede servir de modelo para posteriores versiones, únicamente cambiando el número de versión y quizás, instalando alguna dependencia nueva si te lo pide la terminal.

Vamos con la compilación, que veréis que es muy sencilla
** Instalar Dependencias
Esta son algunas dependencias necesarias

#+begin_src 
sudo apt-get install libxcb1-dev 
libxcb-keysyms1-dev \
libxcb-util0-dev \
libxcb-icccm4-dev \
libyajl-dev \
libstartup-notification0-dev  \
libxcb-randr0-dev \
libev-dev \
libxcb-xinerama0-dev \
libpango1.0-dev \
libxcursor-dev \
libxcb-cursor-dev\
libxcb-xkb-dev \
libxkbcommon-dev \
libxkbcommon-x11-dev \
libxcb-xrm-dev
#+end_src

** Descargamos la última versión

Podemos ver y descargar la última versión estable, desde https://i3wm.org/.

Descargaremos con wget la última versión en el momento de este artículo =4.18.2=.
#+begin_src 
wget https://i3wm.org/downloads/i3-4.18.2.tar.bz2 -O - | tar -xj
cd i3-4.18.2
mkdir -p build && cd build
#+end_src

** Compilamos
#+begin_src 
../configure
make
sudo make install
#+end_src
** Conclusión
A disfrutar plenamente de la última versión de i3wm!!!
** Reiniciamos
Reiniciamos la sesión de usuario, para iniciar la nueva versión de i3wm.
** Fuentes
- https://lunaticgeek.com/compila-i3wm/
- https://faq.i3wm.org/question/68/how-to-build-and-install-i3-from-sources.1.html
- https://i3wm.org/

#+HTML: <center>
[[./images-blog/i3wm.png]]
#+HTML: </center>


* DONE gossa. Servidor ligero de archivos, multimedia, desarrollado en Go
:PROPERTIES:
:TITLE: gossa. Servidor ligero de archivos, multimedia, desarrollado en Go
:EXPORT_FILE_NAME: gossa-servidor-ligero-de-archivos-multimedia-desarrollado-en-go
:DESCRIPTION:
:EXPORT_DATE: 2020-08-18 17:30
:CATEGORY: servicios
:TAG: go
:IMAGE: ./images-blog/gossa.png
:END:

Un nuevo servicio en Go. Gossa es un servidor web rápido y simple para ver archivos, sin dependencia y con menos de 200 líneas de código, de modo que es muy fácil de revisar.

#+HTML: <center>
[[./images-blog/gossa.png]]
#+HTML: </center>

La interfaz de usuario es muy simple y viene por defecto, con:

- navegador de archivos/directorios
- Arrastrar y soltar para subir archivos/directorios
- Interfaz de usuario predeterminada solo pesa 110 kb, pudiendo manejar archivos, moverlos, renombrarlos, borrarlos
- navegador de imágenes
- Reproducción video en streaming
- Editor de texto simple
- atajos de teclado
- servidor estático rápido de golang, llena fácilmente el ancho de banda disponible
- bloquear configuración fácil/segura de múltiples cuentas

** Instalación

Nos conectamos a la *release* disponible en GitHub y descargamos la correspondiente a nuestra arquitectura o sistema operativo.
https://github.com/pldubouilh/gossa/releases

En este caso, voy a utilizar de ejemplo Linux y arquitectura ARM

*** ARM

Descargamos la release correspondiente, en el momento de redactar el artículo, está la versión 0.1.6.

#+begin_src 
wget https://github.com/pldubouilh/gossa/releases/download/v0.1.6/gossa-linux-arm
#+end_src

#+begin_src 
mv gossa-linux-arm gossa
#+end_src


#+begin_src 
./gossa -h 192.168.1.100 ~/directorio
#+end_src

Hacer correr, por ejemplo, por el Puerto 8888
#+begin_src d
 ./gossa -h 192.168.1.100 -p 8888 ~/directorio
#+end_src

*** Docker arquitectura amd64 

#+begin_src 
docker run -v ~/directorio:/shared -p 8001:8001 pldubouilh/gossa
#+end_src
** Ayuda

Gossa también la podemos utilizar con la terminal.

Para mostrar las opciones disponibles, ejecutamos la ayuda:

#+begin_src 
./gossa -h
#+end_src

#+begin_src 
flag needs an argument: -h

usage: ./gossa ~/directory-to-share

  -h string
    	host to listen to (default "127.0.0.1")
  -k	
    	skip hidden files (default true)
  -p string
    	port to listen to (default "8001")
  -prefix string
    	url prefix at which gossa can be reached, e.g. /gossa/ (slashes of importance) (default "/")
  -ro
    	read only mode (no upload, rename, move, etc...)
  -symlinks
    	follow symlinks WARNING: symlinks will by nature allow to escape the defined path (default: false)
  -verb
    	verbosity
#+end_src

** Fuentes

- https://github.com/pldubouilh/gossa
- https://github.com/pldubouilh/gossa/releases
- https://hub.docker.com/r/pldubouilh/gossa



* DONE Kanboard
:PROPERTIES:
:TITLE: Kanboard
:EXPORT_FILE_NAME: kanboard
:DESCRIPTION:
:EXPORT_DATE: 2020-08-19 17:30
:CATEGORY: docker
:TAG: kanban
:IMAGE: ./images-blog/kanboard.png
:END:


Kanboard es un servicio que nos permite gestionar nuestras tareas siguiendo el método Kanban.

#+HTML: <center>
[[./images-blog/kanboard.png]]
#+HTML: </center>

He instalado el servicio después de mucho tiempo tanto en mi Raspberry como mi Servidor amd64, de un modo súper sencillo y rápido, gracias a Docker.


** Docker

El docker lo tenemos disponible tanto para arquitectura amd64, arm, arm64...

*** Docker amd64


#+begin_src 
docker create --name=kanboard \
      -p "80:80" \
      -v $HOME/docker/kanboard/data:/var/www/app/data \
      -v $HOME/docker/kanboard/plugins:/var/www/app/plugins \
      -v $HOME/docker/kanboard/ssl:/etc/nginx/ssl \
kanboard/kanboard:latest
#+end_src


*** Docker arm o Raspberry Pi 

#+begin_src 
docker create --name=kanboard \
      -p "80:80" \
      -v $HOME/docker/kanboard/data:/var/www/app/data \
      -v $HOME/docker/kanboard/plugins:/var/www/app/plugins \
      -v $HOME/docker/kanboard/ssl:/etc/nginx/ssl \
kanboard/kanboard:arm32v7-latest
#+end_src

*** Docker más arquitecturas 
Si quieres otra arquitectura, revisa en [[https://hub.docker.com/r/kanboard/kanboard/tags][DockerHub]] todas las etiquetas disponibles, cambiando la etiqueta que corresponda.

*** Docker Compose para Traefik y Proxy Inverso
Si utilizas un proxy inverso, podemos montar el contenedor con este docker-compose

#+begin_src 
version: "3"

networks:
  web:
      external: true

services:
  kanboard:
    image: kanboard/kanboard:latest
    ports:
      - "83:80"
    volumes:
      - $HOME/docker/kanboard/data:/var/www/app/data
      - $HOME/docker/kanboard/plugins:/var/www/app/plugins
      - $HOME/docker/kanboard/ssl:/etc/nginx/ssl
    labels:
      - traefik.backend=kanboard
      - traefik.frontend.rule=Host:kanboard.midominio.duckdns.org
      - traefik.docker.network=web
      - traefik.port=80
      - traefik.enable=true
    networks:
      - web
#+end_src


** Iniciar Kanboard y cambiar usuario y contraseña
La primera vez que iniciamos Kanboard, para utilizar el servicio, utilizaremos el usuario y contraseña por defecto:


Username: admin
Password: admin


Es importante el cambiar el usuario y contraseña. Para hacerlo, lo haremos del siguiente modo pulsando en el icono del usuario.

- Cambiar usuario: Gestión de usuarios -> Acciones -> Editar perfil
- Cambiar contraseña: Gestión de usuarios -> Acciones -> Cambiar contraseña


** Habilitar plugins
Por defecto y por seguridad, vienen deshabilitada la posibilidad de instalar plugins. Si deseas instalar cualquiera del gran número de plugins disponibles, entramos dentro del contenedor y editaremos con vi el archivo *config.php*.


#+begin_src 
vi /var/www/app/config.php
#+end_src

#+begin_src 
// Plugins directory
define('PLUGINS_DIR', 'plugins');
 
// Plugins directory URL
define('PLUGIN_API_URL', 'https://kanboard.org/plugins.json');
 
// Enable/Disable plugin installer
define('PLUGIN_INSTALLER', true);
#+end_src

*Restaurar el docker, para que los cambios tengan efecto*.


** Temas
Hay varios temas disponible, que harán de Kanboard una interfaz más amigable, bonita y moderna.

En mi caso he instalado la de *Greenwing*.

** Notificaciones
Si creamos un Bot con su Token en Telegram, podremos hacer que nos notifique cada vez que cambiemos una tarea de estado.

Recuerda el Podcast y Artículo donde explico como hacerlo paso a paso : https://ugeek.github.io/post/2018-02-09-kanboard-con-notificaciones-en-telegram.html

** Fuentes
- https://docs.kanboard.org/en/latest/admin_guide/docker.html
- https://hub.docker.com/r/kanboard/kanboard/tags
- https://www.ochobitshacenunbyte.com/2019/04/26/kanboard-instalacion-de-plugins-via-web/
- https://github.com/Confexion/Greenwing


* DONE Instalar última versión de Go en Raspberry, ARM o amd64
:PROPERTIES:
:TITLE: Instalar última versión de Go en Raspberry, ARM o amd64
:EXPORT_FILE_NAME: instalar-ultima-version-de-go-en-raspberry-arm-o-amd64
:DESCRIPTION:
:EXPORT_DATE: 2020-08-21 17:25
:CATEGORY: go
:TAG: arm,amd64
:IMAGE: ./images-blog/go.png
:END:




Cada vez utilizo más aplicaciones en Go y aunque en las últimas versiones de Debian, Ubuntu, Raspbian,... viene en los repositorios oficiales, no disponemos de la última versión.
#+HTML: <center>
[[./images-blog/go.png]]
#+HTML: </center>

Vamos a ver como descargarla e instalarla, veréis que sencillo

Yo pongo de ejemplo arquitectura para ARM y amd64, si utilizas alguna otra arquitectura, descarga la correspondiente siguiendo los mismos pasos que muestro.

** Instalar Go en Raspberry o ARM
*** Descargando en instalando Go

Descargamos la versión más reciente [[https://golang.org/doc/install][desde la página de go]].

#+begin_src 
wget https://storage.googleapis.com/golang/go1.14.6.linux-armv6l.tar.gz
sudo tar -C /usr/local -xvf go1.14.6.linux-armv6l.tar.gz
#+end_src

*** Añadimos a .bashr o .zshrc

#+begin_src 
export GOPATH=$HOME/go
export PATH=/usr/local/go/bin:$PATH:$GOPATH/bin
#+end_src

*** Volvemos a cargar el archivo .bashrc o .zshrc

#+begin_src 
source ~/.bashrc
#+end_src
o
#+begin_src 
source ~/.zshrc
#+end_src

*** Comprobamos que esta todo ok y que versión tenemos

#+begin_src 
go version                         
#+end_src

** Instalar Go en amd64
*** Descargando en instalando Go


#+begin_src 
wget https://storage.googleapis.com/golang/go1.14.6.linux-amd64.tar.gz
sudo tar -C /usr/local -xvf go1.14.6.linux-amd64.tar.gz
#+end_src

*** Añadimos a .bashr o .zshrc

#+begin_src 
export GOPATH=$HOME/go
export PATH=/usr/local/go/bin:$PATH:$GOPATH/bin
#+end_src

*** Volvemos a cargar el archivo .bashrc o .zshrc

#+begin_src 
source ~/.bashrc
#+end_src
o
#+begin_src 
source ~/.zshrc
#+end_src

*** Comprobamos que esta todo ok y que versión tenemos

#+begin_src 
go version                         
#+end_src



#+begin_src  bash
wget https://dl.google.com/go/go1.14.6.linux-amd64.tar.gz
#+end_src

Tras la descarga, vamos a descomprimir el archivo descargado en el directorio /usr/local:

#+begin_src 
sudo tar -xvf go1.14.2.linux-amd64.tar.gz -C /usr/local/
#+end_src

** Fuentes

- https://golang.org/dl/
- https://golang.org/doc/install

#+HTML: <center>
[[./images-blog/go.png]]
#+HTML: </center>


* DONE Saltando de un directorio a otro con Jump
:PROPERTIES:
:TITLE: Saltando de un directorio a otro con Jump
:EXPORT_FILE_NAME: saltando-de-un-directorio-a-otro-con-jump
:DESCRIPTION:
:EXPORT_DATE: 2020-08-16 21:59
:CATEGORY: bash
:TAG: terminal
:IMAGE: ./images-blog/jump.svg
:END:



Después de escuchar el Podcast de Lorenzo, atareao.es, he decidido probar este complemento para la terminal que hacía mucho tiempo que estaba buscando y no sabía que existía.

#+HTML: <center>
[[./images-blog/jump.svg]]
#+HTML: </center>

Es un complemento súper productivo para moverte por la terminal.

Jump se integra con su shell y aprende sobre sus hábitos de navegación al realizar un seguimiento de los directorios que visita. Te proporciona el directorio más visitado para el término de búsqueda más corto que escriba.


** Instalación
*** Con Go 
Si no tienes instalado Go, busca el artículo donde explico como hacerlo.

Si lo tienes instalado, la instalación es tan simple como:

#+begin_src 
go get github.com/gsamokovarov/jump
#+end_src

*** Ubuntu 
#+begin_src 
wget https://github.com/gsamokovarov/jump/releases/download/v0.30.1/jump_0.30.1_amd64.deb && sudo dpkg -i jump_0.30.1_amd64.deb
#+end_src

*** Mac y otras distros 
Visita el repositorio de Jump donde explica como instalarlo en el resto de distros



** Añadir a bash o zsh

Para bash y zsh, añade la siguiente línea a ~/.bashrc, ~/bash_profileo o ~/.zshrc


#+begin_src 
eval "$(jump shell)"
#+end_src


** Cambiar j por z

Si deseas utilizar otra letra para ejecutar jump, por ejemplo la letra z

#+begin_src 
eval "$(jump shell --bind=z)"
#+end_src


** Funcionamiento
Jump usa la coincidencia difusa para encontrar el directorio deseado para saltar. Solo necesita de 2 a 5 caracteres para saltar al directorio.

Para alimentar jump de los directorios que utilizamos frecuentemente, tendremos que movernos por estos de un modo normal como lo hacemos habitualmente y jump irá añadiendo estos a su base de datos.


Pusamos *j* seguido de los *caracteres que coincidan con el directorio* que buscamos y pulsamos *enter*.

Ejemplo: Buscar el directorio docker

#+begin_src 
j dk
#+end_src

Si no coincide con lo que buscabamos, ya que queríamos ir al directorio ~/docker/docker, escribiremos *j* + *enter* y nos aparecerá la siguiente sugerencia.

#+begin_src 
j
#+end_src

** Listado de directorios añadidos en la base de datos de jump

#+begin_src 
jump top
#+end_src

** Eliminar una ruta de directorio
Nos situamos en ese directorio y ejecutamos

#+begin_src 
jump forget 
#+end_src


** Ayuda
Para ver todas las opciones disponibles, veremos la ayuda

#+begin_src 
jump
#+end_src



** Fuentes
- https://github.com/gsamokovarov/jump
- https://www.atareao.es/podcast/personalizar-el-terminal/




* DONE Jellycon. La mejor experiencia de Jellyfin en Kodi
:PROPERTIES:
:TITLE: Jellycon. La mejor experiencia de Jellyfin en Kodi
:EXPORT_FILE_NAME: jellycon-la-mejor-experiencia-de-jellyfin-en-kodi
:DESCRIPTION:
:EXPORT_DATE: 2020-08-18 17:30
:CATEGORY: jellyfin
:TAG: kodi
:IMAGE: ./images-blog/jellycon.png
:END:



JellyCon es un complemento ligero de Kodi que te permite navegar y reproducir archivos multimedia desde su servidor Jellyfin directamente dentro de la interfaz de Kodi.

A diferencia del [[https://www.jellyfin.eu/kodi/][plugin de Kodi]], que necesita de hacer una primera sincronización con el servidor para integrar todas las bibliotecas en Kodi y a partir de entonces, comenzar a reproducir el contenido, Jellycon Reproduce directamente de Kodi al servidor. 

Esto es genial!!! es instalar el plugin y comenzar a reproducir. El proceso es muchísimo más rápido y sencillo

#+HTML: <center>
[[./images-blog/jellycon.png]]
#+HTML: </center>


Como puedes imaginar, no solo tienes acceso a tus Películas, Series,... sino también tu música.

Ahora en tu PC con Linux, Windows, Mac, Android, Android TV,... No tienes escusas para reproducir Jellyfin con Kodi

** Instalación
Accede al [[https://github.com/mcarlton00/jellycon/releases][repositorio de GitHub de Jellycon]], descarga la última versión del plugin con extensión *.zip* y instálalo en Kodi.


A disfrutar de Jellyfin!!!!


** Fuentes
- https://github.com/mcarlton00/jellycon/releases

* DONE Visualizar aparte una Cabecera de un OrgMode en Emacs
:PROPERTIES:
:TITLE: Visualizar aparte una Cabecera de un OrgMode en Emacs
:EXPORT_FILE_NAME: visualizar-aparte-una-cabecera-de-un-orgmode-en-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-09-03 13:43
:CATEGORY: emacs
:TAG: orgmode
:IMAGE: ./images-blog/orgmode.png
:END:

Hay momentos, al menos a mi me pasa, de todas las notas que voy registrando en mi orgmode, quiero exporta una ya sea en formato txt, pdf, markdown,...

#+HTML: <center>
[[./images-blog/orgmode.png]]
#+HTML: </center>

Para poder visualizar esa cabecera (nota) en un buffer aparte, para poder trabajar con ella, o como en el caso de este artículo, exportarla a formato de texto plano (.txt), es tan simple como:

- Nos situamos en la cabecera que queremos visualizar en un buffer aparte
- Utilizamos el siguiente atajo:

#+BEGIN_SRC 
C-c C-x b
#+END_SRC

Recuerda que Emacs lo único que está haciendo, es visualizar esa cabecera aparte, pero todo aquello que modifiques, lo harás en el orgmode que abriste al principio, no es una archivo aparte.

** OrgMode a txt
Una vez visualizado en un buffer aparte, voy a exportarlo a texto plano

#+BEGIN_SRC 
C-c C-e t u
#+END_SRC

** Orgmode a pdf
También podríamos exportarlo a pdf

#+BEGIN_SRC 
C-c C-e l p
#+END_SRC

** Orgmode a markdown
Emacs también permite exportar a markdown desde nuestro orgmode

#+BEGIN_SRC 
C-c C-e M m
#+END_SRC



 
* DONE Navidrome. La alternativa a Airsonic desarrollada en Go
:PROPERTIES:
:TITLE: Navidrome. La alternativa a Airsonic desarrollada en Go
:EXPORT_FILE_NAME: navidrome-la-alternativa-a-airsonic-desarrollada-en-go
:DESCRIPTION:
:EXPORT_DATE: 2020-09-16 18:30
:CATEGORY: subsonic
:TAG: servidor,música
:IMAGE: ./images-blog/navidrome.png
:END:

Navidrome es un servidor de música en streaming de código abierto basado en un servidor web. Da la libertad de escuchar tu colección de música desde cualquier navegador o dispositivo móvil. ¡Es como tu Spotify personal!

[[https://translate.googleusercontent.com/translate_c?depth=1&hl=es&pto=aue&rurl=translate.google.com&sl=auto&sp=nmt4&u=https://www.navidrome.org/demo/&usg=ALkJrhjBly3sgwOBW24Lv39WuY7lBJAAxw][Aquí hay una Demo]], para que veáis el servicio en acción.

#+HTML: <center>
[[./images-blog/navidrome.png]]
#+HTML: </center>


Cosas que me gustan:
- Página web del servicio
- Descargar canción o album en formato .zip
- Actualización si añades nuevo álbum
- Descargar archivos de listas y exportar listas en .m3u
- Listas públicas y privadas

** Características

- Maneja colecciones de música muy grandes
- Transmite prácticamente cualquier formato de audio disponible
- Lee y usa todos sus metadatos
- Gran soporte para compilaciones (álbumes de varios artistas) y conjuntos de cajas (álbumes de varios discos)
- Multiusuario , cada usuario tiene sus propios recuentos de reproducción, listas de reproducción, favoritos, etc.
- Uso de recursos muy bajo
- Multiplataforma , se ejecuta en macOS, Linux y Windows. También se proporcionan imágenes de Docker
- Binarios listos para usar para todas las plataformas principales, incluida Raspberry Pi
- Supervisa automáticamente su biblioteca en busca de cambios, importa nuevos archivos y recarga nuevos metadatos
- Interfaz web  moderna y receptiva basada en Material UI
- Compatible con todos los clientes Subsonic, Madsonic, Airsonic
- Transcodificación sobre la marcha. Se puede configurar por usuario/reproductor. Se admite la codificación Opus
- Traducido a varios idiomas

** Docker

Tenemos disponible el docker para arquitectura amd64, arm y arm64. 



#+BEGIN_SRC 
docker run -d \
   --name navidrome \
   --restart=unless-stopped \
   --user $(id -u):$(id -g) \
   -v $HOME/docker/media/Musica:/music \
   -v $HOME/navidrome:/data \
   -p 4533:4533 \ 
   -e ND_LOGLEVEL=info \
   deluan/navidrome:latest
#+END_SRC


** Docker Raspberry

Vamos, que también podemos instalarlo en nuestra Raspberry Pi.

#+BEGIN_SRC 
docker run -d \
   --name navidrome \
   --restart=unless-stopped \
   --user $(id -u):$(id -g) \
   -v $HOME/docker/media/Musica:/music \
   -v $HOME/navidrome:/data \
   -p 4533:4533 \ 
   -e ND_LOGLEVEL=info \
   deluan/navidrome:pi
#+END_SRC

** Docker Compose

#+begin_src 
version: "3"
services:
  navidrome:
    image: deluan/navidrome:latest
    ports:
      - "4533:4533"
    environment:
      # All options with their default values:
      ND_MUSICFOLDER: /music
      ND_DATAFOLDER: /data
      ND_SCANINTERVAL: 1m
      ND_LOGLEVEL: info  
      ND_PORT: 4533
      ND_TRANSCODINGCACHESIZE: 100MB
      ND_SESSIONTIMEOUT: 24h
      ND_BASEURL: ""
    volumes:
      - "$HOME/navidrome:/data"
      - "$HOME/docker/media/Musica:/music:ro"

#+end_src

** Reescanear biblioteca

Entramos dentro del docker y ejecutamos
#+BEGIN_SRC 
/app/navidrome scan -f
#+END_SRC

** Ayuda

#+BEGIN_SRC 
/app/navidrome --help
#+END_SRC

** Fuentes

- https://www.navidrome.org
- https://github.com/deluan/navidrome
- https://www.navidrome.org/docs/installation/docker/


* DONE Croc, la aplicación que nos permite enviar o compartir archivos, directorios, texto... a cualquier dispositivo esté donde esté de un modo fácil con la terminal
:PROPERTIES:
:TITLE: Croc, la aplicación que nos permite enviar o compartir archivos, directorios, texto... a cualquier dispositivo esté donde esté de un modo fácil con la terminal
:EXPORT_FILE_NAME: croc-la-aplicacion-que-nos-permite-enviar-o-compartir-archivos-directorios-texto--a-cualquier-dispositivo-este-donde-este-de-un-modo-facil-con-la-terminal
:DESCRIPTION:
:EXPORT_DATE: 2020-09-20 14:58
:CATEGORY: sincronización
:TAG: sync,go
:IMAGE: ./images-blog/croc.png
:END:

Croc una herramienta que permite transferir archivos,directorios y texto, de forma sencilla y segura, entre dos PC's, servidores, etc.... 

#+HTML: <center>
[[./images-blog/croc.png]]
#+HTML: </center>

AFAIK, croc es la única herramienta de transferencia de archivos CLI que hace todo lo siguiente:

- permite que dos computadoras transfieran datos (usando un Relay)
- proporciona *cifrado de extremo a extremo* (mediante PAKE)
- permite transferencias sencillas entre plataformas (Windows, Linux, Mac)
- permite múltiples transferencias de archivos
- permite reanudar transferencias interrumpidas
- No es necesario servidor local o reenvío de puertos
- más rápido que wormhole , rsync , scp a través de la compresión y multiplexación (aceleraciones de 1.5xa 4x)
ipv6-first con respaldo de ipv4.

** Instalación
La instalación podemos hacerla de diferente maneras, también en función de tu sistema operativo
*** Instala la última release Linux
#+BEGIN_SRC 
curl https://getcroc.schollz.com | bash
#+END_SRC

*** Instalación por snap
#+BEGIN_SRC 
sudo snap install croc
#+END_SRC

*** Termux 
Si utilizas Termux en Android:
#+BEGIN_SRC 
pkg install croc
#+END_SRC
** Funcionamiento

Una vez instalado croc en ambos dispositivos, para enviar una archivo o directorio, de un dispositivo a otro, utilizaremos el siguiente comando
#+BEGIN_SRC  shell
croc send archivo.txt

Code is: adrian-freedom-harris
On the other computer run

croc adrian-freedom-harris
#+END_SRC

Para poder recibir este archivo en el otro dispositivo, introduciremos en su terminal *adrian-freedom-harris*

El archivo, queda a la espera en el dispositivo origen, a la espera que introduzcamos el siguiente código en el dispositivo destino:

#+BEGIN_SRC  shell
croc adrian-freedom-harris
#+END_SRC

El otro dispositivo preguntará, si queremos descargar el archivo. Pulsaremos *y* para descargarlo.

#+BEGIN_SRC  shell
croc adrian-freedom-harris

Accept 'archivo.txt' (208.3 kB)? (y/n)
#+END_SRC

El resultado será..
#+BEGIN_SRC 
Receiving (<-[::1]:44504)
unison.log 100% |████████████████████| (203/203 kB, 2.943 MB/s) [0s:0s] ✔️
#+END_SRC

Ahora mi Raspberry se comunica perfectamente con mi PC

** Código personalizado
Para automatizar esta tarea mediante un script, podemos enviar con la opción *--code* nuestro propio código (debe tener más de 4 caracteres).

#+BEGIN_SRC 
croc send --code [código_frase] ~/directorio 
#+END_SRC

** Enviando texto
Para enviar un texto:
#+BEGIN_SRC 
croc send --text "hola mundo"
#+END_SRC


** Utilizando tuberías: stdin y stdout

#+BEGIN_SRC 
cat archivo.txt | croc send
#+END_SRC


** Creando un servidor relay
Entre las opciones de croc, incluye el levantar tu propio relay:

#+BEGIN_SRC 
croc relay
#+END_SRC

De forma predeterminada, utiliza los puertos TCP 9009-9013. Asegúrate de abrirlos. Puede personalizar los puertos (por ejemplo croc relay --ports 1111,1112), pero debe tener un mínimo de 2 puertos para el relay.

El primer puerto es para la comunicación y los puertos subsiguientes se utilizan para la transferencia de datos multiplexados.

Puede enviar archivos usando su relay ingresando *--relay* para cambiar el relé que está usando si desea personalizar el suyo propio.

#+BEGIN_SRC  shell
croc --relay "mirelay.duckdns.org:9009" send archivo.txt
#+END_SRC

al enviar, solo necesita incluir el primer puerto (puerto de comunicación). Los puertos posteriores son para la transferencia de datos que se transmitirán al usuario desde el relay.

** Relay por Docker

Para crear nuestro relay permanente utilizando docker:

#+BEGIN_SRC 
docker run -d -p 9009-9013:9009-9013 -e CROC_PASS='TU_CONTRASEÑA' schollz/croc
#+END_SRC

Asegúrate de incluir la contraseña para el relay, de lo contrario, se rechazarán las solicitudes.

#+BEGIN_SRC  shell
croc --pass TU_CONTRASEÑA --relay "mirelay.duckdns.org:9009" send archivo
#+END_SRC


En el otro dispositivo pondremos para descargar utilizando nuestro relay:
#+BEGIN_SRC 
croc --pass TU_CONTRASEÑA --relay "mirelay.duckdns.org:9009" código_que_dará_nuestro_relay
#+END_SRC

** Código personalizado en mi Relay

#+BEGIN_SRC 
croc --pass CONTRASEÑA --relay "mi.duckdns.org:9009"  send --code este-es-mi-codigo archivo.txt
#+END_SRC

Para no tener que confirmar la descarga, en casos que quieras automatizar esta con un script, utilizaremos *--yes*

#+BEGIN_SRC 
croc --yes --pass CONTRASEÑA --relay "mi.duckdns.org:9009"  send --code este-es-mi-codigo archivo.txt
#+END_SRC

** Exportando mi contraseña

Si no deseas tener que poner en tu dispositivo siempre la contraseña de tu realy, ya que tu dispositivo en de confianza, puedes añadir una variable en ./bashrc o ./zshrc, para que al iniciar bash cargue esta contraseña. Yo he utilizado:

#+BEGIN_SRC 
export CROC_RELAY="--yes --pass CONTRASEÑA --relay mi.duckdns.org:9009"
#+END_SRC

Ahora para enviar lo hariamos:
#+BEGIN_SRC 
croc $(echo $CROC_RELAY)  send --code este-es-mi-codigo archivo.txt
#+END_SRC


** Ayuda 
Comando de ayuda y más opciones:
#+BEGIN_SRC 
croc -h
NAME:       
   croc - easily and securely transfer stuff from one computer to another

USAGE:
   Send a file:
      croc send file.txt

   Send a file with a custom code:
      croc send --code secret-passphrase file.txt

VERSION:
   v8.3.2-7d155ad

COMMANDS:
   send     send a file (see options with croc send -h)
   relay    start your own relay (optional)
   help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --remember      save these settings to reuse next time (default: false)
   --debug         toggle debug mode (default: false)
   --yes           automatically agree to all prompts (default: false)
   --stdout        redirect file to stdout (default: false)
   --no-compress   disable compression (default: false)
   --ask           make sure sender and recipient are prompted (default: false)
   --relay value   address of the relay (default: "142.93.177.120:9009") [$CROC_RELAY]
   --relay6 value  ipv6 address of the relay (default: "[2604:a880:800:c1::14c:1]:9009") [$CROC_RELAY6]
   --out value     specify an output folder to receive the file (default: ".")
   --pass value    password for the relay (default: "pass123") [$CROC_PASS]
   --help, -h      show help (default: false)
   --version, -v   print the version (default: false)
#+END_SRC
** Fuentes 
- https://github.com/schollz/croc
- https://hub.docker.com/r/schollz/croc




* DONE Crear enlaces simbólicos a otros directorios o archivos
:PROPERTIES:
:TITLE: Crear enlaces simbólicos a otros directorios o archivos
:EXPORT_FILE_NAME: crear-enlaces-simbolicos-a-otros-directorios-o-archivos
:DESCRIPTION:
:EXPORT_DATE: 2020-10-05 21:18
:CATEGORY: bash
:TAG: zsh
:IMAGE: ./images-blog/bash.png
:END:

Un enlace simbólico, sería algo similar a crear un acceso directo de un directorio o archivo, a otro dentro en un mismo dispositivo.
#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

** Crear enlace simbólico

Crear enlace simbólico con directorios:

#+BEGIN_SRC  shell 
ln -s ~/directorio_origen ~/directorio_destino
#+END_SRC

También podemos hacerlo con archivos:

#+BEGIN_SRC  shell 
ln -s ~/directorio_origen/archivo.txt ~/directorio_destin/archivo.txt
#+END_SRC

** Eliminar en enlace simbólico

Para eliminar el enlace simbólico.

#+BEGIN_SRC 
unlink ruta_del_enlace 
#+END_SRC

También podríamos utilizar:

#+BEGIN_SRC 
rm ~/directorio_destino
#+END_SRC

Enlace simbólico de un directorio:
#+BEGIN_SRC 
rm -Rf ~/directorio_destino
#+END_SRC




* DONE Montar un usb, tarjeta SD, disco duro o SSD formateado en EXT4, FAT32 o NTFS, en un directorio con Linux
:PROPERTIES:
:TITLE: Montar un usb, tarjeta SD, disco duro o SSD formateado en EXT4, FAT32 o NTFS, en un directorio con Linux
:EXPORT_FILE_NAME: 
:DESCRIPTION:
:EXPORT_DATE: 2020-10-07 07:30
:CATEGORY: bash
:TAG: sd,ssd,usb
:IMAGE: ./images-blog/sd.png
:END:

Vamos a ver los comandos para montar un usb, SD, disco duro o SSD, en un directorio desde la terminal.

#+HTML: <center>
[[./images-blog/sd.png]]
#+HTML: </center>

** Ver unidades
Para saber el nombre de la partición que utiliza el sistema operativo y así poder montarla en el directorio que deseemos:

#+BEGIN_SRC  shell
lsblk
#+END_SRC

** Montar unidad EXT4

#+BEGIN_SRC 
sudo mount -t ext4 -o defaults /dev/sda1 /media/usb
#+END_SRC


** Montar unidad FAT32

#+BEGIN_SRC 
sudo mount -t vfat /dev/sdb1 /media/usb
#+END_SRC

** Montar unidad NTFS

Para montar una partición NTFS, utilizaremos:

#+BEGIN_SRC 
sudo mount -t ntfs-3g /dev/sdb1 /media/usb
#+END_SRC

** Comprobar si la unidad se ha montado correctamente
Sería tan fácil como hacer un *ls* en el directorio donde hemos montado la unidad, pero para ver un resumen del resto de unidades:

#+BEGIN_SRC 
df -l
#+END_SRC

** Desmontar una unidad

#+BEGIN_SRC 
sudo umount /media/usb
#+END_SRC


* DONE duf. Visualizando el almacenamiento
:PROPERTIES:
:TITLE: duf. Visualizando el almacenamiento
:EXPORT_FILE_NAME: duf-visualizando-el-almacenamiento
:DESCRIPTION:
:EXPORT_DATE: 2020-10-10 08:15
:CATEGORY: bash
:TAG: tesrminal
:IMAGE: ./images-blog/bash.png
:END:

Normalmente para ver el tamaño de mis unidades de almacenamiento, utilizo =du -h.= Si quiero conocer el tamaño de un directorio, me situo dentro del mismo y hago un =du -hs=.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>

Ahora con duf, ver el almacenamiento de mis unidades, es muchísimo más simple y sencillo porque podemos verlo de un modo más gráfico.

** Instalación
[[https://github.com/muesli/duf/releases/tag/v0.4.0][Descargaremos el paquete .deb de la última release]], para arquitectura que tengamos: amd64, arm,... siempre y cuando utilices una derivada de Debian.

En el caso de instalarlo en una Raspberry, vamos a proceder como habitualmente lo hacemos:
#+BEGIN_SRC 
sudo dpkg -i duf_0.4.0_linux_armv6.deb
#+END_SRC

Recuerda que los archivos *.deb* no se auto-actualizan, así que si quieres tener la última versión, tendrás que seguir este proceso con cada actualización.

** Ejecutando duf
Para ver de un modo gráfico el tamaño de todas las particiones, ejecutaremos duf de este modo tan simple

#+BEGIN_SRC 
duf
#+END_SRC


** Fuentes
- https://github.com/muesli/duf
- https://nksistemas.com/ver-espacio-de-disco-en-linux-con-du


* DONE Buscar texto en un directorio, archivo,... con grep y find
:PROPERTIES:
:TITLE: Buscar texto en un directorio, archivo,... con grep y find
:EXPORT_FILE_NAME: buscar-texto-en-un-directorio-archivo---con-grep-y-find
:DESCRIPTION:
:EXPORT_DATE: 2020-10-14 07:27
:CATEGORY: bash
:TAG: terminal
:IMAGE: ./images-blog/bash.png
:END:

Grep y find vienen instaladas por defecto en todas las distros y tienen un potencial increíble.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Con grep y find podemos buscar directorios, archivos o el texto que contenga estos archivos. Ideal para encontrar todo aquello que no recuerdes donde lo has dejado.

** grep
*** Buscar en un directorio con grep
Buscamos la palabra “texto” en el directorio "directorio":

#+BEGIN_SRC  sh
grep "texto" ~/directorio
#+END_SRC

*** Busqueda recursiva con grep
La opción *-R*, busca de forma recursiva en los subdirectorios 

- -R = Recursivo mostrando también los enlaces simbólicos
- -r = recursivo
- -i = No distingue entre mayúsculas o minúsculas
- -l = Mostrar la ruta del archivo que tenga la palabra buscada

#+BEGIN_SRC  C
grep -R "texto" ~/directorio
#+END_SRC


#+BEGIN_SRC  C
grep -ir "texto" ~/directorio
#+END_SRC

Buscar la palabra linux en el contenido de todos los archivos y mostrar su ruta

#+BEGIN_SRC 
 grep -ril "linux" .
#+END_SRC

*** Excluyendo determinados directorios o archivos

#+BEGIN_SRC 
grep -ir --color --exclude-dir={directorio1,directorio2,.git} --exclude={*.txt,*.md} /
#+END_SRC

** find
*** Buscar archivo, directorios con find
A partir del directorio donde estamos, busca recursivamente:

#+BEGIN_SRC 
find . -name "archivo"
#+END_SRC

Buscar en todo el dispositivo:
#+BEGIN_SRC 
find / -name "archivo"
#+END_SRC

No tener en cuenta mayúsculas o minúsculas
#+BEGIN_SRC 
find . -iname "archivo"
#+END_SRC

Podemos utilizar expresiones regulares para ayudarnos a encontrar lo que deseamos, si no recordamos la palabra exacta.

No recuerdo como empieza y acaba la palabra "archivo"...

#+BEGIN_SRC 
find . -iname "*chiv*"
#+END_SRC




* DONE Docker: Wireguard para Raspberry, Ubuntu, Debian,...
:PROPERTIES:
:TITLE: Docker: Wireguard para Raspberry, Ubuntu, Debian,...
:EXPORT_FILE_NAME: docker-wireguard-para-raspberry-ubuntu-debian--
:DESCRIPTION:
:EXPORT_DATE: 2020-10-19 14:15
:CATEGORY: vpn
:TAG: wireguard,terminal,servidor,raspberry,ubuntu
:IMAGE: ./images-blog/wireguard.png
:END:

Ya hemos visto como instalar  Wireguard con los paquetes disponibles en la distro o añadiendo el repositorio del desarrollador. También os expliqué como crear el archivo de configuración del servidor y clientes con el script wgc.

#+HTML: <center>
[[./images-blog/wireguard.png]]
#+HTML: </center>

Hoy vamos a montar todo de una vez con docker, gracias nuevamente a la comunidad LinuxServer.io que nos lo pone pone muy muy fácil.

He seguido paralelamente también la documentación el artículo de Joan del blog de [[https://geekland.eu/instalar-y-configurar-el-servidor-vpn-wireguard-con-docker/][geekland.eu]], que me ha ayudado mucho.

** Crear el Docker
Creando el docker de wireguard, el servidor y peers:
- He puesto las DNS de  Cloudflare, 1.1.1.1 y Quad9 (IBM) 9.9.9.9.
- Vamos a generar solo *1* peer. Si quieres generar más, indica el número de peers que deseas
- El puerto para acceder al servidor, lo he desviado al 33555. Recuerda que si hacemos esto, cuando vayamos a utilizar los clientes, *el peer generado utilizará el puerto 51820 , así que deberemos modifiarlo a 33555*.


#+begin_src  shell
docker create \
  --name=wireguard \
  --cap-add=NET_ADMIN \
  --cap-add=SYS_MODULE \
  -e PUID=1000 \
  -e PGID=1000 \
  -e TZ=Europe/Madrid \
  -e SERVERURL=midominio.duckdns.org \
  -e SERVERPORT=51820 \
  -e PEERS=1 \
  -e PEERDNS=1.1.1.1,9.9.9.9  \
  -e INTERNAL_SUBNET=10.13.13.0  \
  -p 33555:51820/udp \
  -v $HOME/docker/wireguard/config:/config \
  -v /lib/modules:/lib/modules \
  --sysctl="net.ipv4.conf.all.src_valid_mark=1" \
  --restart unless-stopped \
  linuxserver/wireguard
#+end_src

** Clientes o Peers

Una vez levantado el docker de wireguard, podremos ver los código QR de los peers desde la terminal, para añadir a nuestro móvil.

#+begin_src 
docker logs -f wireguard
#+end_src

*Toda la configuración tanto del servidor como los peers, está en el volumen que se ha creado con el contenedor* =$HOME/docker/wireguard/config=.

** Crear nuevos peers o clientes

Para crear nuevos peers, tan sencillo como:

#+begin_src 
docker exec -it wireguard /app/add-peer
#+end_src

Nos creará un nuevo peer o cliente y previsualizará el código QR en pantalla

** Mostrar QR de un peer o cliente ya creado 
Aunque como he comentado antes, toda la configuración tanto del servidor como los peers está en =$HOME/docker/wireguard/config=, también podemos previsualizarlo directamente desde la terminal con:

#+BEGIN_SRC 
docker exec -it wireguard /app/show-peer 1
#+END_SRC

En este caso, estamos previsualizando el código QR del peer 1. Indica el número de peer que desees.

** Eliminar Peers o Clientes

Accederemos a nuestro volumen de configuración y eliminaremos directamente el peer que no deseemos

#+begin_src 
cd $HOME/docker/wireguard/config
#+end_src

Borro el peer3
#+begin_src 
rm -r peer3
#+end_src

Elimina en el archivo de configuración del servidor *wg0.conf*, los valores del peer eliminado

#+begin_src 
nano wg0.conf
#+end_src

** Conclusión
Como veis, en menos de 5 minutos tenemos creada una vpn con docker de un modo seguro y sencillo.




* PUBLICAR Añadiendo texto al principio de cada línea en Emacs
  :PROPERTIES:
  :ARCHIVE_TIME: 2020-10-24 sáb 20:10
  :ARCHIVE_FILE: /webdav/org/tareas.org
  :ARCHIVE_OLPATH: Artículos
  :ARCHIVE_CATEGORY: tareas
  :ARCHIVE_TODO: PUBLICAR
  :END:
:LOGBOOK:
CLOCK: [2020-10-24 sáb 19:45]--[2020-10-24 sáb 20:07] =>  0:22
:END:

Como podéis imaginar, yo creo y edito mis scripts con Emacs. Hay momentos en los que quiero añadir "#" en un bloque de código para que no se ejecute, o simplemente, añadir un comentario respecto al código.

Esto con emacs es muy sencillo.

Yo lo utilizo para los scripts, pero como puedes imaginar, puedes añadir a cada línea el texto que desees.

** Añadir texto al inicio de cada línea
1) Pulsa =Ctrl+Space= para seleccionar el texto
2) Ahora pulsa =C-x r t=. Equivale a =M-x string-rectangle=
3) Añade el texto que quieres añadir al inicio de cada línea

** Eliminar el texto al principio de cada línea
1) Selecciona el texto al principio de cada línea, con =C-x Space=
2) pulsa =suprimir=.




* DONE Añadiendo texto al principio de cada línea en Emacs
:PROPERTIES:
:TITLE: Añadiendo texto al principio de cada línea en Emacs
:EXPORT_FILE_NAME: anadiendo-texto-al-principio-de-cada-linea-en-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-10-24 20:25
:CATEGORY: emacs
:TAG: bash,script
:IMAGE: ./images-blog/emacs.png
:END:


Como podéis imaginar, yo creo y edito mis scripts con Emacs. Hay momentos en los que quiero añadir "#" en un bloque de código para que no se ejecute, o simplemente, añadir un comentario respecto al código.


Esto con emacs es muy sencillo.

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>

Yo lo utilizo para los scripts, pero como puedes imaginar, puedes añadir a cada línea el texto que desees.

** Añadir texto al inicio de cada línea
1) Pulsa =Ctrl+Space= para seleccionar el texto
2) Ahora pulsa =C-x r t=. Equivale a =M-x string-rectangle=
3) Añade el texto que quieres añadir al inicio de cada línea

** Eliminar el texto al principio de cada línea
1) Selecciona el texto al principio de cada línea, con =C-x Space=
2) pulsa =suprimir=.



* DONE Borrando líneas en blanco de un texto con Emacs
:PROPERTIES:
:TITLE: Borrando líneas en blanco de un texto con Emacs
:EXPORT_FILE_NAME: borrando-lineas-en-blanco-de-un-texto-con-emacs
:DESCRIPTION:
:EXPORT_DATE: 2020-10-26 11:21
:CATEGORY: emacs
:TAG: terminal
:IMAGE: ./images-blog/emacs.png
:END:

A veces cuando copio un documento en la terminal, lo hace dejando líneas en blanco entre líneas. Para eliminar esto con Emacs es muy sencillo:

#+HTML: <center>
[[./images-blog/emacs.png]]
#+HTML: </center>


1) Seleccionamos todo el contenido del buffer con =C-x h=
2) Introducimos: =M-x flush-lines= RET =^$= RET

=flush-lines= significa que limpia las líneas que coincidan con una expresión regular, en este caso del principio al final =^$=, lo que interpreta como lineas en blanco.








* DONE s-screen. Gestionando mis procesos en segundo plano de un modo sencillo
:PROPERTIES:
:TITLE: s-screen. Gestionando mis procesos en segundo plano de un modo sencillo
:EXPORT_FILE_NAME: s-screen-gestionando-mis-procesos-en-segundo-plano-de-un-modo-sencillo
:DESCRIPTION:
:EXPORT_DATE: 2020-10-28 18:45
:CATEGORY: bash
:TAG: screen
:IMAGE: ./images-blog/bash.png
:END:

Este artículo es una recopilación de los dos anteriores, dónde íntegro todo lo aprendido dentro de un script.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Recordar los comandos, a veces suele ser una tarea dura, así que si no te quieres calentar la cabeza, una solución sería el crear alias o mejor aún, como en este caso, englobar dentro todo de un script, donde además podremos gestionar las respuestas a modo de menú sin tener que introducir ningún texto en la terminal. 

Rápido y sencillo

De todos los atajos que aprendimos, solo tenemos que recordar el de *Control + a + d*, para salir de la sesión.

** Instalación

El script está en GitHub, de manera que podemos instalarlo gracias a curl con este sencillo comando.

#+BEGIN_SRC 
sudo curl -L https://raw.githubusercontent.com/uGeek/s-screen/main/s -o /usr/bin/s && sudo chmod +x /usr/bin/s
#+END_SRC


** Funcionamiento

A partir de ahora, utilizaremos la letra *s* en lugar, para ejecutar el script.

Paralelamente, si así lo deseas, también puedes utilizar screen. Este método no te obliga a utilizar sí o sí el script.




** Crear una nueva sesión
Hay dos modos de crear una nueva sesión.

*** Crear sesión

Igual que hacemos con screen, en lugar de utilizar la palabra screen para iniciar una nueva sesión, en este caso utilizaremos la letra *s.*

#+BEGIN_SRC 
s
#+END_SRC

*** Crear sesión con nombre

Para crear una nueva sesión y además nombrarla, utilizaremos el comando:

#+BEGIN_SRC 
s n
#+END_SRC


recuerda que para salir de la sesión tienes que utilizar el atajo, control + a + d.

** Listar sesiones

Para listar las sesiones que están corriendo en este momento, utilizaremos el comando.

#+BEGIN_SRC 
s ls
#+END_SRC



** Cambiar nombre de una sesión

Una vez creada la sesión, hayas nombrado o no ésta, puedes cambiar el nombre o crear uno nuevo si previamente no lo has hecho.

Tan sencillo como utilizar el comando:

#+BEGIN_SRC 
s n
#+END_SRC

** Entrar dentro de una sesión

Para entrar en una de las sesiones están corriendo, utilizaremos el comando

#+BEGIN_SRC 
s i
#+END_SRC

Primero *s* coma listar a todas las sesiones que hay corriendo con un número delante, en produce el número de la sesión que quieres entrar y listo.

** Cerrar una sesión

Quizás lo te deseas es cerrar una sesión esté abierta con un proceso o no dentro.

Para ello utiliza el comando:

#+BEGIN_SRC 
s k
#+END_SRC

nuevamente  para todas las sesiones numeradas, induce el número de la sesión que quieres cerrar.

** Ayuda

#+BEGIN_SRC 
s h
#+END_SRC

** Conclusiones

Como puedes ver, de un modo sencillo podemos crear un script que nos permitan facilitarnos  poco vida y no tener que recordar complejos comandos.

Esto tengo que decir que crea dependencia del script, pero a la vez te hace disfrutar mucho más de la terminal. 

También aquel que crea el script, lo disfruta muchísimo.

Espero que disfrutéis del script.

* TODO Nuevas DNS de Cloudflare




* DONE Nuevas DNS de CloudFlare
:PROPERTIES:
:TITLE: Nuevas DNS de Cloudflare
:EXPORT_FILE_NAME: nuevas-dns-de-cloudflare
:DESCRIPTION:
:EXPORT_DATE: 2020-10-29 18:40
:CATEGORY: dns
:TAG: internet,web
:IMAGE: ./images-blog/cloudflare.png
:END:

Ahora se añade nuevos filtros a la familia de DNS CloudFlare.
#+HTML: <center>
[[./images-blog/cloudflare.png]]
#+HTML: </center>

** DNS sin filtros

CloudFlare sigue teniendo por defecto la  tradicional ruta de DNS 1.1.1.1

Esta dirección no tiene ningún filtro.

- 1.1.1.1

** Bloquear malware

 Ahora CloudFlare añade dos nuevas DNS para filtrar el malware.

- 1.1.1.2
- 1.0.0.2

** Bloquear malware y contenido para adultos

Ideal como control parental, CloudFlare añade dos nuevas rutas de DNS para filtrar el malware y el contenido de sitios de adultos.

- 1.1.1.3
- 1.0.0.3

* DONE Jellyfin Skin Manager. Repositorio para cambiar el tema de tu Jellyfin
:PROPERTIES:
:TITLE: Jellyfin Skin Manager. Repositorio para cambiar el tema de tu Jellyfin
:EXPORT_FILE_NAME: jellyfin-skin-manager-repositorio-para-cambiar-el-tema-de-tu-jellyfin
:DESCRIPTION:
:EXPORT_DATE: 2020-11-15 17:50
:CATEGORY: jellyfin
:TAG: docker
:IMAGE: ./images-blog/jellyfin.png
:END:

Dado que la comunidad está creando muchos temas para jellyfin, cambiando el aspecto de nuestro servidor multimedia, un desarrollador ha decidido crear un repositorio dentro de las extensiones de jellyfin, para que sea mucho más sencillo cambiar los temas a tan solo un clic.

#+HTML: <center>
[[./images-blog/jellyfin.png]]
#+HTML: </center>

Tengo que decir que ya había creado un repositorio donde estaba recopilando todos estos skins, pero el poderlo tener en una extensión tal como implementó jellyfin en las últimas actualizaciones, lo hace todavía mucho más sencillo.

La instalación es muy sencilla. 

** Instalación

1) En jellyfin, ves a Panel Control -> Extensiones -> Repositorios -> agregua y pegue este enlace 

#+BEGIN_SRC 
https://raw.githubusercontent.com/danieladov/JellyfinPluginManifest/master/manifest.json
#+END_SRC

2) Ves al Catálogo y busqua Skin Manager

3) Haz clic en él, e instalalo
4) Reinicia Jellyfin
5) Vuelve a Extensiones -> Mis Extensiones, y selecciona el tema que más te guste

Cambia de aspecto Jellyfin y disfruta de todos los temas disponibles

** Fuentes
- https://github.com/danieladov/jellyfin-plugin-skin-manager
* DONE Docker: Telegram de terminal para Raspberry Pi y amd64
:PROPERTIES:
:TITLE: Docker: Telegram de terminal para Raspberry Pi y amd64
:EXPORT_FILE_NAME: docker-telegram-de-terminal-para-raspberry-pi-y-amd64
:DESCRIPTION:
:EXPORT_DATE: 2020-12-06 19:46
:CATEGORY: telegram
:TAG: docker
:IMAGE: ./images-blog/telegram.png
:END:

He creado un docker para poder utilizar Telegram desde tu terminal, ya estes en tu PC o Raspberry Pi.

#+HTML: <center>
[[./images-blog/telegram.png]]
#+HTML: </center>

** Dockers en dos versiones
*** Crear docker para amd64
#+BEGIN_SRC sh
docker create \                                  
 --name telegram-cli  \
 -e TZ=Europe/Madrid \
 -v $HOME/docker/telegram-cli:/root/.telegram-cli \
  ugeek/telegram-cli:amd64
#+END_SRC

*** Crear docker para arm y Raspberry Pi
#+BEGIN_SRC sh
docker create \                                  
 --name telegram-cli  \
 -e TZ=Europe/Madrid \
 -v $HOME/docker/telegram-cli:/root/.telegram-cli \
  ugeek/telegram-cli:arm
#+END_SRC

** Iniciar el docker

#+BEGIN_SRC 
docker start telegram-cli
#+END_SRC

** Iniciar telegram-cli

#+BEGIN_SRC 
docker exec -it telegram-cli telegram-cli -N -W
#+END_SRC

** Fuente
- https://hub.docker.com/r/ugeek/telegram-cli

* DONE Conectandose por SSH introduciendo la contraseña en una única línea de terminal
:PROPERTIES:
:TITLE: Conectándote por SSH introduciendo la contraseña en una única línea de terminal
:EXPORT_FILE_NAME: conectandote-por-ssh-introduciendo-la-contrasena-en-una-unica-linea-de-terminal
:DESCRIPTION:
:EXPORT_DATE: 2020-12-07 17:03
:CATEGORY: bash
:TAG: ssh
:IMAGE: ./images-blog/bash.png
:END:

El mejor método para conectarse a un servidor por SSH, es enviando las llaves al servidor y no tener que estar introduciendo la contraseña.

Aparte de ser más rápido y cómodo, es mucho más seguro, ya que enviando las llaves, también puedes deshabilitar el tener que introducir la contraseña.

Pero si por algún motivo no tienes la posibilidad de enviar las llaves al servidor, siempre puedes utilizar sshpass.

#+HTML: <center>
[[./images-blog/bash.png]]
#+HTML: </center>


Sshpass es una herramienta que vienen todas las distros Linux pero no viene instalada por defecto y te permite el poder añadir en una única línea de terminal la dirección del servidor y la contraseña.

Cómo explicaba al inicio del artículo, es un método un poco inseguro ya que sí entra en el historial de todo aquello que hemos tecleado en la terminal o si añadimos esta opción en un script, queda de un modo visible la contraseña del servidor.

Vamos a ver cómo instalarlo y conocer algunos ejemplos. 

** Instalación

En todas distro derivadas de Debian lo haremos del siguiente modo

#+begin_src sh 
sudo apt install sshpass
#+end_src


** Utilizando sshpass

Conectarnos por ssh, suponiendo que nuestra ip es "192.168.1.100" y el usuario "pi", con la contraseña en una misma línea seria:

#+begin_example sh
sshpass -p 'contraseña' ssh pi@192.168.1.100
#+end_example


Para especificar un puerto, ejemplo puerto "9122"

#+begin_src sh
sshpass -p 'contraseña' ssh pi@192.168.1.100 -p 9122
#+end_src

* DONE Trilium. Notas jerarquicas en Markdown
:PROPERTIES:
:TITLE: Trilium. Notas jerarquicas en Markdown
:EXPORT_FILE_NAME: trilium-notas-jerarquicas-en-markdown
:DESCRIPTION:
:EXPORT_DATE: 2020-12-25 20:45
:CATEGORY: markdown
:TAG: servidor
:IMAGE: ./images-blog/trilium.png
:END:

Quizás ha llegado el momento de tomar notas para seres humanos, voy a
hablar de Trilum.

Trilium es un método jerárquico para tomar notas, tareas,... donde estás
se gestionan con un método jerarquico como el orgmode y las podemos
exportar a posterior a HTML, Markdown o incluso imprimirlas en pdf. 

#+HTML: <center>
[[./images-blog/trilium.png]]
#+HTML: </center>

El método para introducir el texto es mediante la sintaxis markdown.

He probado diferentes dockers para la arquitectura AMD64 y ARM y
finalmente me quedo con él dockers oficial para amd64 y otro que he
encontrado de (=hlince)=para arm, que funciona muy bien en Raspberry.

** Docker amd64
   :PROPERTIES:
   :CUSTOM_ID: docker-amd64
   :END:

El docker oficial y más actualizado para amd64 es:

#+BEGIN_EXAMPLE
     docker run -t -i -p 127.0.0.1:99:8080 -v ~/trilium-data:/root/trilium-data zadam/trilium
#+END_EXAMPLE

- [[https://github.com/zadam/trilium/wiki/Docker-server-installation]]

Fork ugeek

#+BEGIN_EXAMPLE
     docker run -t -i -p 127.0.0.1:99:8080 \
          -v ~/trilium-data:/root/trilium-data \
          ugeek/trilium:amd64
#+END_EXAMPLE

** Docker para arm
   :PROPERTIES:
   :CUSTOM_ID: docker-para-arm
   :END:

Es docker-compose para arm o Raspberry y funciona a la perfeción:

#+BEGIN_EXAMPLE
    trilium:
        image: hlince/trilium:latest-stable-arm
        restart: always
        ports:
        - 99:8080
        environment:
        - TRILIUM_DATA_DIR=/data
        volumes:
        - ./trilium/data:/data
#+END_EXAMPLE

- https://hub.docker.com/r/hlince/trilium

Fork de ugeek

#+BEGIN_EXAMPLE
    trilium:
        image: ugeek/trilium:arm
        restart: always
        ports:
        - 99:8080
        environment:
        - TRILIUM_DATA_DIR=/data
        volumes:
        - ./trilium/data:/data
#+END_EXAMPLE

** Fuentes
   :PROPERTIES:
   :CUSTOM_ID: fuentes
   :END:

- [[https://github.com/zadam/trilium]]
- https://www.electronjs.org/apps/trilium-notes



* TODO Trilium Web Clipper. Importando el contenido de una web a Trilium
:PROPERTIES:
:TITLE: Trilium Web Clipper. Importando el contenido de una web a Trilium
:EXPORT_FILE_NAME: trilium-web-clipper-importando-el-contenido-de-una-web-a-trilium
:DESCRIPTION:
:EXPORT_DATE: 2020-12-25 22:33
:CATEGORY: trilium
:TAG: markdown
:IMAGE: ./images-blog/web-clipper-trilium.png
:END:

#+HTML: <center>
[[./images-blog/web-clipper-trilium.png]]
#+HTML: </center>



